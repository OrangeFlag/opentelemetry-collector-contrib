// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"fmt"
	"strconv"
	"time"

	"go.opentelemetry.io/collector/pdata/pcommon"
	"go.opentelemetry.io/collector/pdata/pmetric"
)

// MetricSettings provides common settings for a particular metric.
type MetricSettings struct {
	Enabled bool `mapstructure:"enabled"`
}

// MetricsSettings provides settings for flinkmetricsreceiver metrics.
type MetricsSettings struct {
	FlinkmetricsJobCheckpointsCount                                 MetricSettings `mapstructure:"flinkmetrics.job.checkpoints.count"`
	FlinkmetricsJobLastCheckpointSize                               MetricSettings `mapstructure:"flinkmetrics.job.last_checkpoint.size"`
	FlinkmetricsJobLastCheckpointTime                               MetricSettings `mapstructure:"flinkmetrics.job.last_checkpoint.time"`
	FlinkmetricsJobRestartCount                                     MetricSettings `mapstructure:"flinkmetrics.job.restart.count"`
	FlinkmetricsJobmanagerStatusFlinkMemoryManagedTotal             MetricSettings `mapstructure:"flinkmetrics.jobmanager.status.flink.memory.managed.total"`
	FlinkmetricsJobmanagerStatusFlinkMemoryManagedUsed              MetricSettings `mapstructure:"flinkmetrics.jobmanager.status.flink.memory.managed.used"`
	FlinkmetricsJobmanagerStatusJvmClassLoaderClassesLoaded         MetricSettings `mapstructure:"flinkmetrics.jobmanager.status.jvm.class_loader.classes_loaded"`
	FlinkmetricsJobmanagerStatusJvmCPULoad                          MetricSettings `mapstructure:"flinkmetrics.jobmanager.status.jvm.cpu.load"`
	FlinkmetricsJobmanagerStatusJvmCPUTime                          MetricSettings `mapstructure:"flinkmetrics.jobmanager.status.jvm.cpu.time"`
	FlinkmetricsJobmanagerStatusJvmGarbageCollectorCollectionCount  MetricSettings `mapstructure:"flinkmetrics.jobmanager.status.jvm.garbage_collector.collection.count"`
	FlinkmetricsJobmanagerStatusJvmGarbageCollectorCollectionTime   MetricSettings `mapstructure:"flinkmetrics.jobmanager.status.jvm.garbage_collector.collection.time"`
	FlinkmetricsJobmanagerStatusJvmMemoryDirectTotalCapacity        MetricSettings `mapstructure:"flinkmetrics.jobmanager.status.jvm.memory.direct.total_capacity"`
	FlinkmetricsJobmanagerStatusJvmMemoryDirectUsed                 MetricSettings `mapstructure:"flinkmetrics.jobmanager.status.jvm.memory.direct.used"`
	FlinkmetricsJobmanagerStatusJvmMemoryHeapCommitted              MetricSettings `mapstructure:"flinkmetrics.jobmanager.status.jvm.memory.heap.committed"`
	FlinkmetricsJobmanagerStatusJvmMemoryHeapMax                    MetricSettings `mapstructure:"flinkmetrics.jobmanager.status.jvm.memory.heap.max"`
	FlinkmetricsJobmanagerStatusJvmMemoryHeapUsed                   MetricSettings `mapstructure:"flinkmetrics.jobmanager.status.jvm.memory.heap.used"`
	FlinkmetricsJobmanagerStatusJvmMemoryMappedTotalCapacity        MetricSettings `mapstructure:"flinkmetrics.jobmanager.status.jvm.memory.mapped.total_capacity"`
	FlinkmetricsJobmanagerStatusJvmMemoryMappedUsed                 MetricSettings `mapstructure:"flinkmetrics.jobmanager.status.jvm.memory.mapped.used"`
	FlinkmetricsJobmanagerStatusJvmMemoryMetaspaceCommitted         MetricSettings `mapstructure:"flinkmetrics.jobmanager.status.jvm.memory.metaspace.committed"`
	FlinkmetricsJobmanagerStatusJvmMemoryMetaspaceMax               MetricSettings `mapstructure:"flinkmetrics.jobmanager.status.jvm.memory.metaspace.max"`
	FlinkmetricsJobmanagerStatusJvmMemoryMetaspaceUsed              MetricSettings `mapstructure:"flinkmetrics.jobmanager.status.jvm.memory.metaspace.used"`
	FlinkmetricsJobmanagerStatusJvmMemoryNonHeapCommitted           MetricSettings `mapstructure:"flinkmetrics.jobmanager.status.jvm.memory.non_heap.committed"`
	FlinkmetricsJobmanagerStatusJvmMemoryNonHeapMax                 MetricSettings `mapstructure:"flinkmetrics.jobmanager.status.jvm.memory.non_heap.max"`
	FlinkmetricsJobmanagerStatusJvmMemoryNonHeapUsed                MetricSettings `mapstructure:"flinkmetrics.jobmanager.status.jvm.memory.non_heap.used"`
	FlinkmetricsJobmanagerStatusJvmThreadsCount                     MetricSettings `mapstructure:"flinkmetrics.jobmanager.status.jvm.threads.count"`
	FlinkmetricsOperatorRecordCount                                 MetricSettings `mapstructure:"flinkmetrics.operator.record.count"`
	FlinkmetricsOperatorWatermarkOutput                             MetricSettings `mapstructure:"flinkmetrics.operator.watermark.output"`
	FlinkmetricsTaskRecordCount                                     MetricSettings `mapstructure:"flinkmetrics.task.record.count"`
	FlinkmetricsTaskmanagerStatusFlinkMemoryManagedTotal            MetricSettings `mapstructure:"flinkmetrics.taskmanager.status.flink.memory.managed.total"`
	FlinkmetricsTaskmanagerStatusFlinkMemoryManagedUsed             MetricSettings `mapstructure:"flinkmetrics.taskmanager.status.flink.memory.managed.used"`
	FlinkmetricsTaskmanagerStatusJvmClassLoaderClassesLoaded        MetricSettings `mapstructure:"flinkmetrics.taskmanager.status.jvm.class_loader.classes_loaded"`
	FlinkmetricsTaskmanagerStatusJvmCPULoad                         MetricSettings `mapstructure:"flinkmetrics.taskmanager.status.jvm.cpu.load"`
	FlinkmetricsTaskmanagerStatusJvmCPUTime                         MetricSettings `mapstructure:"flinkmetrics.taskmanager.status.jvm.cpu.time"`
	FlinkmetricsTaskmanagerStatusJvmGarbageCollectorCollectionCount MetricSettings `mapstructure:"flinkmetrics.taskmanager.status.jvm.garbage_collector.collection.count"`
	FlinkmetricsTaskmanagerStatusJvmGarbageCollectorCollectionTime  MetricSettings `mapstructure:"flinkmetrics.taskmanager.status.jvm.garbage_collector.collection.time"`
	FlinkmetricsTaskmanagerStatusJvmMemoryDirectTotalCapacity       MetricSettings `mapstructure:"flinkmetrics.taskmanager.status.jvm.memory.direct.total_capacity"`
	FlinkmetricsTaskmanagerStatusJvmMemoryDirectUsed                MetricSettings `mapstructure:"flinkmetrics.taskmanager.status.jvm.memory.direct.used"`
	FlinkmetricsTaskmanagerStatusJvmMemoryHeapCommitted             MetricSettings `mapstructure:"flinkmetrics.taskmanager.status.jvm.memory.heap.committed"`
	FlinkmetricsTaskmanagerStatusJvmMemoryHeapMax                   MetricSettings `mapstructure:"flinkmetrics.taskmanager.status.jvm.memory.heap.max"`
	FlinkmetricsTaskmanagerStatusJvmMemoryHeapUsed                  MetricSettings `mapstructure:"flinkmetrics.taskmanager.status.jvm.memory.heap.used"`
	FlinkmetricsTaskmanagerStatusJvmMemoryMappedTotalCapacity       MetricSettings `mapstructure:"flinkmetrics.taskmanager.status.jvm.memory.mapped.total_capacity"`
	FlinkmetricsTaskmanagerStatusJvmMemoryMappedUsed                MetricSettings `mapstructure:"flinkmetrics.taskmanager.status.jvm.memory.mapped.used"`
	FlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceCommitted        MetricSettings `mapstructure:"flinkmetrics.taskmanager.status.jvm.memory.metaspace.committed"`
	FlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceMax              MetricSettings `mapstructure:"flinkmetrics.taskmanager.status.jvm.memory.metaspace.max"`
	FlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceUsed             MetricSettings `mapstructure:"flinkmetrics.taskmanager.status.jvm.memory.metaspace.used"`
	FlinkmetricsTaskmanagerStatusJvmMemoryNonHeapCommitted          MetricSettings `mapstructure:"flinkmetrics.taskmanager.status.jvm.memory.non_heap.committed"`
	FlinkmetricsTaskmanagerStatusJvmMemoryNonHeapMax                MetricSettings `mapstructure:"flinkmetrics.taskmanager.status.jvm.memory.non_heap.max"`
	FlinkmetricsTaskmanagerStatusJvmMemoryNonHeapUsed               MetricSettings `mapstructure:"flinkmetrics.taskmanager.status.jvm.memory.non_heap.used"`
	FlinkmetricsTaskmanagerStatusJvmThreadsCount                    MetricSettings `mapstructure:"flinkmetrics.taskmanager.status.jvm.threads.count"`
}

func DefaultMetricsSettings() MetricsSettings {
	return MetricsSettings{
		FlinkmetricsJobCheckpointsCount: MetricSettings{
			Enabled: true,
		},
		FlinkmetricsJobLastCheckpointSize: MetricSettings{
			Enabled: true,
		},
		FlinkmetricsJobLastCheckpointTime: MetricSettings{
			Enabled: true,
		},
		FlinkmetricsJobRestartCount: MetricSettings{
			Enabled: true,
		},
		FlinkmetricsJobmanagerStatusFlinkMemoryManagedTotal: MetricSettings{
			Enabled: true,
		},
		FlinkmetricsJobmanagerStatusFlinkMemoryManagedUsed: MetricSettings{
			Enabled: true,
		},
		FlinkmetricsJobmanagerStatusJvmClassLoaderClassesLoaded: MetricSettings{
			Enabled: true,
		},
		FlinkmetricsJobmanagerStatusJvmCPULoad: MetricSettings{
			Enabled: true,
		},
		FlinkmetricsJobmanagerStatusJvmCPUTime: MetricSettings{
			Enabled: true,
		},
		FlinkmetricsJobmanagerStatusJvmGarbageCollectorCollectionCount: MetricSettings{
			Enabled: true,
		},
		FlinkmetricsJobmanagerStatusJvmGarbageCollectorCollectionTime: MetricSettings{
			Enabled: true,
		},
		FlinkmetricsJobmanagerStatusJvmMemoryDirectTotalCapacity: MetricSettings{
			Enabled: true,
		},
		FlinkmetricsJobmanagerStatusJvmMemoryDirectUsed: MetricSettings{
			Enabled: true,
		},
		FlinkmetricsJobmanagerStatusJvmMemoryHeapCommitted: MetricSettings{
			Enabled: true,
		},
		FlinkmetricsJobmanagerStatusJvmMemoryHeapMax: MetricSettings{
			Enabled: true,
		},
		FlinkmetricsJobmanagerStatusJvmMemoryHeapUsed: MetricSettings{
			Enabled: true,
		},
		FlinkmetricsJobmanagerStatusJvmMemoryMappedTotalCapacity: MetricSettings{
			Enabled: true,
		},
		FlinkmetricsJobmanagerStatusJvmMemoryMappedUsed: MetricSettings{
			Enabled: true,
		},
		FlinkmetricsJobmanagerStatusJvmMemoryMetaspaceCommitted: MetricSettings{
			Enabled: true,
		},
		FlinkmetricsJobmanagerStatusJvmMemoryMetaspaceMax: MetricSettings{
			Enabled: true,
		},
		FlinkmetricsJobmanagerStatusJvmMemoryMetaspaceUsed: MetricSettings{
			Enabled: true,
		},
		FlinkmetricsJobmanagerStatusJvmMemoryNonHeapCommitted: MetricSettings{
			Enabled: true,
		},
		FlinkmetricsJobmanagerStatusJvmMemoryNonHeapMax: MetricSettings{
			Enabled: true,
		},
		FlinkmetricsJobmanagerStatusJvmMemoryNonHeapUsed: MetricSettings{
			Enabled: true,
		},
		FlinkmetricsJobmanagerStatusJvmThreadsCount: MetricSettings{
			Enabled: true,
		},
		FlinkmetricsOperatorRecordCount: MetricSettings{
			Enabled: true,
		},
		FlinkmetricsOperatorWatermarkOutput: MetricSettings{
			Enabled: true,
		},
		FlinkmetricsTaskRecordCount: MetricSettings{
			Enabled: true,
		},
		FlinkmetricsTaskmanagerStatusFlinkMemoryManagedTotal: MetricSettings{
			Enabled: true,
		},
		FlinkmetricsTaskmanagerStatusFlinkMemoryManagedUsed: MetricSettings{
			Enabled: true,
		},
		FlinkmetricsTaskmanagerStatusJvmClassLoaderClassesLoaded: MetricSettings{
			Enabled: true,
		},
		FlinkmetricsTaskmanagerStatusJvmCPULoad: MetricSettings{
			Enabled: true,
		},
		FlinkmetricsTaskmanagerStatusJvmCPUTime: MetricSettings{
			Enabled: true,
		},
		FlinkmetricsTaskmanagerStatusJvmGarbageCollectorCollectionCount: MetricSettings{
			Enabled: true,
		},
		FlinkmetricsTaskmanagerStatusJvmGarbageCollectorCollectionTime: MetricSettings{
			Enabled: true,
		},
		FlinkmetricsTaskmanagerStatusJvmMemoryDirectTotalCapacity: MetricSettings{
			Enabled: true,
		},
		FlinkmetricsTaskmanagerStatusJvmMemoryDirectUsed: MetricSettings{
			Enabled: true,
		},
		FlinkmetricsTaskmanagerStatusJvmMemoryHeapCommitted: MetricSettings{
			Enabled: true,
		},
		FlinkmetricsTaskmanagerStatusJvmMemoryHeapMax: MetricSettings{
			Enabled: true,
		},
		FlinkmetricsTaskmanagerStatusJvmMemoryHeapUsed: MetricSettings{
			Enabled: true,
		},
		FlinkmetricsTaskmanagerStatusJvmMemoryMappedTotalCapacity: MetricSettings{
			Enabled: true,
		},
		FlinkmetricsTaskmanagerStatusJvmMemoryMappedUsed: MetricSettings{
			Enabled: true,
		},
		FlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceCommitted: MetricSettings{
			Enabled: true,
		},
		FlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceMax: MetricSettings{
			Enabled: true,
		},
		FlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceUsed: MetricSettings{
			Enabled: true,
		},
		FlinkmetricsTaskmanagerStatusJvmMemoryNonHeapCommitted: MetricSettings{
			Enabled: true,
		},
		FlinkmetricsTaskmanagerStatusJvmMemoryNonHeapMax: MetricSettings{
			Enabled: true,
		},
		FlinkmetricsTaskmanagerStatusJvmMemoryNonHeapUsed: MetricSettings{
			Enabled: true,
		},
		FlinkmetricsTaskmanagerStatusJvmThreadsCount: MetricSettings{
			Enabled: true,
		},
	}
}

// AttributeCheckpoint specifies the a value checkpoint attribute.
type AttributeCheckpoint int

const (
	_ AttributeCheckpoint = iota
	AttributeCheckpointInProgress
	AttributeCheckpointCompleted
	AttributeCheckpointFailed
)

// String returns the string representation of the AttributeCheckpoint.
func (av AttributeCheckpoint) String() string {
	switch av {
	case AttributeCheckpointInProgress:
		return "in_progress"
	case AttributeCheckpointCompleted:
		return "completed"
	case AttributeCheckpointFailed:
		return "failed"
	}
	return ""
}

// MapAttributeCheckpoint is a helper map of string to AttributeCheckpoint attribute value.
var MapAttributeCheckpoint = map[string]AttributeCheckpoint{
	"in_progress": AttributeCheckpointInProgress,
	"completed":   AttributeCheckpointCompleted,
	"failed":      AttributeCheckpointFailed,
}

// AttributeRecord specifies the a value record attribute.
type AttributeRecord int

const (
	_ AttributeRecord = iota
	AttributeRecordIn
	AttributeRecordOut
	AttributeRecordLateRecordsDropped
)

// String returns the string representation of the AttributeRecord.
func (av AttributeRecord) String() string {
	switch av {
	case AttributeRecordIn:
		return "in"
	case AttributeRecordOut:
		return "out"
	case AttributeRecordLateRecordsDropped:
		return "late_records_dropped"
	}
	return ""
}

// MapAttributeRecord is a helper map of string to AttributeRecord attribute value.
var MapAttributeRecord = map[string]AttributeRecord{
	"in":                   AttributeRecordIn,
	"out":                  AttributeRecordOut,
	"late_records_dropped": AttributeRecordLateRecordsDropped,
}

type metricFlinkmetricsJobCheckpointsCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flinkmetrics.job.checkpoints.count metric with initial data.
func (m *metricFlinkmetricsJobCheckpointsCount) init() {
	m.data.SetName("flinkmetrics.job.checkpoints.count")
	m.data.SetDescription("The number of checkpoints by type.")
	m.data.SetUnit("{checkpoints}")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkmetricsJobCheckpointsCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, checkpointAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert("checkpoint", pcommon.NewValueString(checkpointAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkmetricsJobCheckpointsCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkmetricsJobCheckpointsCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkmetricsJobCheckpointsCount(settings MetricSettings) metricFlinkmetricsJobCheckpointsCount {
	m := metricFlinkmetricsJobCheckpointsCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkmetricsJobLastCheckpointSize struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flinkmetrics.job.last_checkpoint.size metric with initial data.
func (m *metricFlinkmetricsJobLastCheckpointSize) init() {
	m.data.SetName("flinkmetrics.job.last_checkpoint.size")
	m.data.SetDescription("The total size of the last checkpoint.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkmetricsJobLastCheckpointSize) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkmetricsJobLastCheckpointSize) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkmetricsJobLastCheckpointSize) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkmetricsJobLastCheckpointSize(settings MetricSettings) metricFlinkmetricsJobLastCheckpointSize {
	m := metricFlinkmetricsJobLastCheckpointSize{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkmetricsJobLastCheckpointTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flinkmetrics.job.last_checkpoint.time metric with initial data.
func (m *metricFlinkmetricsJobLastCheckpointTime) init() {
	m.data.SetName("flinkmetrics.job.last_checkpoint.time")
	m.data.SetDescription("The time it took to complete the last checkpoint.")
	m.data.SetUnit("milliseconds")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkmetricsJobLastCheckpointTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkmetricsJobLastCheckpointTime) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkmetricsJobLastCheckpointTime) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkmetricsJobLastCheckpointTime(settings MetricSettings) metricFlinkmetricsJobLastCheckpointTime {
	m := metricFlinkmetricsJobLastCheckpointTime{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkmetricsJobRestartCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flinkmetrics.job.restart.count metric with initial data.
func (m *metricFlinkmetricsJobRestartCount) init() {
	m.data.SetName("flinkmetrics.job.restart.count")
	m.data.SetDescription("The total number of restarts since this job was submitted, including full restarts and fine-grained restarts.")
	m.data.SetUnit("{restarts}")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkmetricsJobRestartCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkmetricsJobRestartCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkmetricsJobRestartCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkmetricsJobRestartCount(settings MetricSettings) metricFlinkmetricsJobRestartCount {
	m := metricFlinkmetricsJobRestartCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkmetricsJobmanagerStatusFlinkMemoryManagedTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flinkmetrics.jobmanager.status.flink.memory.managed.total metric with initial data.
func (m *metricFlinkmetricsJobmanagerStatusFlinkMemoryManagedTotal) init() {
	m.data.SetName("flinkmetrics.jobmanager.status.flink.memory.managed.total")
	m.data.SetDescription("The total amount of managed memory.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkmetricsJobmanagerStatusFlinkMemoryManagedTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkmetricsJobmanagerStatusFlinkMemoryManagedTotal) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkmetricsJobmanagerStatusFlinkMemoryManagedTotal) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkmetricsJobmanagerStatusFlinkMemoryManagedTotal(settings MetricSettings) metricFlinkmetricsJobmanagerStatusFlinkMemoryManagedTotal {
	m := metricFlinkmetricsJobmanagerStatusFlinkMemoryManagedTotal{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkmetricsJobmanagerStatusFlinkMemoryManagedUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flinkmetrics.jobmanager.status.flink.memory.managed.used metric with initial data.
func (m *metricFlinkmetricsJobmanagerStatusFlinkMemoryManagedUsed) init() {
	m.data.SetName("flinkmetrics.jobmanager.status.flink.memory.managed.used")
	m.data.SetDescription("The amount of managed memory currently used.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkmetricsJobmanagerStatusFlinkMemoryManagedUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkmetricsJobmanagerStatusFlinkMemoryManagedUsed) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkmetricsJobmanagerStatusFlinkMemoryManagedUsed) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkmetricsJobmanagerStatusFlinkMemoryManagedUsed(settings MetricSettings) metricFlinkmetricsJobmanagerStatusFlinkMemoryManagedUsed {
	m := metricFlinkmetricsJobmanagerStatusFlinkMemoryManagedUsed{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkmetricsJobmanagerStatusJvmClassLoaderClassesLoaded struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flinkmetrics.jobmanager.status.jvm.class_loader.classes_loaded metric with initial data.
func (m *metricFlinkmetricsJobmanagerStatusJvmClassLoaderClassesLoaded) init() {
	m.data.SetName("flinkmetrics.jobmanager.status.jvm.class_loader.classes_loaded")
	m.data.SetDescription("The total number of classes loaded since the start of the JVM.")
	m.data.SetUnit("{classes}")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkmetricsJobmanagerStatusJvmClassLoaderClassesLoaded) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkmetricsJobmanagerStatusJvmClassLoaderClassesLoaded) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkmetricsJobmanagerStatusJvmClassLoaderClassesLoaded) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkmetricsJobmanagerStatusJvmClassLoaderClassesLoaded(settings MetricSettings) metricFlinkmetricsJobmanagerStatusJvmClassLoaderClassesLoaded {
	m := metricFlinkmetricsJobmanagerStatusJvmClassLoaderClassesLoaded{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkmetricsJobmanagerStatusJvmCPULoad struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flinkmetrics.jobmanager.status.jvm.cpu.load metric with initial data.
func (m *metricFlinkmetricsJobmanagerStatusJvmCPULoad) init() {
	m.data.SetName("flinkmetrics.jobmanager.status.jvm.cpu.load")
	m.data.SetDescription("The recent CPU usage of the JVM.")
	m.data.SetUnit("1")
	m.data.SetDataType(pmetric.MetricDataTypeGauge)
}

func (m *metricFlinkmetricsJobmanagerStatusJvmCPULoad) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkmetricsJobmanagerStatusJvmCPULoad) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkmetricsJobmanagerStatusJvmCPULoad) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkmetricsJobmanagerStatusJvmCPULoad(settings MetricSettings) metricFlinkmetricsJobmanagerStatusJvmCPULoad {
	m := metricFlinkmetricsJobmanagerStatusJvmCPULoad{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkmetricsJobmanagerStatusJvmCPUTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flinkmetrics.jobmanager.status.jvm.cpu.time metric with initial data.
func (m *metricFlinkmetricsJobmanagerStatusJvmCPUTime) init() {
	m.data.SetName("flinkmetrics.jobmanager.status.jvm.cpu.time")
	m.data.SetDescription("The CPU time used by the JVM.")
	m.data.SetUnit("ns")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkmetricsJobmanagerStatusJvmCPUTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkmetricsJobmanagerStatusJvmCPUTime) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkmetricsJobmanagerStatusJvmCPUTime) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkmetricsJobmanagerStatusJvmCPUTime(settings MetricSettings) metricFlinkmetricsJobmanagerStatusJvmCPUTime {
	m := metricFlinkmetricsJobmanagerStatusJvmCPUTime{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkmetricsJobmanagerStatusJvmGarbageCollectorCollectionCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flinkmetrics.jobmanager.status.jvm.garbage_collector.collection.count metric with initial data.
func (m *metricFlinkmetricsJobmanagerStatusJvmGarbageCollectorCollectionCount) init() {
	m.data.SetName("flinkmetrics.jobmanager.status.jvm.garbage_collector.collection.count")
	m.data.SetDescription("The total number of collections that have occurred.")
	m.data.SetUnit("{collections}")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkmetricsJobmanagerStatusJvmGarbageCollectorCollectionCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, garbageCollectorNameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert("garbage_collector_name", pcommon.NewValueString(garbageCollectorNameAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkmetricsJobmanagerStatusJvmGarbageCollectorCollectionCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkmetricsJobmanagerStatusJvmGarbageCollectorCollectionCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkmetricsJobmanagerStatusJvmGarbageCollectorCollectionCount(settings MetricSettings) metricFlinkmetricsJobmanagerStatusJvmGarbageCollectorCollectionCount {
	m := metricFlinkmetricsJobmanagerStatusJvmGarbageCollectorCollectionCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkmetricsJobmanagerStatusJvmGarbageCollectorCollectionTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flinkmetrics.jobmanager.status.jvm.garbage_collector.collection.time metric with initial data.
func (m *metricFlinkmetricsJobmanagerStatusJvmGarbageCollectorCollectionTime) init() {
	m.data.SetName("flinkmetrics.jobmanager.status.jvm.garbage_collector.collection.time")
	m.data.SetDescription("The total time spent performing garbage collection.")
	m.data.SetUnit("milliseconds")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkmetricsJobmanagerStatusJvmGarbageCollectorCollectionTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, garbageCollectorNameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert("garbage_collector_name", pcommon.NewValueString(garbageCollectorNameAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkmetricsJobmanagerStatusJvmGarbageCollectorCollectionTime) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkmetricsJobmanagerStatusJvmGarbageCollectorCollectionTime) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkmetricsJobmanagerStatusJvmGarbageCollectorCollectionTime(settings MetricSettings) metricFlinkmetricsJobmanagerStatusJvmGarbageCollectorCollectionTime {
	m := metricFlinkmetricsJobmanagerStatusJvmGarbageCollectorCollectionTime{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkmetricsJobmanagerStatusJvmMemoryDirectTotalCapacity struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flinkmetrics.jobmanager.status.jvm.memory.direct.total_capacity metric with initial data.
func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryDirectTotalCapacity) init() {
	m.data.SetName("flinkmetrics.jobmanager.status.jvm.memory.direct.total_capacity")
	m.data.SetDescription("The total capacity of all buffers in the direct buffer pool.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryDirectTotalCapacity) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryDirectTotalCapacity) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryDirectTotalCapacity) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkmetricsJobmanagerStatusJvmMemoryDirectTotalCapacity(settings MetricSettings) metricFlinkmetricsJobmanagerStatusJvmMemoryDirectTotalCapacity {
	m := metricFlinkmetricsJobmanagerStatusJvmMemoryDirectTotalCapacity{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkmetricsJobmanagerStatusJvmMemoryDirectUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flinkmetrics.jobmanager.status.jvm.memory.direct.used metric with initial data.
func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryDirectUsed) init() {
	m.data.SetName("flinkmetrics.jobmanager.status.jvm.memory.direct.used")
	m.data.SetDescription("The amount of memory used by the JVM for the direct buffer pool.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryDirectUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryDirectUsed) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryDirectUsed) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkmetricsJobmanagerStatusJvmMemoryDirectUsed(settings MetricSettings) metricFlinkmetricsJobmanagerStatusJvmMemoryDirectUsed {
	m := metricFlinkmetricsJobmanagerStatusJvmMemoryDirectUsed{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkmetricsJobmanagerStatusJvmMemoryHeapCommitted struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flinkmetrics.jobmanager.status.jvm.memory.heap.committed metric with initial data.
func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryHeapCommitted) init() {
	m.data.SetName("flinkmetrics.jobmanager.status.jvm.memory.heap.committed")
	m.data.SetDescription("The amount of heap memory guaranteed to be available to the JVM.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryHeapCommitted) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryHeapCommitted) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryHeapCommitted) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkmetricsJobmanagerStatusJvmMemoryHeapCommitted(settings MetricSettings) metricFlinkmetricsJobmanagerStatusJvmMemoryHeapCommitted {
	m := metricFlinkmetricsJobmanagerStatusJvmMemoryHeapCommitted{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkmetricsJobmanagerStatusJvmMemoryHeapMax struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flinkmetrics.jobmanager.status.jvm.memory.heap.max metric with initial data.
func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryHeapMax) init() {
	m.data.SetName("flinkmetrics.jobmanager.status.jvm.memory.heap.max")
	m.data.SetDescription("The maximum amount of heap memory that can be used for memory management.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryHeapMax) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryHeapMax) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryHeapMax) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkmetricsJobmanagerStatusJvmMemoryHeapMax(settings MetricSettings) metricFlinkmetricsJobmanagerStatusJvmMemoryHeapMax {
	m := metricFlinkmetricsJobmanagerStatusJvmMemoryHeapMax{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkmetricsJobmanagerStatusJvmMemoryHeapUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flinkmetrics.jobmanager.status.jvm.memory.heap.used metric with initial data.
func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryHeapUsed) init() {
	m.data.SetName("flinkmetrics.jobmanager.status.jvm.memory.heap.used")
	m.data.SetDescription("The amount of heap memory currently used.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryHeapUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryHeapUsed) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryHeapUsed) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkmetricsJobmanagerStatusJvmMemoryHeapUsed(settings MetricSettings) metricFlinkmetricsJobmanagerStatusJvmMemoryHeapUsed {
	m := metricFlinkmetricsJobmanagerStatusJvmMemoryHeapUsed{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkmetricsJobmanagerStatusJvmMemoryMappedTotalCapacity struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flinkmetrics.jobmanager.status.jvm.memory.mapped.total_capacity metric with initial data.
func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryMappedTotalCapacity) init() {
	m.data.SetName("flinkmetrics.jobmanager.status.jvm.memory.mapped.total_capacity")
	m.data.SetDescription("The number of buffers in the mapped buffer pool.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryMappedTotalCapacity) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryMappedTotalCapacity) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryMappedTotalCapacity) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkmetricsJobmanagerStatusJvmMemoryMappedTotalCapacity(settings MetricSettings) metricFlinkmetricsJobmanagerStatusJvmMemoryMappedTotalCapacity {
	m := metricFlinkmetricsJobmanagerStatusJvmMemoryMappedTotalCapacity{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkmetricsJobmanagerStatusJvmMemoryMappedUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flinkmetrics.jobmanager.status.jvm.memory.mapped.used metric with initial data.
func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryMappedUsed) init() {
	m.data.SetName("flinkmetrics.jobmanager.status.jvm.memory.mapped.used")
	m.data.SetDescription("The amount of memory used by the JVM for the mapped buffer pool.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryMappedUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryMappedUsed) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryMappedUsed) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkmetricsJobmanagerStatusJvmMemoryMappedUsed(settings MetricSettings) metricFlinkmetricsJobmanagerStatusJvmMemoryMappedUsed {
	m := metricFlinkmetricsJobmanagerStatusJvmMemoryMappedUsed{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkmetricsJobmanagerStatusJvmMemoryMetaspaceCommitted struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flinkmetrics.jobmanager.status.jvm.memory.metaspace.committed metric with initial data.
func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryMetaspaceCommitted) init() {
	m.data.SetName("flinkmetrics.jobmanager.status.jvm.memory.metaspace.committed")
	m.data.SetDescription("The amount of memory guaranteed to be available to the JVM in the Metaspace memory pool.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryMetaspaceCommitted) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryMetaspaceCommitted) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryMetaspaceCommitted) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkmetricsJobmanagerStatusJvmMemoryMetaspaceCommitted(settings MetricSettings) metricFlinkmetricsJobmanagerStatusJvmMemoryMetaspaceCommitted {
	m := metricFlinkmetricsJobmanagerStatusJvmMemoryMetaspaceCommitted{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkmetricsJobmanagerStatusJvmMemoryMetaspaceMax struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flinkmetrics.jobmanager.status.jvm.memory.metaspace.max metric with initial data.
func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryMetaspaceMax) init() {
	m.data.SetName("flinkmetrics.jobmanager.status.jvm.memory.metaspace.max")
	m.data.SetDescription("The maximum amount of memory that can be used in the Metaspace memory pool.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryMetaspaceMax) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryMetaspaceMax) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryMetaspaceMax) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkmetricsJobmanagerStatusJvmMemoryMetaspaceMax(settings MetricSettings) metricFlinkmetricsJobmanagerStatusJvmMemoryMetaspaceMax {
	m := metricFlinkmetricsJobmanagerStatusJvmMemoryMetaspaceMax{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkmetricsJobmanagerStatusJvmMemoryMetaspaceUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flinkmetrics.jobmanager.status.jvm.memory.metaspace.used metric with initial data.
func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryMetaspaceUsed) init() {
	m.data.SetName("flinkmetrics.jobmanager.status.jvm.memory.metaspace.used")
	m.data.SetDescription("The amount of memory currently used in the Metaspace memory pool.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryMetaspaceUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryMetaspaceUsed) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryMetaspaceUsed) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkmetricsJobmanagerStatusJvmMemoryMetaspaceUsed(settings MetricSettings) metricFlinkmetricsJobmanagerStatusJvmMemoryMetaspaceUsed {
	m := metricFlinkmetricsJobmanagerStatusJvmMemoryMetaspaceUsed{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkmetricsJobmanagerStatusJvmMemoryNonHeapCommitted struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flinkmetrics.jobmanager.status.jvm.memory.non_heap.committed metric with initial data.
func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryNonHeapCommitted) init() {
	m.data.SetName("flinkmetrics.jobmanager.status.jvm.memory.non_heap.committed")
	m.data.SetDescription("The amount of non-heap memory guaranteed to be available to the JVM.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryNonHeapCommitted) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryNonHeapCommitted) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryNonHeapCommitted) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkmetricsJobmanagerStatusJvmMemoryNonHeapCommitted(settings MetricSettings) metricFlinkmetricsJobmanagerStatusJvmMemoryNonHeapCommitted {
	m := metricFlinkmetricsJobmanagerStatusJvmMemoryNonHeapCommitted{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkmetricsJobmanagerStatusJvmMemoryNonHeapMax struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flinkmetrics.jobmanager.status.jvm.memory.non_heap.max metric with initial data.
func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryNonHeapMax) init() {
	m.data.SetName("flinkmetrics.jobmanager.status.jvm.memory.non_heap.max")
	m.data.SetDescription("The maximum amount of non-heap memory that can be used for memory management.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryNonHeapMax) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryNonHeapMax) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryNonHeapMax) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkmetricsJobmanagerStatusJvmMemoryNonHeapMax(settings MetricSettings) metricFlinkmetricsJobmanagerStatusJvmMemoryNonHeapMax {
	m := metricFlinkmetricsJobmanagerStatusJvmMemoryNonHeapMax{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkmetricsJobmanagerStatusJvmMemoryNonHeapUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flinkmetrics.jobmanager.status.jvm.memory.non_heap.used metric with initial data.
func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryNonHeapUsed) init() {
	m.data.SetName("flinkmetrics.jobmanager.status.jvm.memory.non_heap.used")
	m.data.SetDescription("The amount of non-heap memory currently used.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryNonHeapUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryNonHeapUsed) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkmetricsJobmanagerStatusJvmMemoryNonHeapUsed) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkmetricsJobmanagerStatusJvmMemoryNonHeapUsed(settings MetricSettings) metricFlinkmetricsJobmanagerStatusJvmMemoryNonHeapUsed {
	m := metricFlinkmetricsJobmanagerStatusJvmMemoryNonHeapUsed{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkmetricsJobmanagerStatusJvmThreadsCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flinkmetrics.jobmanager.status.jvm.threads.count metric with initial data.
func (m *metricFlinkmetricsJobmanagerStatusJvmThreadsCount) init() {
	m.data.SetName("flinkmetrics.jobmanager.status.jvm.threads.count")
	m.data.SetDescription("The total number of live threads.")
	m.data.SetUnit("{threads}")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkmetricsJobmanagerStatusJvmThreadsCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkmetricsJobmanagerStatusJvmThreadsCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkmetricsJobmanagerStatusJvmThreadsCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkmetricsJobmanagerStatusJvmThreadsCount(settings MetricSettings) metricFlinkmetricsJobmanagerStatusJvmThreadsCount {
	m := metricFlinkmetricsJobmanagerStatusJvmThreadsCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkmetricsOperatorRecordCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flinkmetrics.operator.record.count metric with initial data.
func (m *metricFlinkmetricsOperatorRecordCount) init() {
	m.data.SetName("flinkmetrics.operator.record.count")
	m.data.SetDescription("The number of records this operator type has.")
	m.data.SetUnit("{records}")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkmetricsOperatorRecordCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, operatorNameAttributeValue string, recordAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert("operator_name", pcommon.NewValueString(operatorNameAttributeValue))
	dp.Attributes().Insert("record", pcommon.NewValueString(recordAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkmetricsOperatorRecordCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkmetricsOperatorRecordCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkmetricsOperatorRecordCount(settings MetricSettings) metricFlinkmetricsOperatorRecordCount {
	m := metricFlinkmetricsOperatorRecordCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkmetricsOperatorWatermarkOutput struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flinkmetrics.operator.watermark.output metric with initial data.
func (m *metricFlinkmetricsOperatorWatermarkOutput) init() {
	m.data.SetName("flinkmetrics.operator.watermark.output")
	m.data.SetDescription("The last watermark this operator has emitted.")
	m.data.SetUnit("milliseconds")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkmetricsOperatorWatermarkOutput) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, operatorNameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert("operator_name", pcommon.NewValueString(operatorNameAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkmetricsOperatorWatermarkOutput) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkmetricsOperatorWatermarkOutput) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkmetricsOperatorWatermarkOutput(settings MetricSettings) metricFlinkmetricsOperatorWatermarkOutput {
	m := metricFlinkmetricsOperatorWatermarkOutput{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkmetricsTaskRecordCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flinkmetrics.task.record.count metric with initial data.
func (m *metricFlinkmetricsTaskRecordCount) init() {
	m.data.SetName("flinkmetrics.task.record.count")
	m.data.SetDescription("The number of records this task type has.")
	m.data.SetUnit("{records}")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkmetricsTaskRecordCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, recordAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert("record", pcommon.NewValueString(recordAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkmetricsTaskRecordCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkmetricsTaskRecordCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkmetricsTaskRecordCount(settings MetricSettings) metricFlinkmetricsTaskRecordCount {
	m := metricFlinkmetricsTaskRecordCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkmetricsTaskmanagerStatusFlinkMemoryManagedTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flinkmetrics.taskmanager.status.flink.memory.managed.total metric with initial data.
func (m *metricFlinkmetricsTaskmanagerStatusFlinkMemoryManagedTotal) init() {
	m.data.SetName("flinkmetrics.taskmanager.status.flink.memory.managed.total")
	m.data.SetDescription("The total amount of managed memory.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkmetricsTaskmanagerStatusFlinkMemoryManagedTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkmetricsTaskmanagerStatusFlinkMemoryManagedTotal) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkmetricsTaskmanagerStatusFlinkMemoryManagedTotal) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkmetricsTaskmanagerStatusFlinkMemoryManagedTotal(settings MetricSettings) metricFlinkmetricsTaskmanagerStatusFlinkMemoryManagedTotal {
	m := metricFlinkmetricsTaskmanagerStatusFlinkMemoryManagedTotal{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkmetricsTaskmanagerStatusFlinkMemoryManagedUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flinkmetrics.taskmanager.status.flink.memory.managed.used metric with initial data.
func (m *metricFlinkmetricsTaskmanagerStatusFlinkMemoryManagedUsed) init() {
	m.data.SetName("flinkmetrics.taskmanager.status.flink.memory.managed.used")
	m.data.SetDescription("The amount of managed memory currently used.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkmetricsTaskmanagerStatusFlinkMemoryManagedUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkmetricsTaskmanagerStatusFlinkMemoryManagedUsed) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkmetricsTaskmanagerStatusFlinkMemoryManagedUsed) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkmetricsTaskmanagerStatusFlinkMemoryManagedUsed(settings MetricSettings) metricFlinkmetricsTaskmanagerStatusFlinkMemoryManagedUsed {
	m := metricFlinkmetricsTaskmanagerStatusFlinkMemoryManagedUsed{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkmetricsTaskmanagerStatusJvmClassLoaderClassesLoaded struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flinkmetrics.taskmanager.status.jvm.class_loader.classes_loaded metric with initial data.
func (m *metricFlinkmetricsTaskmanagerStatusJvmClassLoaderClassesLoaded) init() {
	m.data.SetName("flinkmetrics.taskmanager.status.jvm.class_loader.classes_loaded")
	m.data.SetDescription("The total number of classes loaded since the start of the JVM.")
	m.data.SetUnit("{classes}")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkmetricsTaskmanagerStatusJvmClassLoaderClassesLoaded) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkmetricsTaskmanagerStatusJvmClassLoaderClassesLoaded) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkmetricsTaskmanagerStatusJvmClassLoaderClassesLoaded) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkmetricsTaskmanagerStatusJvmClassLoaderClassesLoaded(settings MetricSettings) metricFlinkmetricsTaskmanagerStatusJvmClassLoaderClassesLoaded {
	m := metricFlinkmetricsTaskmanagerStatusJvmClassLoaderClassesLoaded{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkmetricsTaskmanagerStatusJvmCPULoad struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flinkmetrics.taskmanager.status.jvm.cpu.load metric with initial data.
func (m *metricFlinkmetricsTaskmanagerStatusJvmCPULoad) init() {
	m.data.SetName("flinkmetrics.taskmanager.status.jvm.cpu.load")
	m.data.SetDescription("The recent CPU usage of the JVM.")
	m.data.SetUnit("1")
	m.data.SetDataType(pmetric.MetricDataTypeGauge)
}

func (m *metricFlinkmetricsTaskmanagerStatusJvmCPULoad) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkmetricsTaskmanagerStatusJvmCPULoad) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkmetricsTaskmanagerStatusJvmCPULoad) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkmetricsTaskmanagerStatusJvmCPULoad(settings MetricSettings) metricFlinkmetricsTaskmanagerStatusJvmCPULoad {
	m := metricFlinkmetricsTaskmanagerStatusJvmCPULoad{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkmetricsTaskmanagerStatusJvmCPUTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flinkmetrics.taskmanager.status.jvm.cpu.time metric with initial data.
func (m *metricFlinkmetricsTaskmanagerStatusJvmCPUTime) init() {
	m.data.SetName("flinkmetrics.taskmanager.status.jvm.cpu.time")
	m.data.SetDescription("The CPU time used by the JVM.")
	m.data.SetUnit("ns")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkmetricsTaskmanagerStatusJvmCPUTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkmetricsTaskmanagerStatusJvmCPUTime) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkmetricsTaskmanagerStatusJvmCPUTime) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkmetricsTaskmanagerStatusJvmCPUTime(settings MetricSettings) metricFlinkmetricsTaskmanagerStatusJvmCPUTime {
	m := metricFlinkmetricsTaskmanagerStatusJvmCPUTime{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkmetricsTaskmanagerStatusJvmGarbageCollectorCollectionCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flinkmetrics.taskmanager.status.jvm.garbage_collector.collection.count metric with initial data.
func (m *metricFlinkmetricsTaskmanagerStatusJvmGarbageCollectorCollectionCount) init() {
	m.data.SetName("flinkmetrics.taskmanager.status.jvm.garbage_collector.collection.count")
	m.data.SetDescription("The total number of collections that have occurred.")
	m.data.SetUnit("{collections}")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkmetricsTaskmanagerStatusJvmGarbageCollectorCollectionCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, garbageCollectorNameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert("garbage_collector_name", pcommon.NewValueString(garbageCollectorNameAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkmetricsTaskmanagerStatusJvmGarbageCollectorCollectionCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkmetricsTaskmanagerStatusJvmGarbageCollectorCollectionCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkmetricsTaskmanagerStatusJvmGarbageCollectorCollectionCount(settings MetricSettings) metricFlinkmetricsTaskmanagerStatusJvmGarbageCollectorCollectionCount {
	m := metricFlinkmetricsTaskmanagerStatusJvmGarbageCollectorCollectionCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkmetricsTaskmanagerStatusJvmGarbageCollectorCollectionTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flinkmetrics.taskmanager.status.jvm.garbage_collector.collection.time metric with initial data.
func (m *metricFlinkmetricsTaskmanagerStatusJvmGarbageCollectorCollectionTime) init() {
	m.data.SetName("flinkmetrics.taskmanager.status.jvm.garbage_collector.collection.time")
	m.data.SetDescription("The total time spent performing garbage collection.")
	m.data.SetUnit("{milliseconds}")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkmetricsTaskmanagerStatusJvmGarbageCollectorCollectionTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, garbageCollectorNameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert("garbage_collector_name", pcommon.NewValueString(garbageCollectorNameAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkmetricsTaskmanagerStatusJvmGarbageCollectorCollectionTime) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkmetricsTaskmanagerStatusJvmGarbageCollectorCollectionTime) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkmetricsTaskmanagerStatusJvmGarbageCollectorCollectionTime(settings MetricSettings) metricFlinkmetricsTaskmanagerStatusJvmGarbageCollectorCollectionTime {
	m := metricFlinkmetricsTaskmanagerStatusJvmGarbageCollectorCollectionTime{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkmetricsTaskmanagerStatusJvmMemoryDirectTotalCapacity struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flinkmetrics.taskmanager.status.jvm.memory.direct.total_capacity metric with initial data.
func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryDirectTotalCapacity) init() {
	m.data.SetName("flinkmetrics.taskmanager.status.jvm.memory.direct.total_capacity")
	m.data.SetDescription("The total capacity of all buffers in the direct buffer pool.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryDirectTotalCapacity) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryDirectTotalCapacity) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryDirectTotalCapacity) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkmetricsTaskmanagerStatusJvmMemoryDirectTotalCapacity(settings MetricSettings) metricFlinkmetricsTaskmanagerStatusJvmMemoryDirectTotalCapacity {
	m := metricFlinkmetricsTaskmanagerStatusJvmMemoryDirectTotalCapacity{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkmetricsTaskmanagerStatusJvmMemoryDirectUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flinkmetrics.taskmanager.status.jvm.memory.direct.used metric with initial data.
func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryDirectUsed) init() {
	m.data.SetName("flinkmetrics.taskmanager.status.jvm.memory.direct.used")
	m.data.SetDescription("The amount of memory used by the JVM for the direct buffer pool.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryDirectUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryDirectUsed) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryDirectUsed) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkmetricsTaskmanagerStatusJvmMemoryDirectUsed(settings MetricSettings) metricFlinkmetricsTaskmanagerStatusJvmMemoryDirectUsed {
	m := metricFlinkmetricsTaskmanagerStatusJvmMemoryDirectUsed{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkmetricsTaskmanagerStatusJvmMemoryHeapCommitted struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flinkmetrics.taskmanager.status.jvm.memory.heap.committed metric with initial data.
func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryHeapCommitted) init() {
	m.data.SetName("flinkmetrics.taskmanager.status.jvm.memory.heap.committed")
	m.data.SetDescription("The amount of heap memory guaranteed to be available to the JVM.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryHeapCommitted) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryHeapCommitted) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryHeapCommitted) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkmetricsTaskmanagerStatusJvmMemoryHeapCommitted(settings MetricSettings) metricFlinkmetricsTaskmanagerStatusJvmMemoryHeapCommitted {
	m := metricFlinkmetricsTaskmanagerStatusJvmMemoryHeapCommitted{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkmetricsTaskmanagerStatusJvmMemoryHeapMax struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flinkmetrics.taskmanager.status.jvm.memory.heap.max metric with initial data.
func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryHeapMax) init() {
	m.data.SetName("flinkmetrics.taskmanager.status.jvm.memory.heap.max")
	m.data.SetDescription("The maximum amount of heap memory that can be used for memory management.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryHeapMax) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryHeapMax) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryHeapMax) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkmetricsTaskmanagerStatusJvmMemoryHeapMax(settings MetricSettings) metricFlinkmetricsTaskmanagerStatusJvmMemoryHeapMax {
	m := metricFlinkmetricsTaskmanagerStatusJvmMemoryHeapMax{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkmetricsTaskmanagerStatusJvmMemoryHeapUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flinkmetrics.taskmanager.status.jvm.memory.heap.used metric with initial data.
func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryHeapUsed) init() {
	m.data.SetName("flinkmetrics.taskmanager.status.jvm.memory.heap.used")
	m.data.SetDescription("The amount of heap memory currently used.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryHeapUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryHeapUsed) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryHeapUsed) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkmetricsTaskmanagerStatusJvmMemoryHeapUsed(settings MetricSettings) metricFlinkmetricsTaskmanagerStatusJvmMemoryHeapUsed {
	m := metricFlinkmetricsTaskmanagerStatusJvmMemoryHeapUsed{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkmetricsTaskmanagerStatusJvmMemoryMappedTotalCapacity struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flinkmetrics.taskmanager.status.jvm.memory.mapped.total_capacity metric with initial data.
func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryMappedTotalCapacity) init() {
	m.data.SetName("flinkmetrics.taskmanager.status.jvm.memory.mapped.total_capacity")
	m.data.SetDescription("The number of buffers in the mapped buffer pool.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryMappedTotalCapacity) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryMappedTotalCapacity) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryMappedTotalCapacity) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkmetricsTaskmanagerStatusJvmMemoryMappedTotalCapacity(settings MetricSettings) metricFlinkmetricsTaskmanagerStatusJvmMemoryMappedTotalCapacity {
	m := metricFlinkmetricsTaskmanagerStatusJvmMemoryMappedTotalCapacity{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkmetricsTaskmanagerStatusJvmMemoryMappedUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flinkmetrics.taskmanager.status.jvm.memory.mapped.used metric with initial data.
func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryMappedUsed) init() {
	m.data.SetName("flinkmetrics.taskmanager.status.jvm.memory.mapped.used")
	m.data.SetDescription("The amount of memory used by the JVM for the mapped buffer pool.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryMappedUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryMappedUsed) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryMappedUsed) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkmetricsTaskmanagerStatusJvmMemoryMappedUsed(settings MetricSettings) metricFlinkmetricsTaskmanagerStatusJvmMemoryMappedUsed {
	m := metricFlinkmetricsTaskmanagerStatusJvmMemoryMappedUsed{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceCommitted struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flinkmetrics.taskmanager.status.jvm.memory.metaspace.committed metric with initial data.
func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceCommitted) init() {
	m.data.SetName("flinkmetrics.taskmanager.status.jvm.memory.metaspace.committed")
	m.data.SetDescription("The amount of memory guaranteed to be available to the JVM in the Metaspace memory pool.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceCommitted) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceCommitted) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceCommitted) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceCommitted(settings MetricSettings) metricFlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceCommitted {
	m := metricFlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceCommitted{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceMax struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flinkmetrics.taskmanager.status.jvm.memory.metaspace.max metric with initial data.
func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceMax) init() {
	m.data.SetName("flinkmetrics.taskmanager.status.jvm.memory.metaspace.max")
	m.data.SetDescription("The maximum amount of memory that can be used in the Metaspace memory pool.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceMax) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceMax) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceMax) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceMax(settings MetricSettings) metricFlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceMax {
	m := metricFlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceMax{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flinkmetrics.taskmanager.status.jvm.memory.metaspace.used metric with initial data.
func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceUsed) init() {
	m.data.SetName("flinkmetrics.taskmanager.status.jvm.memory.metaspace.used")
	m.data.SetDescription("The amount of memory currently used in the Metaspace memory pool.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceUsed) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceUsed) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceUsed(settings MetricSettings) metricFlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceUsed {
	m := metricFlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceUsed{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkmetricsTaskmanagerStatusJvmMemoryNonHeapCommitted struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flinkmetrics.taskmanager.status.jvm.memory.non_heap.committed metric with initial data.
func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryNonHeapCommitted) init() {
	m.data.SetName("flinkmetrics.taskmanager.status.jvm.memory.non_heap.committed")
	m.data.SetDescription("The amount of non-heap memory guaranteed to be available to the JVM.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryNonHeapCommitted) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryNonHeapCommitted) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryNonHeapCommitted) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkmetricsTaskmanagerStatusJvmMemoryNonHeapCommitted(settings MetricSettings) metricFlinkmetricsTaskmanagerStatusJvmMemoryNonHeapCommitted {
	m := metricFlinkmetricsTaskmanagerStatusJvmMemoryNonHeapCommitted{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkmetricsTaskmanagerStatusJvmMemoryNonHeapMax struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flinkmetrics.taskmanager.status.jvm.memory.non_heap.max metric with initial data.
func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryNonHeapMax) init() {
	m.data.SetName("flinkmetrics.taskmanager.status.jvm.memory.non_heap.max")
	m.data.SetDescription("The maximum amount of non-heap memory that can be used for memory management.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryNonHeapMax) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryNonHeapMax) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryNonHeapMax) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkmetricsTaskmanagerStatusJvmMemoryNonHeapMax(settings MetricSettings) metricFlinkmetricsTaskmanagerStatusJvmMemoryNonHeapMax {
	m := metricFlinkmetricsTaskmanagerStatusJvmMemoryNonHeapMax{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkmetricsTaskmanagerStatusJvmMemoryNonHeapUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flinkmetrics.taskmanager.status.jvm.memory.non_heap.used metric with initial data.
func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryNonHeapUsed) init() {
	m.data.SetName("flinkmetrics.taskmanager.status.jvm.memory.non_heap.used")
	m.data.SetDescription("The amount of non-heap memory currently used.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryNonHeapUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryNonHeapUsed) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkmetricsTaskmanagerStatusJvmMemoryNonHeapUsed) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkmetricsTaskmanagerStatusJvmMemoryNonHeapUsed(settings MetricSettings) metricFlinkmetricsTaskmanagerStatusJvmMemoryNonHeapUsed {
	m := metricFlinkmetricsTaskmanagerStatusJvmMemoryNonHeapUsed{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkmetricsTaskmanagerStatusJvmThreadsCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flinkmetrics.taskmanager.status.jvm.threads.count metric with initial data.
func (m *metricFlinkmetricsTaskmanagerStatusJvmThreadsCount) init() {
	m.data.SetName("flinkmetrics.taskmanager.status.jvm.threads.count")
	m.data.SetDescription("The total number of live threads.")
	m.data.SetUnit("{threads}")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkmetricsTaskmanagerStatusJvmThreadsCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkmetricsTaskmanagerStatusJvmThreadsCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkmetricsTaskmanagerStatusJvmThreadsCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkmetricsTaskmanagerStatusJvmThreadsCount(settings MetricSettings) metricFlinkmetricsTaskmanagerStatusJvmThreadsCount {
	m := metricFlinkmetricsTaskmanagerStatusJvmThreadsCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

// MetricsBuilder provides an interface for scrapers to report metrics while taking care of all the transformations
// required to produce metric representation defined in metadata and user settings.
type MetricsBuilder struct {
	startTime                                                             pcommon.Timestamp // start time that will be applied to all recorded data points.
	metricsCapacity                                                       int               // maximum observed number of metrics per resource.
	resourceCapacity                                                      int               // maximum observed number of resource attributes.
	metricsBuffer                                                         pmetric.Metrics   // accumulates metrics data before emitting.
	metricFlinkmetricsJobCheckpointsCount                                 metricFlinkmetricsJobCheckpointsCount
	metricFlinkmetricsJobLastCheckpointSize                               metricFlinkmetricsJobLastCheckpointSize
	metricFlinkmetricsJobLastCheckpointTime                               metricFlinkmetricsJobLastCheckpointTime
	metricFlinkmetricsJobRestartCount                                     metricFlinkmetricsJobRestartCount
	metricFlinkmetricsJobmanagerStatusFlinkMemoryManagedTotal             metricFlinkmetricsJobmanagerStatusFlinkMemoryManagedTotal
	metricFlinkmetricsJobmanagerStatusFlinkMemoryManagedUsed              metricFlinkmetricsJobmanagerStatusFlinkMemoryManagedUsed
	metricFlinkmetricsJobmanagerStatusJvmClassLoaderClassesLoaded         metricFlinkmetricsJobmanagerStatusJvmClassLoaderClassesLoaded
	metricFlinkmetricsJobmanagerStatusJvmCPULoad                          metricFlinkmetricsJobmanagerStatusJvmCPULoad
	metricFlinkmetricsJobmanagerStatusJvmCPUTime                          metricFlinkmetricsJobmanagerStatusJvmCPUTime
	metricFlinkmetricsJobmanagerStatusJvmGarbageCollectorCollectionCount  metricFlinkmetricsJobmanagerStatusJvmGarbageCollectorCollectionCount
	metricFlinkmetricsJobmanagerStatusJvmGarbageCollectorCollectionTime   metricFlinkmetricsJobmanagerStatusJvmGarbageCollectorCollectionTime
	metricFlinkmetricsJobmanagerStatusJvmMemoryDirectTotalCapacity        metricFlinkmetricsJobmanagerStatusJvmMemoryDirectTotalCapacity
	metricFlinkmetricsJobmanagerStatusJvmMemoryDirectUsed                 metricFlinkmetricsJobmanagerStatusJvmMemoryDirectUsed
	metricFlinkmetricsJobmanagerStatusJvmMemoryHeapCommitted              metricFlinkmetricsJobmanagerStatusJvmMemoryHeapCommitted
	metricFlinkmetricsJobmanagerStatusJvmMemoryHeapMax                    metricFlinkmetricsJobmanagerStatusJvmMemoryHeapMax
	metricFlinkmetricsJobmanagerStatusJvmMemoryHeapUsed                   metricFlinkmetricsJobmanagerStatusJvmMemoryHeapUsed
	metricFlinkmetricsJobmanagerStatusJvmMemoryMappedTotalCapacity        metricFlinkmetricsJobmanagerStatusJvmMemoryMappedTotalCapacity
	metricFlinkmetricsJobmanagerStatusJvmMemoryMappedUsed                 metricFlinkmetricsJobmanagerStatusJvmMemoryMappedUsed
	metricFlinkmetricsJobmanagerStatusJvmMemoryMetaspaceCommitted         metricFlinkmetricsJobmanagerStatusJvmMemoryMetaspaceCommitted
	metricFlinkmetricsJobmanagerStatusJvmMemoryMetaspaceMax               metricFlinkmetricsJobmanagerStatusJvmMemoryMetaspaceMax
	metricFlinkmetricsJobmanagerStatusJvmMemoryMetaspaceUsed              metricFlinkmetricsJobmanagerStatusJvmMemoryMetaspaceUsed
	metricFlinkmetricsJobmanagerStatusJvmMemoryNonHeapCommitted           metricFlinkmetricsJobmanagerStatusJvmMemoryNonHeapCommitted
	metricFlinkmetricsJobmanagerStatusJvmMemoryNonHeapMax                 metricFlinkmetricsJobmanagerStatusJvmMemoryNonHeapMax
	metricFlinkmetricsJobmanagerStatusJvmMemoryNonHeapUsed                metricFlinkmetricsJobmanagerStatusJvmMemoryNonHeapUsed
	metricFlinkmetricsJobmanagerStatusJvmThreadsCount                     metricFlinkmetricsJobmanagerStatusJvmThreadsCount
	metricFlinkmetricsOperatorRecordCount                                 metricFlinkmetricsOperatorRecordCount
	metricFlinkmetricsOperatorWatermarkOutput                             metricFlinkmetricsOperatorWatermarkOutput
	metricFlinkmetricsTaskRecordCount                                     metricFlinkmetricsTaskRecordCount
	metricFlinkmetricsTaskmanagerStatusFlinkMemoryManagedTotal            metricFlinkmetricsTaskmanagerStatusFlinkMemoryManagedTotal
	metricFlinkmetricsTaskmanagerStatusFlinkMemoryManagedUsed             metricFlinkmetricsTaskmanagerStatusFlinkMemoryManagedUsed
	metricFlinkmetricsTaskmanagerStatusJvmClassLoaderClassesLoaded        metricFlinkmetricsTaskmanagerStatusJvmClassLoaderClassesLoaded
	metricFlinkmetricsTaskmanagerStatusJvmCPULoad                         metricFlinkmetricsTaskmanagerStatusJvmCPULoad
	metricFlinkmetricsTaskmanagerStatusJvmCPUTime                         metricFlinkmetricsTaskmanagerStatusJvmCPUTime
	metricFlinkmetricsTaskmanagerStatusJvmGarbageCollectorCollectionCount metricFlinkmetricsTaskmanagerStatusJvmGarbageCollectorCollectionCount
	metricFlinkmetricsTaskmanagerStatusJvmGarbageCollectorCollectionTime  metricFlinkmetricsTaskmanagerStatusJvmGarbageCollectorCollectionTime
	metricFlinkmetricsTaskmanagerStatusJvmMemoryDirectTotalCapacity       metricFlinkmetricsTaskmanagerStatusJvmMemoryDirectTotalCapacity
	metricFlinkmetricsTaskmanagerStatusJvmMemoryDirectUsed                metricFlinkmetricsTaskmanagerStatusJvmMemoryDirectUsed
	metricFlinkmetricsTaskmanagerStatusJvmMemoryHeapCommitted             metricFlinkmetricsTaskmanagerStatusJvmMemoryHeapCommitted
	metricFlinkmetricsTaskmanagerStatusJvmMemoryHeapMax                   metricFlinkmetricsTaskmanagerStatusJvmMemoryHeapMax
	metricFlinkmetricsTaskmanagerStatusJvmMemoryHeapUsed                  metricFlinkmetricsTaskmanagerStatusJvmMemoryHeapUsed
	metricFlinkmetricsTaskmanagerStatusJvmMemoryMappedTotalCapacity       metricFlinkmetricsTaskmanagerStatusJvmMemoryMappedTotalCapacity
	metricFlinkmetricsTaskmanagerStatusJvmMemoryMappedUsed                metricFlinkmetricsTaskmanagerStatusJvmMemoryMappedUsed
	metricFlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceCommitted        metricFlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceCommitted
	metricFlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceMax              metricFlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceMax
	metricFlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceUsed             metricFlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceUsed
	metricFlinkmetricsTaskmanagerStatusJvmMemoryNonHeapCommitted          metricFlinkmetricsTaskmanagerStatusJvmMemoryNonHeapCommitted
	metricFlinkmetricsTaskmanagerStatusJvmMemoryNonHeapMax                metricFlinkmetricsTaskmanagerStatusJvmMemoryNonHeapMax
	metricFlinkmetricsTaskmanagerStatusJvmMemoryNonHeapUsed               metricFlinkmetricsTaskmanagerStatusJvmMemoryNonHeapUsed
	metricFlinkmetricsTaskmanagerStatusJvmThreadsCount                    metricFlinkmetricsTaskmanagerStatusJvmThreadsCount
}

// metricBuilderOption applies changes to default metrics builder.
type metricBuilderOption func(*MetricsBuilder)

// WithStartTime sets startTime on the metrics builder.
func WithStartTime(startTime pcommon.Timestamp) metricBuilderOption {
	return func(mb *MetricsBuilder) {
		mb.startTime = startTime
	}
}

func NewMetricsBuilder(settings MetricsSettings, options ...metricBuilderOption) *MetricsBuilder {
	mb := &MetricsBuilder{
		startTime:                                                             pcommon.NewTimestampFromTime(time.Now()),
		metricsBuffer:                                                         pmetric.NewMetrics(),
		metricFlinkmetricsJobCheckpointsCount:                                 newMetricFlinkmetricsJobCheckpointsCount(settings.FlinkmetricsJobCheckpointsCount),
		metricFlinkmetricsJobLastCheckpointSize:                               newMetricFlinkmetricsJobLastCheckpointSize(settings.FlinkmetricsJobLastCheckpointSize),
		metricFlinkmetricsJobLastCheckpointTime:                               newMetricFlinkmetricsJobLastCheckpointTime(settings.FlinkmetricsJobLastCheckpointTime),
		metricFlinkmetricsJobRestartCount:                                     newMetricFlinkmetricsJobRestartCount(settings.FlinkmetricsJobRestartCount),
		metricFlinkmetricsJobmanagerStatusFlinkMemoryManagedTotal:             newMetricFlinkmetricsJobmanagerStatusFlinkMemoryManagedTotal(settings.FlinkmetricsJobmanagerStatusFlinkMemoryManagedTotal),
		metricFlinkmetricsJobmanagerStatusFlinkMemoryManagedUsed:              newMetricFlinkmetricsJobmanagerStatusFlinkMemoryManagedUsed(settings.FlinkmetricsJobmanagerStatusFlinkMemoryManagedUsed),
		metricFlinkmetricsJobmanagerStatusJvmClassLoaderClassesLoaded:         newMetricFlinkmetricsJobmanagerStatusJvmClassLoaderClassesLoaded(settings.FlinkmetricsJobmanagerStatusJvmClassLoaderClassesLoaded),
		metricFlinkmetricsJobmanagerStatusJvmCPULoad:                          newMetricFlinkmetricsJobmanagerStatusJvmCPULoad(settings.FlinkmetricsJobmanagerStatusJvmCPULoad),
		metricFlinkmetricsJobmanagerStatusJvmCPUTime:                          newMetricFlinkmetricsJobmanagerStatusJvmCPUTime(settings.FlinkmetricsJobmanagerStatusJvmCPUTime),
		metricFlinkmetricsJobmanagerStatusJvmGarbageCollectorCollectionCount:  newMetricFlinkmetricsJobmanagerStatusJvmGarbageCollectorCollectionCount(settings.FlinkmetricsJobmanagerStatusJvmGarbageCollectorCollectionCount),
		metricFlinkmetricsJobmanagerStatusJvmGarbageCollectorCollectionTime:   newMetricFlinkmetricsJobmanagerStatusJvmGarbageCollectorCollectionTime(settings.FlinkmetricsJobmanagerStatusJvmGarbageCollectorCollectionTime),
		metricFlinkmetricsJobmanagerStatusJvmMemoryDirectTotalCapacity:        newMetricFlinkmetricsJobmanagerStatusJvmMemoryDirectTotalCapacity(settings.FlinkmetricsJobmanagerStatusJvmMemoryDirectTotalCapacity),
		metricFlinkmetricsJobmanagerStatusJvmMemoryDirectUsed:                 newMetricFlinkmetricsJobmanagerStatusJvmMemoryDirectUsed(settings.FlinkmetricsJobmanagerStatusJvmMemoryDirectUsed),
		metricFlinkmetricsJobmanagerStatusJvmMemoryHeapCommitted:              newMetricFlinkmetricsJobmanagerStatusJvmMemoryHeapCommitted(settings.FlinkmetricsJobmanagerStatusJvmMemoryHeapCommitted),
		metricFlinkmetricsJobmanagerStatusJvmMemoryHeapMax:                    newMetricFlinkmetricsJobmanagerStatusJvmMemoryHeapMax(settings.FlinkmetricsJobmanagerStatusJvmMemoryHeapMax),
		metricFlinkmetricsJobmanagerStatusJvmMemoryHeapUsed:                   newMetricFlinkmetricsJobmanagerStatusJvmMemoryHeapUsed(settings.FlinkmetricsJobmanagerStatusJvmMemoryHeapUsed),
		metricFlinkmetricsJobmanagerStatusJvmMemoryMappedTotalCapacity:        newMetricFlinkmetricsJobmanagerStatusJvmMemoryMappedTotalCapacity(settings.FlinkmetricsJobmanagerStatusJvmMemoryMappedTotalCapacity),
		metricFlinkmetricsJobmanagerStatusJvmMemoryMappedUsed:                 newMetricFlinkmetricsJobmanagerStatusJvmMemoryMappedUsed(settings.FlinkmetricsJobmanagerStatusJvmMemoryMappedUsed),
		metricFlinkmetricsJobmanagerStatusJvmMemoryMetaspaceCommitted:         newMetricFlinkmetricsJobmanagerStatusJvmMemoryMetaspaceCommitted(settings.FlinkmetricsJobmanagerStatusJvmMemoryMetaspaceCommitted),
		metricFlinkmetricsJobmanagerStatusJvmMemoryMetaspaceMax:               newMetricFlinkmetricsJobmanagerStatusJvmMemoryMetaspaceMax(settings.FlinkmetricsJobmanagerStatusJvmMemoryMetaspaceMax),
		metricFlinkmetricsJobmanagerStatusJvmMemoryMetaspaceUsed:              newMetricFlinkmetricsJobmanagerStatusJvmMemoryMetaspaceUsed(settings.FlinkmetricsJobmanagerStatusJvmMemoryMetaspaceUsed),
		metricFlinkmetricsJobmanagerStatusJvmMemoryNonHeapCommitted:           newMetricFlinkmetricsJobmanagerStatusJvmMemoryNonHeapCommitted(settings.FlinkmetricsJobmanagerStatusJvmMemoryNonHeapCommitted),
		metricFlinkmetricsJobmanagerStatusJvmMemoryNonHeapMax:                 newMetricFlinkmetricsJobmanagerStatusJvmMemoryNonHeapMax(settings.FlinkmetricsJobmanagerStatusJvmMemoryNonHeapMax),
		metricFlinkmetricsJobmanagerStatusJvmMemoryNonHeapUsed:                newMetricFlinkmetricsJobmanagerStatusJvmMemoryNonHeapUsed(settings.FlinkmetricsJobmanagerStatusJvmMemoryNonHeapUsed),
		metricFlinkmetricsJobmanagerStatusJvmThreadsCount:                     newMetricFlinkmetricsJobmanagerStatusJvmThreadsCount(settings.FlinkmetricsJobmanagerStatusJvmThreadsCount),
		metricFlinkmetricsOperatorRecordCount:                                 newMetricFlinkmetricsOperatorRecordCount(settings.FlinkmetricsOperatorRecordCount),
		metricFlinkmetricsOperatorWatermarkOutput:                             newMetricFlinkmetricsOperatorWatermarkOutput(settings.FlinkmetricsOperatorWatermarkOutput),
		metricFlinkmetricsTaskRecordCount:                                     newMetricFlinkmetricsTaskRecordCount(settings.FlinkmetricsTaskRecordCount),
		metricFlinkmetricsTaskmanagerStatusFlinkMemoryManagedTotal:            newMetricFlinkmetricsTaskmanagerStatusFlinkMemoryManagedTotal(settings.FlinkmetricsTaskmanagerStatusFlinkMemoryManagedTotal),
		metricFlinkmetricsTaskmanagerStatusFlinkMemoryManagedUsed:             newMetricFlinkmetricsTaskmanagerStatusFlinkMemoryManagedUsed(settings.FlinkmetricsTaskmanagerStatusFlinkMemoryManagedUsed),
		metricFlinkmetricsTaskmanagerStatusJvmClassLoaderClassesLoaded:        newMetricFlinkmetricsTaskmanagerStatusJvmClassLoaderClassesLoaded(settings.FlinkmetricsTaskmanagerStatusJvmClassLoaderClassesLoaded),
		metricFlinkmetricsTaskmanagerStatusJvmCPULoad:                         newMetricFlinkmetricsTaskmanagerStatusJvmCPULoad(settings.FlinkmetricsTaskmanagerStatusJvmCPULoad),
		metricFlinkmetricsTaskmanagerStatusJvmCPUTime:                         newMetricFlinkmetricsTaskmanagerStatusJvmCPUTime(settings.FlinkmetricsTaskmanagerStatusJvmCPUTime),
		metricFlinkmetricsTaskmanagerStatusJvmGarbageCollectorCollectionCount: newMetricFlinkmetricsTaskmanagerStatusJvmGarbageCollectorCollectionCount(settings.FlinkmetricsTaskmanagerStatusJvmGarbageCollectorCollectionCount),
		metricFlinkmetricsTaskmanagerStatusJvmGarbageCollectorCollectionTime:  newMetricFlinkmetricsTaskmanagerStatusJvmGarbageCollectorCollectionTime(settings.FlinkmetricsTaskmanagerStatusJvmGarbageCollectorCollectionTime),
		metricFlinkmetricsTaskmanagerStatusJvmMemoryDirectTotalCapacity:       newMetricFlinkmetricsTaskmanagerStatusJvmMemoryDirectTotalCapacity(settings.FlinkmetricsTaskmanagerStatusJvmMemoryDirectTotalCapacity),
		metricFlinkmetricsTaskmanagerStatusJvmMemoryDirectUsed:                newMetricFlinkmetricsTaskmanagerStatusJvmMemoryDirectUsed(settings.FlinkmetricsTaskmanagerStatusJvmMemoryDirectUsed),
		metricFlinkmetricsTaskmanagerStatusJvmMemoryHeapCommitted:             newMetricFlinkmetricsTaskmanagerStatusJvmMemoryHeapCommitted(settings.FlinkmetricsTaskmanagerStatusJvmMemoryHeapCommitted),
		metricFlinkmetricsTaskmanagerStatusJvmMemoryHeapMax:                   newMetricFlinkmetricsTaskmanagerStatusJvmMemoryHeapMax(settings.FlinkmetricsTaskmanagerStatusJvmMemoryHeapMax),
		metricFlinkmetricsTaskmanagerStatusJvmMemoryHeapUsed:                  newMetricFlinkmetricsTaskmanagerStatusJvmMemoryHeapUsed(settings.FlinkmetricsTaskmanagerStatusJvmMemoryHeapUsed),
		metricFlinkmetricsTaskmanagerStatusJvmMemoryMappedTotalCapacity:       newMetricFlinkmetricsTaskmanagerStatusJvmMemoryMappedTotalCapacity(settings.FlinkmetricsTaskmanagerStatusJvmMemoryMappedTotalCapacity),
		metricFlinkmetricsTaskmanagerStatusJvmMemoryMappedUsed:                newMetricFlinkmetricsTaskmanagerStatusJvmMemoryMappedUsed(settings.FlinkmetricsTaskmanagerStatusJvmMemoryMappedUsed),
		metricFlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceCommitted:        newMetricFlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceCommitted(settings.FlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceCommitted),
		metricFlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceMax:              newMetricFlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceMax(settings.FlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceMax),
		metricFlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceUsed:             newMetricFlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceUsed(settings.FlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceUsed),
		metricFlinkmetricsTaskmanagerStatusJvmMemoryNonHeapCommitted:          newMetricFlinkmetricsTaskmanagerStatusJvmMemoryNonHeapCommitted(settings.FlinkmetricsTaskmanagerStatusJvmMemoryNonHeapCommitted),
		metricFlinkmetricsTaskmanagerStatusJvmMemoryNonHeapMax:                newMetricFlinkmetricsTaskmanagerStatusJvmMemoryNonHeapMax(settings.FlinkmetricsTaskmanagerStatusJvmMemoryNonHeapMax),
		metricFlinkmetricsTaskmanagerStatusJvmMemoryNonHeapUsed:               newMetricFlinkmetricsTaskmanagerStatusJvmMemoryNonHeapUsed(settings.FlinkmetricsTaskmanagerStatusJvmMemoryNonHeapUsed),
		metricFlinkmetricsTaskmanagerStatusJvmThreadsCount:                    newMetricFlinkmetricsTaskmanagerStatusJvmThreadsCount(settings.FlinkmetricsTaskmanagerStatusJvmThreadsCount),
	}
	for _, op := range options {
		op(mb)
	}
	return mb
}

// updateCapacity updates max length of metrics and resource attributes that will be used for the slice capacity.
func (mb *MetricsBuilder) updateCapacity(rm pmetric.ResourceMetrics) {
	if mb.metricsCapacity < rm.ScopeMetrics().At(0).Metrics().Len() {
		mb.metricsCapacity = rm.ScopeMetrics().At(0).Metrics().Len()
	}
	if mb.resourceCapacity < rm.Resource().Attributes().Len() {
		mb.resourceCapacity = rm.Resource().Attributes().Len()
	}
}

// ResourceMetricsOption applies changes to provided resource metrics.
type ResourceMetricsOption func(pmetric.ResourceMetrics)

// WithHost sets provided value as "host" attribute for current resource.
func WithHost(val string) ResourceMetricsOption {
	return func(rm pmetric.ResourceMetrics) {
		rm.Resource().Attributes().UpsertString("host", val)
	}
}

// WithJobName sets provided value as "job_name" attribute for current resource.
func WithJobName(val string) ResourceMetricsOption {
	return func(rm pmetric.ResourceMetrics) {
		rm.Resource().Attributes().UpsertString("job_name", val)
	}
}

// WithSubtaskIndex sets provided value as "subtask_index" attribute for current resource.
func WithSubtaskIndex(val string) ResourceMetricsOption {
	return func(rm pmetric.ResourceMetrics) {
		rm.Resource().Attributes().UpsertString("subtask_index", val)
	}
}

// WithTaskName sets provided value as "task_name" attribute for current resource.
func WithTaskName(val string) ResourceMetricsOption {
	return func(rm pmetric.ResourceMetrics) {
		rm.Resource().Attributes().UpsertString("task_name", val)
	}
}

// WithTaskmanagerID sets provided value as "taskmanager_id" attribute for current resource.
func WithTaskmanagerID(val string) ResourceMetricsOption {
	return func(rm pmetric.ResourceMetrics) {
		rm.Resource().Attributes().UpsertString("taskmanager_id", val)
	}
}

// WithStartTimeOverride overrides start time for all the resource metrics data points.
// This option should be only used if different start time has to be set on metrics coming from different resources.
func WithStartTimeOverride(start pcommon.Timestamp) ResourceMetricsOption {
	return func(rm pmetric.ResourceMetrics) {
		var dps pmetric.NumberDataPointSlice
		metrics := rm.ScopeMetrics().At(0).Metrics()
		for i := 0; i < metrics.Len(); i++ {
			switch metrics.At(i).DataType() {
			case pmetric.MetricDataTypeGauge:
				dps = metrics.At(i).Gauge().DataPoints()
			case pmetric.MetricDataTypeSum:
				dps = metrics.At(i).Sum().DataPoints()
			}
			for j := 0; j < dps.Len(); j++ {
				dps.At(j).SetStartTimestamp(start)
			}
		}
	}
}

// EmitForResource saves all the generated metrics under a new resource and updates the internal state to be ready for
// recording another set of data points as part of another resource. This function can be helpful when one scraper
// needs to emit metrics from several resources. Otherwise calling this function is not required,
// just `Emit` function can be called instead.
// Resource attributes should be provided as ResourceMetricsOption arguments.
func (mb *MetricsBuilder) EmitForResource(rmo ...ResourceMetricsOption) {
	rm := pmetric.NewResourceMetrics()
	rm.Resource().Attributes().EnsureCapacity(mb.resourceCapacity)
	ils := rm.ScopeMetrics().AppendEmpty()
	ils.Scope().SetName("otelcol/flinkmetricsreceiver")
	ils.Metrics().EnsureCapacity(mb.metricsCapacity)
	mb.metricFlinkmetricsJobCheckpointsCount.emit(ils.Metrics())
	mb.metricFlinkmetricsJobLastCheckpointSize.emit(ils.Metrics())
	mb.metricFlinkmetricsJobLastCheckpointTime.emit(ils.Metrics())
	mb.metricFlinkmetricsJobRestartCount.emit(ils.Metrics())
	mb.metricFlinkmetricsJobmanagerStatusFlinkMemoryManagedTotal.emit(ils.Metrics())
	mb.metricFlinkmetricsJobmanagerStatusFlinkMemoryManagedUsed.emit(ils.Metrics())
	mb.metricFlinkmetricsJobmanagerStatusJvmClassLoaderClassesLoaded.emit(ils.Metrics())
	mb.metricFlinkmetricsJobmanagerStatusJvmCPULoad.emit(ils.Metrics())
	mb.metricFlinkmetricsJobmanagerStatusJvmCPUTime.emit(ils.Metrics())
	mb.metricFlinkmetricsJobmanagerStatusJvmGarbageCollectorCollectionCount.emit(ils.Metrics())
	mb.metricFlinkmetricsJobmanagerStatusJvmGarbageCollectorCollectionTime.emit(ils.Metrics())
	mb.metricFlinkmetricsJobmanagerStatusJvmMemoryDirectTotalCapacity.emit(ils.Metrics())
	mb.metricFlinkmetricsJobmanagerStatusJvmMemoryDirectUsed.emit(ils.Metrics())
	mb.metricFlinkmetricsJobmanagerStatusJvmMemoryHeapCommitted.emit(ils.Metrics())
	mb.metricFlinkmetricsJobmanagerStatusJvmMemoryHeapMax.emit(ils.Metrics())
	mb.metricFlinkmetricsJobmanagerStatusJvmMemoryHeapUsed.emit(ils.Metrics())
	mb.metricFlinkmetricsJobmanagerStatusJvmMemoryMappedTotalCapacity.emit(ils.Metrics())
	mb.metricFlinkmetricsJobmanagerStatusJvmMemoryMappedUsed.emit(ils.Metrics())
	mb.metricFlinkmetricsJobmanagerStatusJvmMemoryMetaspaceCommitted.emit(ils.Metrics())
	mb.metricFlinkmetricsJobmanagerStatusJvmMemoryMetaspaceMax.emit(ils.Metrics())
	mb.metricFlinkmetricsJobmanagerStatusJvmMemoryMetaspaceUsed.emit(ils.Metrics())
	mb.metricFlinkmetricsJobmanagerStatusJvmMemoryNonHeapCommitted.emit(ils.Metrics())
	mb.metricFlinkmetricsJobmanagerStatusJvmMemoryNonHeapMax.emit(ils.Metrics())
	mb.metricFlinkmetricsJobmanagerStatusJvmMemoryNonHeapUsed.emit(ils.Metrics())
	mb.metricFlinkmetricsJobmanagerStatusJvmThreadsCount.emit(ils.Metrics())
	mb.metricFlinkmetricsOperatorRecordCount.emit(ils.Metrics())
	mb.metricFlinkmetricsOperatorWatermarkOutput.emit(ils.Metrics())
	mb.metricFlinkmetricsTaskRecordCount.emit(ils.Metrics())
	mb.metricFlinkmetricsTaskmanagerStatusFlinkMemoryManagedTotal.emit(ils.Metrics())
	mb.metricFlinkmetricsTaskmanagerStatusFlinkMemoryManagedUsed.emit(ils.Metrics())
	mb.metricFlinkmetricsTaskmanagerStatusJvmClassLoaderClassesLoaded.emit(ils.Metrics())
	mb.metricFlinkmetricsTaskmanagerStatusJvmCPULoad.emit(ils.Metrics())
	mb.metricFlinkmetricsTaskmanagerStatusJvmCPUTime.emit(ils.Metrics())
	mb.metricFlinkmetricsTaskmanagerStatusJvmGarbageCollectorCollectionCount.emit(ils.Metrics())
	mb.metricFlinkmetricsTaskmanagerStatusJvmGarbageCollectorCollectionTime.emit(ils.Metrics())
	mb.metricFlinkmetricsTaskmanagerStatusJvmMemoryDirectTotalCapacity.emit(ils.Metrics())
	mb.metricFlinkmetricsTaskmanagerStatusJvmMemoryDirectUsed.emit(ils.Metrics())
	mb.metricFlinkmetricsTaskmanagerStatusJvmMemoryHeapCommitted.emit(ils.Metrics())
	mb.metricFlinkmetricsTaskmanagerStatusJvmMemoryHeapMax.emit(ils.Metrics())
	mb.metricFlinkmetricsTaskmanagerStatusJvmMemoryHeapUsed.emit(ils.Metrics())
	mb.metricFlinkmetricsTaskmanagerStatusJvmMemoryMappedTotalCapacity.emit(ils.Metrics())
	mb.metricFlinkmetricsTaskmanagerStatusJvmMemoryMappedUsed.emit(ils.Metrics())
	mb.metricFlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceCommitted.emit(ils.Metrics())
	mb.metricFlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceMax.emit(ils.Metrics())
	mb.metricFlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceUsed.emit(ils.Metrics())
	mb.metricFlinkmetricsTaskmanagerStatusJvmMemoryNonHeapCommitted.emit(ils.Metrics())
	mb.metricFlinkmetricsTaskmanagerStatusJvmMemoryNonHeapMax.emit(ils.Metrics())
	mb.metricFlinkmetricsTaskmanagerStatusJvmMemoryNonHeapUsed.emit(ils.Metrics())
	mb.metricFlinkmetricsTaskmanagerStatusJvmThreadsCount.emit(ils.Metrics())
	for _, op := range rmo {
		op(rm)
	}
	if ils.Metrics().Len() > 0 {
		mb.updateCapacity(rm)
		rm.MoveTo(mb.metricsBuffer.ResourceMetrics().AppendEmpty())
	}
}

// Emit returns all the metrics accumulated by the metrics builder and updates the internal state to be ready for
// recording another set of metrics. This function will be responsible for applying all the transformations required to
// produce metric representation defined in metadata and user settings, e.g. delta or cumulative.
func (mb *MetricsBuilder) Emit(rmo ...ResourceMetricsOption) pmetric.Metrics {
	mb.EmitForResource(rmo...)
	metrics := pmetric.NewMetrics()
	mb.metricsBuffer.MoveTo(metrics)
	return metrics
}

// RecordFlinkmetricsJobCheckpointsCountDataPoint adds a data point to flinkmetrics.job.checkpoints.count metric.
func (mb *MetricsBuilder) RecordFlinkmetricsJobCheckpointsCountDataPoint(ts pcommon.Timestamp, inputVal string, checkpointAttributeValue AttributeCheckpoint) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkmetricsJobCheckpointsCount, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkmetricsJobCheckpointsCount.recordDataPoint(mb.startTime, ts, val, checkpointAttributeValue.String())
	return nil
}

// RecordFlinkmetricsJobLastCheckpointSizeDataPoint adds a data point to flinkmetrics.job.last_checkpoint.size metric.
func (mb *MetricsBuilder) RecordFlinkmetricsJobLastCheckpointSizeDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkmetricsJobLastCheckpointSize, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkmetricsJobLastCheckpointSize.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkmetricsJobLastCheckpointTimeDataPoint adds a data point to flinkmetrics.job.last_checkpoint.time metric.
func (mb *MetricsBuilder) RecordFlinkmetricsJobLastCheckpointTimeDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkmetricsJobLastCheckpointTime, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkmetricsJobLastCheckpointTime.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkmetricsJobRestartCountDataPoint adds a data point to flinkmetrics.job.restart.count metric.
func (mb *MetricsBuilder) RecordFlinkmetricsJobRestartCountDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkmetricsJobRestartCount, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkmetricsJobRestartCount.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkmetricsJobmanagerStatusFlinkMemoryManagedTotalDataPoint adds a data point to flinkmetrics.jobmanager.status.flink.memory.managed.total metric.
func (mb *MetricsBuilder) RecordFlinkmetricsJobmanagerStatusFlinkMemoryManagedTotalDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkmetricsJobmanagerStatusFlinkMemoryManagedTotal, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkmetricsJobmanagerStatusFlinkMemoryManagedTotal.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkmetricsJobmanagerStatusFlinkMemoryManagedUsedDataPoint adds a data point to flinkmetrics.jobmanager.status.flink.memory.managed.used metric.
func (mb *MetricsBuilder) RecordFlinkmetricsJobmanagerStatusFlinkMemoryManagedUsedDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkmetricsJobmanagerStatusFlinkMemoryManagedUsed, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkmetricsJobmanagerStatusFlinkMemoryManagedUsed.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkmetricsJobmanagerStatusJvmClassLoaderClassesLoadedDataPoint adds a data point to flinkmetrics.jobmanager.status.jvm.class_loader.classes_loaded metric.
func (mb *MetricsBuilder) RecordFlinkmetricsJobmanagerStatusJvmClassLoaderClassesLoadedDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkmetricsJobmanagerStatusJvmClassLoaderClassesLoaded, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkmetricsJobmanagerStatusJvmClassLoaderClassesLoaded.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkmetricsJobmanagerStatusJvmCPULoadDataPoint adds a data point to flinkmetrics.jobmanager.status.jvm.cpu.load metric.
func (mb *MetricsBuilder) RecordFlinkmetricsJobmanagerStatusJvmCPULoadDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseFloat(inputVal, 64)
	if err != nil {
		return fmt.Errorf("failed to parse float64 for FlinkmetricsJobmanagerStatusJvmCPULoad, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkmetricsJobmanagerStatusJvmCPULoad.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkmetricsJobmanagerStatusJvmCPUTimeDataPoint adds a data point to flinkmetrics.jobmanager.status.jvm.cpu.time metric.
func (mb *MetricsBuilder) RecordFlinkmetricsJobmanagerStatusJvmCPUTimeDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkmetricsJobmanagerStatusJvmCPUTime, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkmetricsJobmanagerStatusJvmCPUTime.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkmetricsJobmanagerStatusJvmGarbageCollectorCollectionCountDataPoint adds a data point to flinkmetrics.jobmanager.status.jvm.garbage_collector.collection.count metric.
func (mb *MetricsBuilder) RecordFlinkmetricsJobmanagerStatusJvmGarbageCollectorCollectionCountDataPoint(ts pcommon.Timestamp, inputVal string, garbageCollectorNameAttributeValue string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkmetricsJobmanagerStatusJvmGarbageCollectorCollectionCount, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkmetricsJobmanagerStatusJvmGarbageCollectorCollectionCount.recordDataPoint(mb.startTime, ts, val, garbageCollectorNameAttributeValue)
	return nil
}

// RecordFlinkmetricsJobmanagerStatusJvmGarbageCollectorCollectionTimeDataPoint adds a data point to flinkmetrics.jobmanager.status.jvm.garbage_collector.collection.time metric.
func (mb *MetricsBuilder) RecordFlinkmetricsJobmanagerStatusJvmGarbageCollectorCollectionTimeDataPoint(ts pcommon.Timestamp, inputVal string, garbageCollectorNameAttributeValue string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkmetricsJobmanagerStatusJvmGarbageCollectorCollectionTime, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkmetricsJobmanagerStatusJvmGarbageCollectorCollectionTime.recordDataPoint(mb.startTime, ts, val, garbageCollectorNameAttributeValue)
	return nil
}

// RecordFlinkmetricsJobmanagerStatusJvmMemoryDirectTotalCapacityDataPoint adds a data point to flinkmetrics.jobmanager.status.jvm.memory.direct.total_capacity metric.
func (mb *MetricsBuilder) RecordFlinkmetricsJobmanagerStatusJvmMemoryDirectTotalCapacityDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkmetricsJobmanagerStatusJvmMemoryDirectTotalCapacity, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkmetricsJobmanagerStatusJvmMemoryDirectTotalCapacity.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkmetricsJobmanagerStatusJvmMemoryDirectUsedDataPoint adds a data point to flinkmetrics.jobmanager.status.jvm.memory.direct.used metric.
func (mb *MetricsBuilder) RecordFlinkmetricsJobmanagerStatusJvmMemoryDirectUsedDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkmetricsJobmanagerStatusJvmMemoryDirectUsed, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkmetricsJobmanagerStatusJvmMemoryDirectUsed.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkmetricsJobmanagerStatusJvmMemoryHeapCommittedDataPoint adds a data point to flinkmetrics.jobmanager.status.jvm.memory.heap.committed metric.
func (mb *MetricsBuilder) RecordFlinkmetricsJobmanagerStatusJvmMemoryHeapCommittedDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkmetricsJobmanagerStatusJvmMemoryHeapCommitted, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkmetricsJobmanagerStatusJvmMemoryHeapCommitted.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkmetricsJobmanagerStatusJvmMemoryHeapMaxDataPoint adds a data point to flinkmetrics.jobmanager.status.jvm.memory.heap.max metric.
func (mb *MetricsBuilder) RecordFlinkmetricsJobmanagerStatusJvmMemoryHeapMaxDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkmetricsJobmanagerStatusJvmMemoryHeapMax, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkmetricsJobmanagerStatusJvmMemoryHeapMax.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkmetricsJobmanagerStatusJvmMemoryHeapUsedDataPoint adds a data point to flinkmetrics.jobmanager.status.jvm.memory.heap.used metric.
func (mb *MetricsBuilder) RecordFlinkmetricsJobmanagerStatusJvmMemoryHeapUsedDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkmetricsJobmanagerStatusJvmMemoryHeapUsed, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkmetricsJobmanagerStatusJvmMemoryHeapUsed.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkmetricsJobmanagerStatusJvmMemoryMappedTotalCapacityDataPoint adds a data point to flinkmetrics.jobmanager.status.jvm.memory.mapped.total_capacity metric.
func (mb *MetricsBuilder) RecordFlinkmetricsJobmanagerStatusJvmMemoryMappedTotalCapacityDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkmetricsJobmanagerStatusJvmMemoryMappedTotalCapacity, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkmetricsJobmanagerStatusJvmMemoryMappedTotalCapacity.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkmetricsJobmanagerStatusJvmMemoryMappedUsedDataPoint adds a data point to flinkmetrics.jobmanager.status.jvm.memory.mapped.used metric.
func (mb *MetricsBuilder) RecordFlinkmetricsJobmanagerStatusJvmMemoryMappedUsedDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkmetricsJobmanagerStatusJvmMemoryMappedUsed, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkmetricsJobmanagerStatusJvmMemoryMappedUsed.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkmetricsJobmanagerStatusJvmMemoryMetaspaceCommittedDataPoint adds a data point to flinkmetrics.jobmanager.status.jvm.memory.metaspace.committed metric.
func (mb *MetricsBuilder) RecordFlinkmetricsJobmanagerStatusJvmMemoryMetaspaceCommittedDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkmetricsJobmanagerStatusJvmMemoryMetaspaceCommitted, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkmetricsJobmanagerStatusJvmMemoryMetaspaceCommitted.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkmetricsJobmanagerStatusJvmMemoryMetaspaceMaxDataPoint adds a data point to flinkmetrics.jobmanager.status.jvm.memory.metaspace.max metric.
func (mb *MetricsBuilder) RecordFlinkmetricsJobmanagerStatusJvmMemoryMetaspaceMaxDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkmetricsJobmanagerStatusJvmMemoryMetaspaceMax, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkmetricsJobmanagerStatusJvmMemoryMetaspaceMax.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkmetricsJobmanagerStatusJvmMemoryMetaspaceUsedDataPoint adds a data point to flinkmetrics.jobmanager.status.jvm.memory.metaspace.used metric.
func (mb *MetricsBuilder) RecordFlinkmetricsJobmanagerStatusJvmMemoryMetaspaceUsedDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkmetricsJobmanagerStatusJvmMemoryMetaspaceUsed, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkmetricsJobmanagerStatusJvmMemoryMetaspaceUsed.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkmetricsJobmanagerStatusJvmMemoryNonHeapCommittedDataPoint adds a data point to flinkmetrics.jobmanager.status.jvm.memory.non_heap.committed metric.
func (mb *MetricsBuilder) RecordFlinkmetricsJobmanagerStatusJvmMemoryNonHeapCommittedDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkmetricsJobmanagerStatusJvmMemoryNonHeapCommitted, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkmetricsJobmanagerStatusJvmMemoryNonHeapCommitted.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkmetricsJobmanagerStatusJvmMemoryNonHeapMaxDataPoint adds a data point to flinkmetrics.jobmanager.status.jvm.memory.non_heap.max metric.
func (mb *MetricsBuilder) RecordFlinkmetricsJobmanagerStatusJvmMemoryNonHeapMaxDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkmetricsJobmanagerStatusJvmMemoryNonHeapMax, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkmetricsJobmanagerStatusJvmMemoryNonHeapMax.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkmetricsJobmanagerStatusJvmMemoryNonHeapUsedDataPoint adds a data point to flinkmetrics.jobmanager.status.jvm.memory.non_heap.used metric.
func (mb *MetricsBuilder) RecordFlinkmetricsJobmanagerStatusJvmMemoryNonHeapUsedDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkmetricsJobmanagerStatusJvmMemoryNonHeapUsed, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkmetricsJobmanagerStatusJvmMemoryNonHeapUsed.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkmetricsJobmanagerStatusJvmThreadsCountDataPoint adds a data point to flinkmetrics.jobmanager.status.jvm.threads.count metric.
func (mb *MetricsBuilder) RecordFlinkmetricsJobmanagerStatusJvmThreadsCountDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkmetricsJobmanagerStatusJvmThreadsCount, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkmetricsJobmanagerStatusJvmThreadsCount.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkmetricsOperatorRecordCountDataPoint adds a data point to flinkmetrics.operator.record.count metric.
func (mb *MetricsBuilder) RecordFlinkmetricsOperatorRecordCountDataPoint(ts pcommon.Timestamp, inputVal string, operatorNameAttributeValue string, recordAttributeValue AttributeRecord) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkmetricsOperatorRecordCount, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkmetricsOperatorRecordCount.recordDataPoint(mb.startTime, ts, val, operatorNameAttributeValue, recordAttributeValue.String())
	return nil
}

// RecordFlinkmetricsOperatorWatermarkOutputDataPoint adds a data point to flinkmetrics.operator.watermark.output metric.
func (mb *MetricsBuilder) RecordFlinkmetricsOperatorWatermarkOutputDataPoint(ts pcommon.Timestamp, inputVal string, operatorNameAttributeValue string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkmetricsOperatorWatermarkOutput, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkmetricsOperatorWatermarkOutput.recordDataPoint(mb.startTime, ts, val, operatorNameAttributeValue)
	return nil
}

// RecordFlinkmetricsTaskRecordCountDataPoint adds a data point to flinkmetrics.task.record.count metric.
func (mb *MetricsBuilder) RecordFlinkmetricsTaskRecordCountDataPoint(ts pcommon.Timestamp, inputVal string, recordAttributeValue AttributeRecord) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkmetricsTaskRecordCount, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkmetricsTaskRecordCount.recordDataPoint(mb.startTime, ts, val, recordAttributeValue.String())
	return nil
}

// RecordFlinkmetricsTaskmanagerStatusFlinkMemoryManagedTotalDataPoint adds a data point to flinkmetrics.taskmanager.status.flink.memory.managed.total metric.
func (mb *MetricsBuilder) RecordFlinkmetricsTaskmanagerStatusFlinkMemoryManagedTotalDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkmetricsTaskmanagerStatusFlinkMemoryManagedTotal, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkmetricsTaskmanagerStatusFlinkMemoryManagedTotal.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkmetricsTaskmanagerStatusFlinkMemoryManagedUsedDataPoint adds a data point to flinkmetrics.taskmanager.status.flink.memory.managed.used metric.
func (mb *MetricsBuilder) RecordFlinkmetricsTaskmanagerStatusFlinkMemoryManagedUsedDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkmetricsTaskmanagerStatusFlinkMemoryManagedUsed, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkmetricsTaskmanagerStatusFlinkMemoryManagedUsed.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkmetricsTaskmanagerStatusJvmClassLoaderClassesLoadedDataPoint adds a data point to flinkmetrics.taskmanager.status.jvm.class_loader.classes_loaded metric.
func (mb *MetricsBuilder) RecordFlinkmetricsTaskmanagerStatusJvmClassLoaderClassesLoadedDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkmetricsTaskmanagerStatusJvmClassLoaderClassesLoaded, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkmetricsTaskmanagerStatusJvmClassLoaderClassesLoaded.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkmetricsTaskmanagerStatusJvmCPULoadDataPoint adds a data point to flinkmetrics.taskmanager.status.jvm.cpu.load metric.
func (mb *MetricsBuilder) RecordFlinkmetricsTaskmanagerStatusJvmCPULoadDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseFloat(inputVal, 64)
	if err != nil {
		return fmt.Errorf("failed to parse float64 for FlinkmetricsTaskmanagerStatusJvmCPULoad, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkmetricsTaskmanagerStatusJvmCPULoad.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkmetricsTaskmanagerStatusJvmCPUTimeDataPoint adds a data point to flinkmetrics.taskmanager.status.jvm.cpu.time metric.
func (mb *MetricsBuilder) RecordFlinkmetricsTaskmanagerStatusJvmCPUTimeDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkmetricsTaskmanagerStatusJvmCPUTime, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkmetricsTaskmanagerStatusJvmCPUTime.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkmetricsTaskmanagerStatusJvmGarbageCollectorCollectionCountDataPoint adds a data point to flinkmetrics.taskmanager.status.jvm.garbage_collector.collection.count metric.
func (mb *MetricsBuilder) RecordFlinkmetricsTaskmanagerStatusJvmGarbageCollectorCollectionCountDataPoint(ts pcommon.Timestamp, inputVal string, garbageCollectorNameAttributeValue string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkmetricsTaskmanagerStatusJvmGarbageCollectorCollectionCount, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkmetricsTaskmanagerStatusJvmGarbageCollectorCollectionCount.recordDataPoint(mb.startTime, ts, val, garbageCollectorNameAttributeValue)
	return nil
}

// RecordFlinkmetricsTaskmanagerStatusJvmGarbageCollectorCollectionTimeDataPoint adds a data point to flinkmetrics.taskmanager.status.jvm.garbage_collector.collection.time metric.
func (mb *MetricsBuilder) RecordFlinkmetricsTaskmanagerStatusJvmGarbageCollectorCollectionTimeDataPoint(ts pcommon.Timestamp, inputVal string, garbageCollectorNameAttributeValue string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkmetricsTaskmanagerStatusJvmGarbageCollectorCollectionTime, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkmetricsTaskmanagerStatusJvmGarbageCollectorCollectionTime.recordDataPoint(mb.startTime, ts, val, garbageCollectorNameAttributeValue)
	return nil
}

// RecordFlinkmetricsTaskmanagerStatusJvmMemoryDirectTotalCapacityDataPoint adds a data point to flinkmetrics.taskmanager.status.jvm.memory.direct.total_capacity metric.
func (mb *MetricsBuilder) RecordFlinkmetricsTaskmanagerStatusJvmMemoryDirectTotalCapacityDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkmetricsTaskmanagerStatusJvmMemoryDirectTotalCapacity, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkmetricsTaskmanagerStatusJvmMemoryDirectTotalCapacity.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkmetricsTaskmanagerStatusJvmMemoryDirectUsedDataPoint adds a data point to flinkmetrics.taskmanager.status.jvm.memory.direct.used metric.
func (mb *MetricsBuilder) RecordFlinkmetricsTaskmanagerStatusJvmMemoryDirectUsedDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkmetricsTaskmanagerStatusJvmMemoryDirectUsed, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkmetricsTaskmanagerStatusJvmMemoryDirectUsed.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkmetricsTaskmanagerStatusJvmMemoryHeapCommittedDataPoint adds a data point to flinkmetrics.taskmanager.status.jvm.memory.heap.committed metric.
func (mb *MetricsBuilder) RecordFlinkmetricsTaskmanagerStatusJvmMemoryHeapCommittedDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkmetricsTaskmanagerStatusJvmMemoryHeapCommitted, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkmetricsTaskmanagerStatusJvmMemoryHeapCommitted.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkmetricsTaskmanagerStatusJvmMemoryHeapMaxDataPoint adds a data point to flinkmetrics.taskmanager.status.jvm.memory.heap.max metric.
func (mb *MetricsBuilder) RecordFlinkmetricsTaskmanagerStatusJvmMemoryHeapMaxDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkmetricsTaskmanagerStatusJvmMemoryHeapMax, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkmetricsTaskmanagerStatusJvmMemoryHeapMax.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkmetricsTaskmanagerStatusJvmMemoryHeapUsedDataPoint adds a data point to flinkmetrics.taskmanager.status.jvm.memory.heap.used metric.
func (mb *MetricsBuilder) RecordFlinkmetricsTaskmanagerStatusJvmMemoryHeapUsedDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkmetricsTaskmanagerStatusJvmMemoryHeapUsed, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkmetricsTaskmanagerStatusJvmMemoryHeapUsed.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkmetricsTaskmanagerStatusJvmMemoryMappedTotalCapacityDataPoint adds a data point to flinkmetrics.taskmanager.status.jvm.memory.mapped.total_capacity metric.
func (mb *MetricsBuilder) RecordFlinkmetricsTaskmanagerStatusJvmMemoryMappedTotalCapacityDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkmetricsTaskmanagerStatusJvmMemoryMappedTotalCapacity, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkmetricsTaskmanagerStatusJvmMemoryMappedTotalCapacity.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkmetricsTaskmanagerStatusJvmMemoryMappedUsedDataPoint adds a data point to flinkmetrics.taskmanager.status.jvm.memory.mapped.used metric.
func (mb *MetricsBuilder) RecordFlinkmetricsTaskmanagerStatusJvmMemoryMappedUsedDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkmetricsTaskmanagerStatusJvmMemoryMappedUsed, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkmetricsTaskmanagerStatusJvmMemoryMappedUsed.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceCommittedDataPoint adds a data point to flinkmetrics.taskmanager.status.jvm.memory.metaspace.committed metric.
func (mb *MetricsBuilder) RecordFlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceCommittedDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceCommitted, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceCommitted.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceMaxDataPoint adds a data point to flinkmetrics.taskmanager.status.jvm.memory.metaspace.max metric.
func (mb *MetricsBuilder) RecordFlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceMaxDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceMax, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceMax.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceUsedDataPoint adds a data point to flinkmetrics.taskmanager.status.jvm.memory.metaspace.used metric.
func (mb *MetricsBuilder) RecordFlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceUsedDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceUsed, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkmetricsTaskmanagerStatusJvmMemoryMetaspaceUsed.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkmetricsTaskmanagerStatusJvmMemoryNonHeapCommittedDataPoint adds a data point to flinkmetrics.taskmanager.status.jvm.memory.non_heap.committed metric.
func (mb *MetricsBuilder) RecordFlinkmetricsTaskmanagerStatusJvmMemoryNonHeapCommittedDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkmetricsTaskmanagerStatusJvmMemoryNonHeapCommitted, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkmetricsTaskmanagerStatusJvmMemoryNonHeapCommitted.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkmetricsTaskmanagerStatusJvmMemoryNonHeapMaxDataPoint adds a data point to flinkmetrics.taskmanager.status.jvm.memory.non_heap.max metric.
func (mb *MetricsBuilder) RecordFlinkmetricsTaskmanagerStatusJvmMemoryNonHeapMaxDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkmetricsTaskmanagerStatusJvmMemoryNonHeapMax, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkmetricsTaskmanagerStatusJvmMemoryNonHeapMax.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkmetricsTaskmanagerStatusJvmMemoryNonHeapUsedDataPoint adds a data point to flinkmetrics.taskmanager.status.jvm.memory.non_heap.used metric.
func (mb *MetricsBuilder) RecordFlinkmetricsTaskmanagerStatusJvmMemoryNonHeapUsedDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkmetricsTaskmanagerStatusJvmMemoryNonHeapUsed, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkmetricsTaskmanagerStatusJvmMemoryNonHeapUsed.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkmetricsTaskmanagerStatusJvmThreadsCountDataPoint adds a data point to flinkmetrics.taskmanager.status.jvm.threads.count metric.
func (mb *MetricsBuilder) RecordFlinkmetricsTaskmanagerStatusJvmThreadsCountDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkmetricsTaskmanagerStatusJvmThreadsCount, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkmetricsTaskmanagerStatusJvmThreadsCount.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// Reset resets metrics builder to its initial state. It should be used when external metrics source is restarted,
// and metrics builder should update its startTime and reset it's internal state accordingly.
func (mb *MetricsBuilder) Reset(options ...metricBuilderOption) {
	mb.startTime = pcommon.NewTimestampFromTime(time.Now())
	for _, op := range options {
		op(mb)
	}
}
