// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"fmt"
	"strconv"
	"time"

	"go.opentelemetry.io/collector/component"
	"go.opentelemetry.io/collector/pdata/pcommon"
	"go.opentelemetry.io/collector/pdata/pmetric"
)

// MetricSettings provides common settings for a particular metric.
type MetricSettings struct {
	Enabled bool `mapstructure:"enabled"`
}

// MetricsSettings provides settings for flinkmetricsreceiver metrics.
type MetricsSettings struct {
	FlinkJobCheckpointsCount                           MetricSettings `mapstructure:"flink.job.checkpoints.count"`
	FlinkJobLastCheckpointSize                         MetricSettings `mapstructure:"flink.job.last_checkpoint.size"`
	FlinkJobLastCheckpointTime                         MetricSettings `mapstructure:"flink.job.last_checkpoint.time"`
	FlinkJobRestartCount                               MetricSettings `mapstructure:"flink.job.restart.count"`
	FlinkJobmanagerJvmClassLoaderClassesLoaded         MetricSettings `mapstructure:"flink.jobmanager.jvm.class_loader.classes_loaded"`
	FlinkJobmanagerJvmCPULoad                          MetricSettings `mapstructure:"flink.jobmanager.jvm.cpu.load"`
	FlinkJobmanagerJvmCPUTime                          MetricSettings `mapstructure:"flink.jobmanager.jvm.cpu.time"`
	FlinkJobmanagerJvmGarbageCollectorCollectionCount  MetricSettings `mapstructure:"flink.jobmanager.jvm.garbage_collector.collection.count"`
	FlinkJobmanagerJvmGarbageCollectorCollectionTime   MetricSettings `mapstructure:"flink.jobmanager.jvm.garbage_collector.collection.time"`
	FlinkJobmanagerJvmMemoryDirectTotalCapacity        MetricSettings `mapstructure:"flink.jobmanager.jvm.memory.direct.total_capacity"`
	FlinkJobmanagerJvmMemoryDirectUsed                 MetricSettings `mapstructure:"flink.jobmanager.jvm.memory.direct.used"`
	FlinkJobmanagerJvmMemoryHeapCommitted              MetricSettings `mapstructure:"flink.jobmanager.jvm.memory.heap.committed"`
	FlinkJobmanagerJvmMemoryHeapMax                    MetricSettings `mapstructure:"flink.jobmanager.jvm.memory.heap.max"`
	FlinkJobmanagerJvmMemoryHeapUsed                   MetricSettings `mapstructure:"flink.jobmanager.jvm.memory.heap.used"`
	FlinkJobmanagerJvmMemoryMappedTotalCapacity        MetricSettings `mapstructure:"flink.jobmanager.jvm.memory.mapped.total_capacity"`
	FlinkJobmanagerJvmMemoryMappedUsed                 MetricSettings `mapstructure:"flink.jobmanager.jvm.memory.mapped.used"`
	FlinkJobmanagerJvmMemoryMetaspaceCommitted         MetricSettings `mapstructure:"flink.jobmanager.jvm.memory.metaspace.committed"`
	FlinkJobmanagerJvmMemoryMetaspaceMax               MetricSettings `mapstructure:"flink.jobmanager.jvm.memory.metaspace.max"`
	FlinkJobmanagerJvmMemoryMetaspaceUsed              MetricSettings `mapstructure:"flink.jobmanager.jvm.memory.metaspace.used"`
	FlinkJobmanagerJvmMemoryNonHeapCommitted           MetricSettings `mapstructure:"flink.jobmanager.jvm.memory.non_heap.committed"`
	FlinkJobmanagerJvmMemoryNonHeapMax                 MetricSettings `mapstructure:"flink.jobmanager.jvm.memory.non_heap.max"`
	FlinkJobmanagerJvmMemoryNonHeapUsed                MetricSettings `mapstructure:"flink.jobmanager.jvm.memory.non_heap.used"`
	FlinkJobmanagerJvmThreadsCount                     MetricSettings `mapstructure:"flink.jobmanager.jvm.threads.count"`
	FlinkJobmanagerMemoryManagedTotal                  MetricSettings `mapstructure:"flink.jobmanager.memory.managed.total"`
	FlinkJobmanagerMemoryManagedUsed                   MetricSettings `mapstructure:"flink.jobmanager.memory.managed.used"`
	FlinkOperatorRecordCount                           MetricSettings `mapstructure:"flink.operator.record.count"`
	FlinkOperatorWatermarkOutput                       MetricSettings `mapstructure:"flink.operator.watermark.output"`
	FlinkTaskRecordCount                               MetricSettings `mapstructure:"flink.task.record.count"`
	FlinkTaskmanagerJvmClassLoaderClassesLoaded        MetricSettings `mapstructure:"flink.taskmanager.jvm.class_loader.classes_loaded"`
	FlinkTaskmanagerJvmCPULoad                         MetricSettings `mapstructure:"flink.taskmanager.jvm.cpu.load"`
	FlinkTaskmanagerJvmCPUTime                         MetricSettings `mapstructure:"flink.taskmanager.jvm.cpu.time"`
	FlinkTaskmanagerJvmGarbageCollectorCollectionCount MetricSettings `mapstructure:"flink.taskmanager.jvm.garbage_collector.collection.count"`
	FlinkTaskmanagerJvmGarbageCollectorCollectionTime  MetricSettings `mapstructure:"flink.taskmanager.jvm.garbage_collector.collection.time"`
	FlinkTaskmanagerJvmMemoryDirectTotalCapacity       MetricSettings `mapstructure:"flink.taskmanager.jvm.memory.direct.total_capacity"`
	FlinkTaskmanagerJvmMemoryDirectUsed                MetricSettings `mapstructure:"flink.taskmanager.jvm.memory.direct.used"`
	FlinkTaskmanagerJvmMemoryHeapCommitted             MetricSettings `mapstructure:"flink.taskmanager.jvm.memory.heap.committed"`
	FlinkTaskmanagerJvmMemoryHeapMax                   MetricSettings `mapstructure:"flink.taskmanager.jvm.memory.heap.max"`
	FlinkTaskmanagerJvmMemoryHeapUsed                  MetricSettings `mapstructure:"flink.taskmanager.jvm.memory.heap.used"`
	FlinkTaskmanagerJvmMemoryMappedTotalCapacity       MetricSettings `mapstructure:"flink.taskmanager.jvm.memory.mapped.total_capacity"`
	FlinkTaskmanagerJvmMemoryMappedUsed                MetricSettings `mapstructure:"flink.taskmanager.jvm.memory.mapped.used"`
	FlinkTaskmanagerJvmMemoryMetaspaceCommitted        MetricSettings `mapstructure:"flink.taskmanager.jvm.memory.metaspace.committed"`
	FlinkTaskmanagerJvmMemoryMetaspaceMax              MetricSettings `mapstructure:"flink.taskmanager.jvm.memory.metaspace.max"`
	FlinkTaskmanagerJvmMemoryMetaspaceUsed             MetricSettings `mapstructure:"flink.taskmanager.jvm.memory.metaspace.used"`
	FlinkTaskmanagerJvmMemoryNonHeapCommitted          MetricSettings `mapstructure:"flink.taskmanager.jvm.memory.non_heap.committed"`
	FlinkTaskmanagerJvmMemoryNonHeapMax                MetricSettings `mapstructure:"flink.taskmanager.jvm.memory.non_heap.max"`
	FlinkTaskmanagerJvmMemoryNonHeapUsed               MetricSettings `mapstructure:"flink.taskmanager.jvm.memory.non_heap.used"`
	FlinkTaskmanagerJvmThreadsCount                    MetricSettings `mapstructure:"flink.taskmanager.jvm.threads.count"`
	FlinkTaskmanagerMemoryManagedTotal                 MetricSettings `mapstructure:"flink.taskmanager.memory.managed.total"`
	FlinkTaskmanagerMemoryManagedUsed                  MetricSettings `mapstructure:"flink.taskmanager.memory.managed.used"`
}

func DefaultMetricsSettings() MetricsSettings {
	return MetricsSettings{
		FlinkJobCheckpointsCount: MetricSettings{
			Enabled: true,
		},
		FlinkJobLastCheckpointSize: MetricSettings{
			Enabled: true,
		},
		FlinkJobLastCheckpointTime: MetricSettings{
			Enabled: true,
		},
		FlinkJobRestartCount: MetricSettings{
			Enabled: true,
		},
		FlinkJobmanagerJvmClassLoaderClassesLoaded: MetricSettings{
			Enabled: true,
		},
		FlinkJobmanagerJvmCPULoad: MetricSettings{
			Enabled: true,
		},
		FlinkJobmanagerJvmCPUTime: MetricSettings{
			Enabled: true,
		},
		FlinkJobmanagerJvmGarbageCollectorCollectionCount: MetricSettings{
			Enabled: true,
		},
		FlinkJobmanagerJvmGarbageCollectorCollectionTime: MetricSettings{
			Enabled: true,
		},
		FlinkJobmanagerJvmMemoryDirectTotalCapacity: MetricSettings{
			Enabled: true,
		},
		FlinkJobmanagerJvmMemoryDirectUsed: MetricSettings{
			Enabled: true,
		},
		FlinkJobmanagerJvmMemoryHeapCommitted: MetricSettings{
			Enabled: true,
		},
		FlinkJobmanagerJvmMemoryHeapMax: MetricSettings{
			Enabled: true,
		},
		FlinkJobmanagerJvmMemoryHeapUsed: MetricSettings{
			Enabled: true,
		},
		FlinkJobmanagerJvmMemoryMappedTotalCapacity: MetricSettings{
			Enabled: true,
		},
		FlinkJobmanagerJvmMemoryMappedUsed: MetricSettings{
			Enabled: true,
		},
		FlinkJobmanagerJvmMemoryMetaspaceCommitted: MetricSettings{
			Enabled: true,
		},
		FlinkJobmanagerJvmMemoryMetaspaceMax: MetricSettings{
			Enabled: true,
		},
		FlinkJobmanagerJvmMemoryMetaspaceUsed: MetricSettings{
			Enabled: true,
		},
		FlinkJobmanagerJvmMemoryNonHeapCommitted: MetricSettings{
			Enabled: true,
		},
		FlinkJobmanagerJvmMemoryNonHeapMax: MetricSettings{
			Enabled: true,
		},
		FlinkJobmanagerJvmMemoryNonHeapUsed: MetricSettings{
			Enabled: true,
		},
		FlinkJobmanagerJvmThreadsCount: MetricSettings{
			Enabled: true,
		},
		FlinkJobmanagerMemoryManagedTotal: MetricSettings{
			Enabled: true,
		},
		FlinkJobmanagerMemoryManagedUsed: MetricSettings{
			Enabled: true,
		},
		FlinkOperatorRecordCount: MetricSettings{
			Enabled: true,
		},
		FlinkOperatorWatermarkOutput: MetricSettings{
			Enabled: true,
		},
		FlinkTaskRecordCount: MetricSettings{
			Enabled: true,
		},
		FlinkTaskmanagerJvmClassLoaderClassesLoaded: MetricSettings{
			Enabled: true,
		},
		FlinkTaskmanagerJvmCPULoad: MetricSettings{
			Enabled: true,
		},
		FlinkTaskmanagerJvmCPUTime: MetricSettings{
			Enabled: true,
		},
		FlinkTaskmanagerJvmGarbageCollectorCollectionCount: MetricSettings{
			Enabled: true,
		},
		FlinkTaskmanagerJvmGarbageCollectorCollectionTime: MetricSettings{
			Enabled: true,
		},
		FlinkTaskmanagerJvmMemoryDirectTotalCapacity: MetricSettings{
			Enabled: true,
		},
		FlinkTaskmanagerJvmMemoryDirectUsed: MetricSettings{
			Enabled: true,
		},
		FlinkTaskmanagerJvmMemoryHeapCommitted: MetricSettings{
			Enabled: true,
		},
		FlinkTaskmanagerJvmMemoryHeapMax: MetricSettings{
			Enabled: true,
		},
		FlinkTaskmanagerJvmMemoryHeapUsed: MetricSettings{
			Enabled: true,
		},
		FlinkTaskmanagerJvmMemoryMappedTotalCapacity: MetricSettings{
			Enabled: true,
		},
		FlinkTaskmanagerJvmMemoryMappedUsed: MetricSettings{
			Enabled: true,
		},
		FlinkTaskmanagerJvmMemoryMetaspaceCommitted: MetricSettings{
			Enabled: true,
		},
		FlinkTaskmanagerJvmMemoryMetaspaceMax: MetricSettings{
			Enabled: true,
		},
		FlinkTaskmanagerJvmMemoryMetaspaceUsed: MetricSettings{
			Enabled: true,
		},
		FlinkTaskmanagerJvmMemoryNonHeapCommitted: MetricSettings{
			Enabled: true,
		},
		FlinkTaskmanagerJvmMemoryNonHeapMax: MetricSettings{
			Enabled: true,
		},
		FlinkTaskmanagerJvmMemoryNonHeapUsed: MetricSettings{
			Enabled: true,
		},
		FlinkTaskmanagerJvmThreadsCount: MetricSettings{
			Enabled: true,
		},
		FlinkTaskmanagerMemoryManagedTotal: MetricSettings{
			Enabled: true,
		},
		FlinkTaskmanagerMemoryManagedUsed: MetricSettings{
			Enabled: true,
		},
	}
}

// AttributeCheckpoint specifies the a value checkpoint attribute.
type AttributeCheckpoint int

const (
	_ AttributeCheckpoint = iota
	AttributeCheckpointInProgress
	AttributeCheckpointCompleted
	AttributeCheckpointFailed
)

// String returns the string representation of the AttributeCheckpoint.
func (av AttributeCheckpoint) String() string {
	switch av {
	case AttributeCheckpointInProgress:
		return "in_progress"
	case AttributeCheckpointCompleted:
		return "completed"
	case AttributeCheckpointFailed:
		return "failed"
	}
	return ""
}

// MapAttributeCheckpoint is a helper map of string to AttributeCheckpoint attribute value.
var MapAttributeCheckpoint = map[string]AttributeCheckpoint{
	"in_progress": AttributeCheckpointInProgress,
	"completed":   AttributeCheckpointCompleted,
	"failed":      AttributeCheckpointFailed,
}

// AttributeRecord specifies the a value record attribute.
type AttributeRecord int

const (
	_ AttributeRecord = iota
	AttributeRecordIn
	AttributeRecordOut
	AttributeRecordLateRecordsDropped
)

// String returns the string representation of the AttributeRecord.
func (av AttributeRecord) String() string {
	switch av {
	case AttributeRecordIn:
		return "in"
	case AttributeRecordOut:
		return "out"
	case AttributeRecordLateRecordsDropped:
		return "late_records_dropped"
	}
	return ""
}

// MapAttributeRecord is a helper map of string to AttributeRecord attribute value.
var MapAttributeRecord = map[string]AttributeRecord{
	"in":                   AttributeRecordIn,
	"out":                  AttributeRecordOut,
	"late_records_dropped": AttributeRecordLateRecordsDropped,
}

type metricFlinkJobCheckpointsCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.job.checkpoints.count metric with initial data.
func (m *metricFlinkJobCheckpointsCount) init() {
	m.data.SetName("flink.job.checkpoints.count")
	m.data.SetDescription("The number of checkpoints by type.")
	m.data.SetUnit("{checkpoints}")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkJobCheckpointsCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, checkpointAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert("checkpoint", pcommon.NewValueString(checkpointAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkJobCheckpointsCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkJobCheckpointsCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkJobCheckpointsCount(settings MetricSettings) metricFlinkJobCheckpointsCount {
	m := metricFlinkJobCheckpointsCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkJobLastCheckpointSize struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.job.last_checkpoint.size metric with initial data.
func (m *metricFlinkJobLastCheckpointSize) init() {
	m.data.SetName("flink.job.last_checkpoint.size")
	m.data.SetDescription("The total size of the last checkpoint.")
	m.data.SetUnit("By")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkJobLastCheckpointSize) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkJobLastCheckpointSize) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkJobLastCheckpointSize) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkJobLastCheckpointSize(settings MetricSettings) metricFlinkJobLastCheckpointSize {
	m := metricFlinkJobLastCheckpointSize{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkJobLastCheckpointTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.job.last_checkpoint.time metric with initial data.
func (m *metricFlinkJobLastCheckpointTime) init() {
	m.data.SetName("flink.job.last_checkpoint.time")
	m.data.SetDescription("The end to end duration of the last checkpoint.")
	m.data.SetUnit("ms")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkJobLastCheckpointTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkJobLastCheckpointTime) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkJobLastCheckpointTime) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkJobLastCheckpointTime(settings MetricSettings) metricFlinkJobLastCheckpointTime {
	m := metricFlinkJobLastCheckpointTime{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkJobRestartCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.job.restart.count metric with initial data.
func (m *metricFlinkJobRestartCount) init() {
	m.data.SetName("flink.job.restart.count")
	m.data.SetDescription("The total number of restarts since this job was submitted, including full restarts and fine-grained restarts.")
	m.data.SetUnit("{restarts}")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkJobRestartCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkJobRestartCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkJobRestartCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkJobRestartCount(settings MetricSettings) metricFlinkJobRestartCount {
	m := metricFlinkJobRestartCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkJobmanagerJvmClassLoaderClassesLoaded struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.jobmanager.jvm.class_loader.classes_loaded metric with initial data.
func (m *metricFlinkJobmanagerJvmClassLoaderClassesLoaded) init() {
	m.data.SetName("flink.jobmanager.jvm.class_loader.classes_loaded")
	m.data.SetDescription("The total number of classes loaded since the start of the JVM for a jobmanager.")
	m.data.SetUnit("{classes}")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkJobmanagerJvmClassLoaderClassesLoaded) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkJobmanagerJvmClassLoaderClassesLoaded) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkJobmanagerJvmClassLoaderClassesLoaded) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkJobmanagerJvmClassLoaderClassesLoaded(settings MetricSettings) metricFlinkJobmanagerJvmClassLoaderClassesLoaded {
	m := metricFlinkJobmanagerJvmClassLoaderClassesLoaded{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkJobmanagerJvmCPULoad struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.jobmanager.jvm.cpu.load metric with initial data.
func (m *metricFlinkJobmanagerJvmCPULoad) init() {
	m.data.SetName("flink.jobmanager.jvm.cpu.load")
	m.data.SetDescription("The recent CPU usage of the JVM for a jobmanager.")
	m.data.SetUnit("1")
	m.data.SetDataType(pmetric.MetricDataTypeGauge)
}

func (m *metricFlinkJobmanagerJvmCPULoad) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkJobmanagerJvmCPULoad) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkJobmanagerJvmCPULoad) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkJobmanagerJvmCPULoad(settings MetricSettings) metricFlinkJobmanagerJvmCPULoad {
	m := metricFlinkJobmanagerJvmCPULoad{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkJobmanagerJvmCPUTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.jobmanager.jvm.cpu.time metric with initial data.
func (m *metricFlinkJobmanagerJvmCPUTime) init() {
	m.data.SetName("flink.jobmanager.jvm.cpu.time")
	m.data.SetDescription("The CPU time used by the JVM for a jobmanager.")
	m.data.SetUnit("ns")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkJobmanagerJvmCPUTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkJobmanagerJvmCPUTime) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkJobmanagerJvmCPUTime) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkJobmanagerJvmCPUTime(settings MetricSettings) metricFlinkJobmanagerJvmCPUTime {
	m := metricFlinkJobmanagerJvmCPUTime{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkJobmanagerJvmGarbageCollectorCollectionCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.jobmanager.jvm.garbage_collector.collection.count metric with initial data.
func (m *metricFlinkJobmanagerJvmGarbageCollectorCollectionCount) init() {
	m.data.SetName("flink.jobmanager.jvm.garbage_collector.collection.count")
	m.data.SetDescription("The total number of collections that have occurred for a jobmanager.")
	m.data.SetUnit("{collections}")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkJobmanagerJvmGarbageCollectorCollectionCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, garbageCollectorNameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert("garbage_collector_name", pcommon.NewValueString(garbageCollectorNameAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkJobmanagerJvmGarbageCollectorCollectionCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkJobmanagerJvmGarbageCollectorCollectionCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkJobmanagerJvmGarbageCollectorCollectionCount(settings MetricSettings) metricFlinkJobmanagerJvmGarbageCollectorCollectionCount {
	m := metricFlinkJobmanagerJvmGarbageCollectorCollectionCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkJobmanagerJvmGarbageCollectorCollectionTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.jobmanager.jvm.garbage_collector.collection.time metric with initial data.
func (m *metricFlinkJobmanagerJvmGarbageCollectorCollectionTime) init() {
	m.data.SetName("flink.jobmanager.jvm.garbage_collector.collection.time")
	m.data.SetDescription("The total time spent performing garbage collection for a jobmanager.")
	m.data.SetUnit("ms")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkJobmanagerJvmGarbageCollectorCollectionTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, garbageCollectorNameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert("garbage_collector_name", pcommon.NewValueString(garbageCollectorNameAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkJobmanagerJvmGarbageCollectorCollectionTime) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkJobmanagerJvmGarbageCollectorCollectionTime) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkJobmanagerJvmGarbageCollectorCollectionTime(settings MetricSettings) metricFlinkJobmanagerJvmGarbageCollectorCollectionTime {
	m := metricFlinkJobmanagerJvmGarbageCollectorCollectionTime{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkJobmanagerJvmMemoryDirectTotalCapacity struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.jobmanager.jvm.memory.direct.total_capacity metric with initial data.
func (m *metricFlinkJobmanagerJvmMemoryDirectTotalCapacity) init() {
	m.data.SetName("flink.jobmanager.jvm.memory.direct.total_capacity")
	m.data.SetDescription("The total capacity of all buffers in the direct buffer pool for a jobmanager.")
	m.data.SetUnit("By")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkJobmanagerJvmMemoryDirectTotalCapacity) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkJobmanagerJvmMemoryDirectTotalCapacity) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkJobmanagerJvmMemoryDirectTotalCapacity) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkJobmanagerJvmMemoryDirectTotalCapacity(settings MetricSettings) metricFlinkJobmanagerJvmMemoryDirectTotalCapacity {
	m := metricFlinkJobmanagerJvmMemoryDirectTotalCapacity{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkJobmanagerJvmMemoryDirectUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.jobmanager.jvm.memory.direct.used metric with initial data.
func (m *metricFlinkJobmanagerJvmMemoryDirectUsed) init() {
	m.data.SetName("flink.jobmanager.jvm.memory.direct.used")
	m.data.SetDescription("The amount of memory used by the JVM for the direct buffer pool for a jobmanager.")
	m.data.SetUnit("By")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkJobmanagerJvmMemoryDirectUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkJobmanagerJvmMemoryDirectUsed) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkJobmanagerJvmMemoryDirectUsed) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkJobmanagerJvmMemoryDirectUsed(settings MetricSettings) metricFlinkJobmanagerJvmMemoryDirectUsed {
	m := metricFlinkJobmanagerJvmMemoryDirectUsed{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkJobmanagerJvmMemoryHeapCommitted struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.jobmanager.jvm.memory.heap.committed metric with initial data.
func (m *metricFlinkJobmanagerJvmMemoryHeapCommitted) init() {
	m.data.SetName("flink.jobmanager.jvm.memory.heap.committed")
	m.data.SetDescription("The amount of heap memory guaranteed to be available to the JVM for a jobmanager.")
	m.data.SetUnit("By")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkJobmanagerJvmMemoryHeapCommitted) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkJobmanagerJvmMemoryHeapCommitted) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkJobmanagerJvmMemoryHeapCommitted) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkJobmanagerJvmMemoryHeapCommitted(settings MetricSettings) metricFlinkJobmanagerJvmMemoryHeapCommitted {
	m := metricFlinkJobmanagerJvmMemoryHeapCommitted{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkJobmanagerJvmMemoryHeapMax struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.jobmanager.jvm.memory.heap.max metric with initial data.
func (m *metricFlinkJobmanagerJvmMemoryHeapMax) init() {
	m.data.SetName("flink.jobmanager.jvm.memory.heap.max")
	m.data.SetDescription("The maximum amount of heap memory that can be used for memory management for a jobmanager.")
	m.data.SetUnit("By")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkJobmanagerJvmMemoryHeapMax) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkJobmanagerJvmMemoryHeapMax) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkJobmanagerJvmMemoryHeapMax) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkJobmanagerJvmMemoryHeapMax(settings MetricSettings) metricFlinkJobmanagerJvmMemoryHeapMax {
	m := metricFlinkJobmanagerJvmMemoryHeapMax{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkJobmanagerJvmMemoryHeapUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.jobmanager.jvm.memory.heap.used metric with initial data.
func (m *metricFlinkJobmanagerJvmMemoryHeapUsed) init() {
	m.data.SetName("flink.jobmanager.jvm.memory.heap.used")
	m.data.SetDescription("The amount of heap memory currently used for a jobmanager.")
	m.data.SetUnit("By")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkJobmanagerJvmMemoryHeapUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkJobmanagerJvmMemoryHeapUsed) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkJobmanagerJvmMemoryHeapUsed) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkJobmanagerJvmMemoryHeapUsed(settings MetricSettings) metricFlinkJobmanagerJvmMemoryHeapUsed {
	m := metricFlinkJobmanagerJvmMemoryHeapUsed{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkJobmanagerJvmMemoryMappedTotalCapacity struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.jobmanager.jvm.memory.mapped.total_capacity metric with initial data.
func (m *metricFlinkJobmanagerJvmMemoryMappedTotalCapacity) init() {
	m.data.SetName("flink.jobmanager.jvm.memory.mapped.total_capacity")
	m.data.SetDescription("The number of buffers in the mapped buffer pool for a jobmanager.")
	m.data.SetUnit("By")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkJobmanagerJvmMemoryMappedTotalCapacity) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkJobmanagerJvmMemoryMappedTotalCapacity) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkJobmanagerJvmMemoryMappedTotalCapacity) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkJobmanagerJvmMemoryMappedTotalCapacity(settings MetricSettings) metricFlinkJobmanagerJvmMemoryMappedTotalCapacity {
	m := metricFlinkJobmanagerJvmMemoryMappedTotalCapacity{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkJobmanagerJvmMemoryMappedUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.jobmanager.jvm.memory.mapped.used metric with initial data.
func (m *metricFlinkJobmanagerJvmMemoryMappedUsed) init() {
	m.data.SetName("flink.jobmanager.jvm.memory.mapped.used")
	m.data.SetDescription("The amount of memory used by the JVM for the mapped buffer pool for a jobmanager.")
	m.data.SetUnit("By")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkJobmanagerJvmMemoryMappedUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkJobmanagerJvmMemoryMappedUsed) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkJobmanagerJvmMemoryMappedUsed) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkJobmanagerJvmMemoryMappedUsed(settings MetricSettings) metricFlinkJobmanagerJvmMemoryMappedUsed {
	m := metricFlinkJobmanagerJvmMemoryMappedUsed{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkJobmanagerJvmMemoryMetaspaceCommitted struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.jobmanager.jvm.memory.metaspace.committed metric with initial data.
func (m *metricFlinkJobmanagerJvmMemoryMetaspaceCommitted) init() {
	m.data.SetName("flink.jobmanager.jvm.memory.metaspace.committed")
	m.data.SetDescription("The amount of memory guaranteed to be available to the JVM in the Metaspace memory pool for a jobmanager.")
	m.data.SetUnit("By")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkJobmanagerJvmMemoryMetaspaceCommitted) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkJobmanagerJvmMemoryMetaspaceCommitted) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkJobmanagerJvmMemoryMetaspaceCommitted) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkJobmanagerJvmMemoryMetaspaceCommitted(settings MetricSettings) metricFlinkJobmanagerJvmMemoryMetaspaceCommitted {
	m := metricFlinkJobmanagerJvmMemoryMetaspaceCommitted{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkJobmanagerJvmMemoryMetaspaceMax struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.jobmanager.jvm.memory.metaspace.max metric with initial data.
func (m *metricFlinkJobmanagerJvmMemoryMetaspaceMax) init() {
	m.data.SetName("flink.jobmanager.jvm.memory.metaspace.max")
	m.data.SetDescription("The maximum amount of memory that can be used in the Metaspace memory pool for a jobmanager.")
	m.data.SetUnit("By")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkJobmanagerJvmMemoryMetaspaceMax) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkJobmanagerJvmMemoryMetaspaceMax) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkJobmanagerJvmMemoryMetaspaceMax) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkJobmanagerJvmMemoryMetaspaceMax(settings MetricSettings) metricFlinkJobmanagerJvmMemoryMetaspaceMax {
	m := metricFlinkJobmanagerJvmMemoryMetaspaceMax{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkJobmanagerJvmMemoryMetaspaceUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.jobmanager.jvm.memory.metaspace.used metric with initial data.
func (m *metricFlinkJobmanagerJvmMemoryMetaspaceUsed) init() {
	m.data.SetName("flink.jobmanager.jvm.memory.metaspace.used")
	m.data.SetDescription("The amount of memory currently used in the Metaspace memory pool for a jobmanager.")
	m.data.SetUnit("By")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkJobmanagerJvmMemoryMetaspaceUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkJobmanagerJvmMemoryMetaspaceUsed) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkJobmanagerJvmMemoryMetaspaceUsed) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkJobmanagerJvmMemoryMetaspaceUsed(settings MetricSettings) metricFlinkJobmanagerJvmMemoryMetaspaceUsed {
	m := metricFlinkJobmanagerJvmMemoryMetaspaceUsed{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkJobmanagerJvmMemoryNonHeapCommitted struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.jobmanager.jvm.memory.non_heap.committed metric with initial data.
func (m *metricFlinkJobmanagerJvmMemoryNonHeapCommitted) init() {
	m.data.SetName("flink.jobmanager.jvm.memory.non_heap.committed")
	m.data.SetDescription("The amount of non-heap memory guaranteed to be available to the JVM for a jobmanager.")
	m.data.SetUnit("By")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkJobmanagerJvmMemoryNonHeapCommitted) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkJobmanagerJvmMemoryNonHeapCommitted) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkJobmanagerJvmMemoryNonHeapCommitted) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkJobmanagerJvmMemoryNonHeapCommitted(settings MetricSettings) metricFlinkJobmanagerJvmMemoryNonHeapCommitted {
	m := metricFlinkJobmanagerJvmMemoryNonHeapCommitted{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkJobmanagerJvmMemoryNonHeapMax struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.jobmanager.jvm.memory.non_heap.max metric with initial data.
func (m *metricFlinkJobmanagerJvmMemoryNonHeapMax) init() {
	m.data.SetName("flink.jobmanager.jvm.memory.non_heap.max")
	m.data.SetDescription("The maximum amount of non-heap memory that can be used for memory management for a jobmanager.")
	m.data.SetUnit("By")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkJobmanagerJvmMemoryNonHeapMax) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkJobmanagerJvmMemoryNonHeapMax) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkJobmanagerJvmMemoryNonHeapMax) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkJobmanagerJvmMemoryNonHeapMax(settings MetricSettings) metricFlinkJobmanagerJvmMemoryNonHeapMax {
	m := metricFlinkJobmanagerJvmMemoryNonHeapMax{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkJobmanagerJvmMemoryNonHeapUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.jobmanager.jvm.memory.non_heap.used metric with initial data.
func (m *metricFlinkJobmanagerJvmMemoryNonHeapUsed) init() {
	m.data.SetName("flink.jobmanager.jvm.memory.non_heap.used")
	m.data.SetDescription("The amount of non-heap memory currently used for a jobmanager.")
	m.data.SetUnit("By")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkJobmanagerJvmMemoryNonHeapUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkJobmanagerJvmMemoryNonHeapUsed) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkJobmanagerJvmMemoryNonHeapUsed) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkJobmanagerJvmMemoryNonHeapUsed(settings MetricSettings) metricFlinkJobmanagerJvmMemoryNonHeapUsed {
	m := metricFlinkJobmanagerJvmMemoryNonHeapUsed{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkJobmanagerJvmThreadsCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.jobmanager.jvm.threads.count metric with initial data.
func (m *metricFlinkJobmanagerJvmThreadsCount) init() {
	m.data.SetName("flink.jobmanager.jvm.threads.count")
	m.data.SetDescription("The total number of live threads for a jobmanager.")
	m.data.SetUnit("{threads}")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkJobmanagerJvmThreadsCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkJobmanagerJvmThreadsCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkJobmanagerJvmThreadsCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkJobmanagerJvmThreadsCount(settings MetricSettings) metricFlinkJobmanagerJvmThreadsCount {
	m := metricFlinkJobmanagerJvmThreadsCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkJobmanagerMemoryManagedTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.jobmanager.memory.managed.total metric with initial data.
func (m *metricFlinkJobmanagerMemoryManagedTotal) init() {
	m.data.SetName("flink.jobmanager.memory.managed.total")
	m.data.SetDescription("The total amount of managed memory for a jobmanager.")
	m.data.SetUnit("By")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkJobmanagerMemoryManagedTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkJobmanagerMemoryManagedTotal) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkJobmanagerMemoryManagedTotal) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkJobmanagerMemoryManagedTotal(settings MetricSettings) metricFlinkJobmanagerMemoryManagedTotal {
	m := metricFlinkJobmanagerMemoryManagedTotal{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkJobmanagerMemoryManagedUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.jobmanager.memory.managed.used metric with initial data.
func (m *metricFlinkJobmanagerMemoryManagedUsed) init() {
	m.data.SetName("flink.jobmanager.memory.managed.used")
	m.data.SetDescription("The amount of managed memory currently used for a jobmanager.")
	m.data.SetUnit("By")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkJobmanagerMemoryManagedUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkJobmanagerMemoryManagedUsed) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkJobmanagerMemoryManagedUsed) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkJobmanagerMemoryManagedUsed(settings MetricSettings) metricFlinkJobmanagerMemoryManagedUsed {
	m := metricFlinkJobmanagerMemoryManagedUsed{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkOperatorRecordCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.operator.record.count metric with initial data.
func (m *metricFlinkOperatorRecordCount) init() {
	m.data.SetName("flink.operator.record.count")
	m.data.SetDescription("The number of records this operator type has.")
	m.data.SetUnit("{records}")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkOperatorRecordCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, operatorNameAttributeValue string, recordAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert("operator_name", pcommon.NewValueString(operatorNameAttributeValue))
	dp.Attributes().Insert("record", pcommon.NewValueString(recordAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkOperatorRecordCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkOperatorRecordCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkOperatorRecordCount(settings MetricSettings) metricFlinkOperatorRecordCount {
	m := metricFlinkOperatorRecordCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkOperatorWatermarkOutput struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.operator.watermark.output metric with initial data.
func (m *metricFlinkOperatorWatermarkOutput) init() {
	m.data.SetName("flink.operator.watermark.output")
	m.data.SetDescription("The last watermark this operator has emitted.")
	m.data.SetUnit("ms")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkOperatorWatermarkOutput) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, operatorNameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert("operator_name", pcommon.NewValueString(operatorNameAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkOperatorWatermarkOutput) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkOperatorWatermarkOutput) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkOperatorWatermarkOutput(settings MetricSettings) metricFlinkOperatorWatermarkOutput {
	m := metricFlinkOperatorWatermarkOutput{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkTaskRecordCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.task.record.count metric with initial data.
func (m *metricFlinkTaskRecordCount) init() {
	m.data.SetName("flink.task.record.count")
	m.data.SetDescription("The number of records this task type has.")
	m.data.SetUnit("{records}")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkTaskRecordCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, recordAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert("record", pcommon.NewValueString(recordAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkTaskRecordCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkTaskRecordCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkTaskRecordCount(settings MetricSettings) metricFlinkTaskRecordCount {
	m := metricFlinkTaskRecordCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkTaskmanagerJvmClassLoaderClassesLoaded struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.taskmanager.jvm.class_loader.classes_loaded metric with initial data.
func (m *metricFlinkTaskmanagerJvmClassLoaderClassesLoaded) init() {
	m.data.SetName("flink.taskmanager.jvm.class_loader.classes_loaded")
	m.data.SetDescription("The total number of classes loaded since the start of the JVM for a taskmanager.")
	m.data.SetUnit("{classes}")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkTaskmanagerJvmClassLoaderClassesLoaded) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkTaskmanagerJvmClassLoaderClassesLoaded) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkTaskmanagerJvmClassLoaderClassesLoaded) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkTaskmanagerJvmClassLoaderClassesLoaded(settings MetricSettings) metricFlinkTaskmanagerJvmClassLoaderClassesLoaded {
	m := metricFlinkTaskmanagerJvmClassLoaderClassesLoaded{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkTaskmanagerJvmCPULoad struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.taskmanager.jvm.cpu.load metric with initial data.
func (m *metricFlinkTaskmanagerJvmCPULoad) init() {
	m.data.SetName("flink.taskmanager.jvm.cpu.load")
	m.data.SetDescription("The recent CPU usage of the JVM for a taskmanager.")
	m.data.SetUnit("1")
	m.data.SetDataType(pmetric.MetricDataTypeGauge)
}

func (m *metricFlinkTaskmanagerJvmCPULoad) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkTaskmanagerJvmCPULoad) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkTaskmanagerJvmCPULoad) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkTaskmanagerJvmCPULoad(settings MetricSettings) metricFlinkTaskmanagerJvmCPULoad {
	m := metricFlinkTaskmanagerJvmCPULoad{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkTaskmanagerJvmCPUTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.taskmanager.jvm.cpu.time metric with initial data.
func (m *metricFlinkTaskmanagerJvmCPUTime) init() {
	m.data.SetName("flink.taskmanager.jvm.cpu.time")
	m.data.SetDescription("The CPU time used by the JVM for a taskmanager.")
	m.data.SetUnit("ns")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkTaskmanagerJvmCPUTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkTaskmanagerJvmCPUTime) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkTaskmanagerJvmCPUTime) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkTaskmanagerJvmCPUTime(settings MetricSettings) metricFlinkTaskmanagerJvmCPUTime {
	m := metricFlinkTaskmanagerJvmCPUTime{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkTaskmanagerJvmGarbageCollectorCollectionCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.taskmanager.jvm.garbage_collector.collection.count metric with initial data.
func (m *metricFlinkTaskmanagerJvmGarbageCollectorCollectionCount) init() {
	m.data.SetName("flink.taskmanager.jvm.garbage_collector.collection.count")
	m.data.SetDescription("The total number of collections that have occurred for a taskmanager.")
	m.data.SetUnit("{collections}")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkTaskmanagerJvmGarbageCollectorCollectionCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, garbageCollectorNameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert("garbage_collector_name", pcommon.NewValueString(garbageCollectorNameAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkTaskmanagerJvmGarbageCollectorCollectionCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkTaskmanagerJvmGarbageCollectorCollectionCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkTaskmanagerJvmGarbageCollectorCollectionCount(settings MetricSettings) metricFlinkTaskmanagerJvmGarbageCollectorCollectionCount {
	m := metricFlinkTaskmanagerJvmGarbageCollectorCollectionCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkTaskmanagerJvmGarbageCollectorCollectionTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.taskmanager.jvm.garbage_collector.collection.time metric with initial data.
func (m *metricFlinkTaskmanagerJvmGarbageCollectorCollectionTime) init() {
	m.data.SetName("flink.taskmanager.jvm.garbage_collector.collection.time")
	m.data.SetDescription("The total time spent performing garbage collection for a taskmanager.")
	m.data.SetUnit("ms")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkTaskmanagerJvmGarbageCollectorCollectionTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, garbageCollectorNameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert("garbage_collector_name", pcommon.NewValueString(garbageCollectorNameAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkTaskmanagerJvmGarbageCollectorCollectionTime) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkTaskmanagerJvmGarbageCollectorCollectionTime) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkTaskmanagerJvmGarbageCollectorCollectionTime(settings MetricSettings) metricFlinkTaskmanagerJvmGarbageCollectorCollectionTime {
	m := metricFlinkTaskmanagerJvmGarbageCollectorCollectionTime{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkTaskmanagerJvmMemoryDirectTotalCapacity struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.taskmanager.jvm.memory.direct.total_capacity metric with initial data.
func (m *metricFlinkTaskmanagerJvmMemoryDirectTotalCapacity) init() {
	m.data.SetName("flink.taskmanager.jvm.memory.direct.total_capacity")
	m.data.SetDescription("The total capacity of all buffers in the direct buffer pool for a taskmanager.")
	m.data.SetUnit("By")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkTaskmanagerJvmMemoryDirectTotalCapacity) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkTaskmanagerJvmMemoryDirectTotalCapacity) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkTaskmanagerJvmMemoryDirectTotalCapacity) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkTaskmanagerJvmMemoryDirectTotalCapacity(settings MetricSettings) metricFlinkTaskmanagerJvmMemoryDirectTotalCapacity {
	m := metricFlinkTaskmanagerJvmMemoryDirectTotalCapacity{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkTaskmanagerJvmMemoryDirectUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.taskmanager.jvm.memory.direct.used metric with initial data.
func (m *metricFlinkTaskmanagerJvmMemoryDirectUsed) init() {
	m.data.SetName("flink.taskmanager.jvm.memory.direct.used")
	m.data.SetDescription("The amount of memory used by the JVM for the direct buffer pool for a taskmanager.")
	m.data.SetUnit("By")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkTaskmanagerJvmMemoryDirectUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkTaskmanagerJvmMemoryDirectUsed) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkTaskmanagerJvmMemoryDirectUsed) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkTaskmanagerJvmMemoryDirectUsed(settings MetricSettings) metricFlinkTaskmanagerJvmMemoryDirectUsed {
	m := metricFlinkTaskmanagerJvmMemoryDirectUsed{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkTaskmanagerJvmMemoryHeapCommitted struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.taskmanager.jvm.memory.heap.committed metric with initial data.
func (m *metricFlinkTaskmanagerJvmMemoryHeapCommitted) init() {
	m.data.SetName("flink.taskmanager.jvm.memory.heap.committed")
	m.data.SetDescription("The amount of heap memory guaranteed to be available to the JVM for a taskmanager.")
	m.data.SetUnit("By")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkTaskmanagerJvmMemoryHeapCommitted) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkTaskmanagerJvmMemoryHeapCommitted) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkTaskmanagerJvmMemoryHeapCommitted) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkTaskmanagerJvmMemoryHeapCommitted(settings MetricSettings) metricFlinkTaskmanagerJvmMemoryHeapCommitted {
	m := metricFlinkTaskmanagerJvmMemoryHeapCommitted{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkTaskmanagerJvmMemoryHeapMax struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.taskmanager.jvm.memory.heap.max metric with initial data.
func (m *metricFlinkTaskmanagerJvmMemoryHeapMax) init() {
	m.data.SetName("flink.taskmanager.jvm.memory.heap.max")
	m.data.SetDescription("The maximum amount of heap memory that can be used for memory management for a taskmanager.")
	m.data.SetUnit("By")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkTaskmanagerJvmMemoryHeapMax) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkTaskmanagerJvmMemoryHeapMax) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkTaskmanagerJvmMemoryHeapMax) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkTaskmanagerJvmMemoryHeapMax(settings MetricSettings) metricFlinkTaskmanagerJvmMemoryHeapMax {
	m := metricFlinkTaskmanagerJvmMemoryHeapMax{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkTaskmanagerJvmMemoryHeapUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.taskmanager.jvm.memory.heap.used metric with initial data.
func (m *metricFlinkTaskmanagerJvmMemoryHeapUsed) init() {
	m.data.SetName("flink.taskmanager.jvm.memory.heap.used")
	m.data.SetDescription("The amount of heap memory currently used for a taskmanager.")
	m.data.SetUnit("By")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkTaskmanagerJvmMemoryHeapUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkTaskmanagerJvmMemoryHeapUsed) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkTaskmanagerJvmMemoryHeapUsed) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkTaskmanagerJvmMemoryHeapUsed(settings MetricSettings) metricFlinkTaskmanagerJvmMemoryHeapUsed {
	m := metricFlinkTaskmanagerJvmMemoryHeapUsed{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkTaskmanagerJvmMemoryMappedTotalCapacity struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.taskmanager.jvm.memory.mapped.total_capacity metric with initial data.
func (m *metricFlinkTaskmanagerJvmMemoryMappedTotalCapacity) init() {
	m.data.SetName("flink.taskmanager.jvm.memory.mapped.total_capacity")
	m.data.SetDescription("The number of buffers in the mapped buffer pool for a taskmanager.")
	m.data.SetUnit("By")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkTaskmanagerJvmMemoryMappedTotalCapacity) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkTaskmanagerJvmMemoryMappedTotalCapacity) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkTaskmanagerJvmMemoryMappedTotalCapacity) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkTaskmanagerJvmMemoryMappedTotalCapacity(settings MetricSettings) metricFlinkTaskmanagerJvmMemoryMappedTotalCapacity {
	m := metricFlinkTaskmanagerJvmMemoryMappedTotalCapacity{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkTaskmanagerJvmMemoryMappedUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.taskmanager.jvm.memory.mapped.used metric with initial data.
func (m *metricFlinkTaskmanagerJvmMemoryMappedUsed) init() {
	m.data.SetName("flink.taskmanager.jvm.memory.mapped.used")
	m.data.SetDescription("The amount of memory used by the JVM for the mapped buffer pool for a taskmanager.")
	m.data.SetUnit("By")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkTaskmanagerJvmMemoryMappedUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkTaskmanagerJvmMemoryMappedUsed) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkTaskmanagerJvmMemoryMappedUsed) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkTaskmanagerJvmMemoryMappedUsed(settings MetricSettings) metricFlinkTaskmanagerJvmMemoryMappedUsed {
	m := metricFlinkTaskmanagerJvmMemoryMappedUsed{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkTaskmanagerJvmMemoryMetaspaceCommitted struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.taskmanager.jvm.memory.metaspace.committed metric with initial data.
func (m *metricFlinkTaskmanagerJvmMemoryMetaspaceCommitted) init() {
	m.data.SetName("flink.taskmanager.jvm.memory.metaspace.committed")
	m.data.SetDescription("The amount of memory guaranteed to be available to the JVM in the Metaspace memory pool for a taskmanager.")
	m.data.SetUnit("By")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkTaskmanagerJvmMemoryMetaspaceCommitted) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkTaskmanagerJvmMemoryMetaspaceCommitted) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkTaskmanagerJvmMemoryMetaspaceCommitted) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkTaskmanagerJvmMemoryMetaspaceCommitted(settings MetricSettings) metricFlinkTaskmanagerJvmMemoryMetaspaceCommitted {
	m := metricFlinkTaskmanagerJvmMemoryMetaspaceCommitted{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkTaskmanagerJvmMemoryMetaspaceMax struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.taskmanager.jvm.memory.metaspace.max metric with initial data.
func (m *metricFlinkTaskmanagerJvmMemoryMetaspaceMax) init() {
	m.data.SetName("flink.taskmanager.jvm.memory.metaspace.max")
	m.data.SetDescription("The maximum amount of memory that can be used in the Metaspace memory pool for a taskmanager.")
	m.data.SetUnit("By")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkTaskmanagerJvmMemoryMetaspaceMax) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkTaskmanagerJvmMemoryMetaspaceMax) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkTaskmanagerJvmMemoryMetaspaceMax) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkTaskmanagerJvmMemoryMetaspaceMax(settings MetricSettings) metricFlinkTaskmanagerJvmMemoryMetaspaceMax {
	m := metricFlinkTaskmanagerJvmMemoryMetaspaceMax{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkTaskmanagerJvmMemoryMetaspaceUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.taskmanager.jvm.memory.metaspace.used metric with initial data.
func (m *metricFlinkTaskmanagerJvmMemoryMetaspaceUsed) init() {
	m.data.SetName("flink.taskmanager.jvm.memory.metaspace.used")
	m.data.SetDescription("The amount of memory currently used in the Metaspace memory pool for a taskmanager.")
	m.data.SetUnit("By")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkTaskmanagerJvmMemoryMetaspaceUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkTaskmanagerJvmMemoryMetaspaceUsed) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkTaskmanagerJvmMemoryMetaspaceUsed) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkTaskmanagerJvmMemoryMetaspaceUsed(settings MetricSettings) metricFlinkTaskmanagerJvmMemoryMetaspaceUsed {
	m := metricFlinkTaskmanagerJvmMemoryMetaspaceUsed{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkTaskmanagerJvmMemoryNonHeapCommitted struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.taskmanager.jvm.memory.non_heap.committed metric with initial data.
func (m *metricFlinkTaskmanagerJvmMemoryNonHeapCommitted) init() {
	m.data.SetName("flink.taskmanager.jvm.memory.non_heap.committed")
	m.data.SetDescription("The amount of non-heap memory guaranteed to be available to the JVM for a taskmanager.")
	m.data.SetUnit("By")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkTaskmanagerJvmMemoryNonHeapCommitted) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkTaskmanagerJvmMemoryNonHeapCommitted) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkTaskmanagerJvmMemoryNonHeapCommitted) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkTaskmanagerJvmMemoryNonHeapCommitted(settings MetricSettings) metricFlinkTaskmanagerJvmMemoryNonHeapCommitted {
	m := metricFlinkTaskmanagerJvmMemoryNonHeapCommitted{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkTaskmanagerJvmMemoryNonHeapMax struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.taskmanager.jvm.memory.non_heap.max metric with initial data.
func (m *metricFlinkTaskmanagerJvmMemoryNonHeapMax) init() {
	m.data.SetName("flink.taskmanager.jvm.memory.non_heap.max")
	m.data.SetDescription("The maximum amount of non-heap memory that can be used for memory management for a taskmanager.")
	m.data.SetUnit("By")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkTaskmanagerJvmMemoryNonHeapMax) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkTaskmanagerJvmMemoryNonHeapMax) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkTaskmanagerJvmMemoryNonHeapMax) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkTaskmanagerJvmMemoryNonHeapMax(settings MetricSettings) metricFlinkTaskmanagerJvmMemoryNonHeapMax {
	m := metricFlinkTaskmanagerJvmMemoryNonHeapMax{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkTaskmanagerJvmMemoryNonHeapUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.taskmanager.jvm.memory.non_heap.used metric with initial data.
func (m *metricFlinkTaskmanagerJvmMemoryNonHeapUsed) init() {
	m.data.SetName("flink.taskmanager.jvm.memory.non_heap.used")
	m.data.SetDescription("The amount of non-heap memory currently used for a taskmanager.")
	m.data.SetUnit("By")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkTaskmanagerJvmMemoryNonHeapUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkTaskmanagerJvmMemoryNonHeapUsed) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkTaskmanagerJvmMemoryNonHeapUsed) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkTaskmanagerJvmMemoryNonHeapUsed(settings MetricSettings) metricFlinkTaskmanagerJvmMemoryNonHeapUsed {
	m := metricFlinkTaskmanagerJvmMemoryNonHeapUsed{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkTaskmanagerJvmThreadsCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.taskmanager.jvm.threads.count metric with initial data.
func (m *metricFlinkTaskmanagerJvmThreadsCount) init() {
	m.data.SetName("flink.taskmanager.jvm.threads.count")
	m.data.SetDescription("The total number of live threads for a taskmanager.")
	m.data.SetUnit("{threads}")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkTaskmanagerJvmThreadsCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkTaskmanagerJvmThreadsCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkTaskmanagerJvmThreadsCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkTaskmanagerJvmThreadsCount(settings MetricSettings) metricFlinkTaskmanagerJvmThreadsCount {
	m := metricFlinkTaskmanagerJvmThreadsCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkTaskmanagerMemoryManagedTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.taskmanager.memory.managed.total metric with initial data.
func (m *metricFlinkTaskmanagerMemoryManagedTotal) init() {
	m.data.SetName("flink.taskmanager.memory.managed.total")
	m.data.SetDescription("The total amount of managed memory for a taskmanager.")
	m.data.SetUnit("By")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkTaskmanagerMemoryManagedTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkTaskmanagerMemoryManagedTotal) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkTaskmanagerMemoryManagedTotal) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkTaskmanagerMemoryManagedTotal(settings MetricSettings) metricFlinkTaskmanagerMemoryManagedTotal {
	m := metricFlinkTaskmanagerMemoryManagedTotal{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkTaskmanagerMemoryManagedUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.taskmanager.memory.managed.used metric with initial data.
func (m *metricFlinkTaskmanagerMemoryManagedUsed) init() {
	m.data.SetName("flink.taskmanager.memory.managed.used")
	m.data.SetDescription("The amount of managed memory currently used for a taskmanager.")
	m.data.SetUnit("By")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricFlinkTaskmanagerMemoryManagedUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkTaskmanagerMemoryManagedUsed) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkTaskmanagerMemoryManagedUsed) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkTaskmanagerMemoryManagedUsed(settings MetricSettings) metricFlinkTaskmanagerMemoryManagedUsed {
	m := metricFlinkTaskmanagerMemoryManagedUsed{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

// MetricsBuilder provides an interface for scrapers to report metrics while taking care of all the transformations
// required to produce metric representation defined in metadata and user settings.
type MetricsBuilder struct {
	startTime                                                pcommon.Timestamp   // start time that will be applied to all recorded data points.
	metricsCapacity                                          int                 // maximum observed number of metrics per resource.
	resourceCapacity                                         int                 // maximum observed number of resource attributes.
	metricsBuffer                                            pmetric.Metrics     // accumulates metrics data before emitting.
	buildInfo                                                component.BuildInfo // contains version information
	metricFlinkJobCheckpointsCount                           metricFlinkJobCheckpointsCount
	metricFlinkJobLastCheckpointSize                         metricFlinkJobLastCheckpointSize
	metricFlinkJobLastCheckpointTime                         metricFlinkJobLastCheckpointTime
	metricFlinkJobRestartCount                               metricFlinkJobRestartCount
	metricFlinkJobmanagerJvmClassLoaderClassesLoaded         metricFlinkJobmanagerJvmClassLoaderClassesLoaded
	metricFlinkJobmanagerJvmCPULoad                          metricFlinkJobmanagerJvmCPULoad
	metricFlinkJobmanagerJvmCPUTime                          metricFlinkJobmanagerJvmCPUTime
	metricFlinkJobmanagerJvmGarbageCollectorCollectionCount  metricFlinkJobmanagerJvmGarbageCollectorCollectionCount
	metricFlinkJobmanagerJvmGarbageCollectorCollectionTime   metricFlinkJobmanagerJvmGarbageCollectorCollectionTime
	metricFlinkJobmanagerJvmMemoryDirectTotalCapacity        metricFlinkJobmanagerJvmMemoryDirectTotalCapacity
	metricFlinkJobmanagerJvmMemoryDirectUsed                 metricFlinkJobmanagerJvmMemoryDirectUsed
	metricFlinkJobmanagerJvmMemoryHeapCommitted              metricFlinkJobmanagerJvmMemoryHeapCommitted
	metricFlinkJobmanagerJvmMemoryHeapMax                    metricFlinkJobmanagerJvmMemoryHeapMax
	metricFlinkJobmanagerJvmMemoryHeapUsed                   metricFlinkJobmanagerJvmMemoryHeapUsed
	metricFlinkJobmanagerJvmMemoryMappedTotalCapacity        metricFlinkJobmanagerJvmMemoryMappedTotalCapacity
	metricFlinkJobmanagerJvmMemoryMappedUsed                 metricFlinkJobmanagerJvmMemoryMappedUsed
	metricFlinkJobmanagerJvmMemoryMetaspaceCommitted         metricFlinkJobmanagerJvmMemoryMetaspaceCommitted
	metricFlinkJobmanagerJvmMemoryMetaspaceMax               metricFlinkJobmanagerJvmMemoryMetaspaceMax
	metricFlinkJobmanagerJvmMemoryMetaspaceUsed              metricFlinkJobmanagerJvmMemoryMetaspaceUsed
	metricFlinkJobmanagerJvmMemoryNonHeapCommitted           metricFlinkJobmanagerJvmMemoryNonHeapCommitted
	metricFlinkJobmanagerJvmMemoryNonHeapMax                 metricFlinkJobmanagerJvmMemoryNonHeapMax
	metricFlinkJobmanagerJvmMemoryNonHeapUsed                metricFlinkJobmanagerJvmMemoryNonHeapUsed
	metricFlinkJobmanagerJvmThreadsCount                     metricFlinkJobmanagerJvmThreadsCount
	metricFlinkJobmanagerMemoryManagedTotal                  metricFlinkJobmanagerMemoryManagedTotal
	metricFlinkJobmanagerMemoryManagedUsed                   metricFlinkJobmanagerMemoryManagedUsed
	metricFlinkOperatorRecordCount                           metricFlinkOperatorRecordCount
	metricFlinkOperatorWatermarkOutput                       metricFlinkOperatorWatermarkOutput
	metricFlinkTaskRecordCount                               metricFlinkTaskRecordCount
	metricFlinkTaskmanagerJvmClassLoaderClassesLoaded        metricFlinkTaskmanagerJvmClassLoaderClassesLoaded
	metricFlinkTaskmanagerJvmCPULoad                         metricFlinkTaskmanagerJvmCPULoad
	metricFlinkTaskmanagerJvmCPUTime                         metricFlinkTaskmanagerJvmCPUTime
	metricFlinkTaskmanagerJvmGarbageCollectorCollectionCount metricFlinkTaskmanagerJvmGarbageCollectorCollectionCount
	metricFlinkTaskmanagerJvmGarbageCollectorCollectionTime  metricFlinkTaskmanagerJvmGarbageCollectorCollectionTime
	metricFlinkTaskmanagerJvmMemoryDirectTotalCapacity       metricFlinkTaskmanagerJvmMemoryDirectTotalCapacity
	metricFlinkTaskmanagerJvmMemoryDirectUsed                metricFlinkTaskmanagerJvmMemoryDirectUsed
	metricFlinkTaskmanagerJvmMemoryHeapCommitted             metricFlinkTaskmanagerJvmMemoryHeapCommitted
	metricFlinkTaskmanagerJvmMemoryHeapMax                   metricFlinkTaskmanagerJvmMemoryHeapMax
	metricFlinkTaskmanagerJvmMemoryHeapUsed                  metricFlinkTaskmanagerJvmMemoryHeapUsed
	metricFlinkTaskmanagerJvmMemoryMappedTotalCapacity       metricFlinkTaskmanagerJvmMemoryMappedTotalCapacity
	metricFlinkTaskmanagerJvmMemoryMappedUsed                metricFlinkTaskmanagerJvmMemoryMappedUsed
	metricFlinkTaskmanagerJvmMemoryMetaspaceCommitted        metricFlinkTaskmanagerJvmMemoryMetaspaceCommitted
	metricFlinkTaskmanagerJvmMemoryMetaspaceMax              metricFlinkTaskmanagerJvmMemoryMetaspaceMax
	metricFlinkTaskmanagerJvmMemoryMetaspaceUsed             metricFlinkTaskmanagerJvmMemoryMetaspaceUsed
	metricFlinkTaskmanagerJvmMemoryNonHeapCommitted          metricFlinkTaskmanagerJvmMemoryNonHeapCommitted
	metricFlinkTaskmanagerJvmMemoryNonHeapMax                metricFlinkTaskmanagerJvmMemoryNonHeapMax
	metricFlinkTaskmanagerJvmMemoryNonHeapUsed               metricFlinkTaskmanagerJvmMemoryNonHeapUsed
	metricFlinkTaskmanagerJvmThreadsCount                    metricFlinkTaskmanagerJvmThreadsCount
	metricFlinkTaskmanagerMemoryManagedTotal                 metricFlinkTaskmanagerMemoryManagedTotal
	metricFlinkTaskmanagerMemoryManagedUsed                  metricFlinkTaskmanagerMemoryManagedUsed
}

// metricBuilderOption applies changes to default metrics builder.
type metricBuilderOption func(*MetricsBuilder)

// WithStartTime sets startTime on the metrics builder.
func WithStartTime(startTime pcommon.Timestamp) metricBuilderOption {
	return func(mb *MetricsBuilder) {
		mb.startTime = startTime
	}
}

func NewMetricsBuilder(settings MetricsSettings, buildInfo component.BuildInfo, options ...metricBuilderOption) *MetricsBuilder {
	mb := &MetricsBuilder{
		startTime:                        pcommon.NewTimestampFromTime(time.Now()),
		metricsBuffer:                    pmetric.NewMetrics(),
		buildInfo:                        buildInfo,
		metricFlinkJobCheckpointsCount:   newMetricFlinkJobCheckpointsCount(settings.FlinkJobCheckpointsCount),
		metricFlinkJobLastCheckpointSize: newMetricFlinkJobLastCheckpointSize(settings.FlinkJobLastCheckpointSize),
		metricFlinkJobLastCheckpointTime: newMetricFlinkJobLastCheckpointTime(settings.FlinkJobLastCheckpointTime),
		metricFlinkJobRestartCount:       newMetricFlinkJobRestartCount(settings.FlinkJobRestartCount),
		metricFlinkJobmanagerJvmClassLoaderClassesLoaded:         newMetricFlinkJobmanagerJvmClassLoaderClassesLoaded(settings.FlinkJobmanagerJvmClassLoaderClassesLoaded),
		metricFlinkJobmanagerJvmCPULoad:                          newMetricFlinkJobmanagerJvmCPULoad(settings.FlinkJobmanagerJvmCPULoad),
		metricFlinkJobmanagerJvmCPUTime:                          newMetricFlinkJobmanagerJvmCPUTime(settings.FlinkJobmanagerJvmCPUTime),
		metricFlinkJobmanagerJvmGarbageCollectorCollectionCount:  newMetricFlinkJobmanagerJvmGarbageCollectorCollectionCount(settings.FlinkJobmanagerJvmGarbageCollectorCollectionCount),
		metricFlinkJobmanagerJvmGarbageCollectorCollectionTime:   newMetricFlinkJobmanagerJvmGarbageCollectorCollectionTime(settings.FlinkJobmanagerJvmGarbageCollectorCollectionTime),
		metricFlinkJobmanagerJvmMemoryDirectTotalCapacity:        newMetricFlinkJobmanagerJvmMemoryDirectTotalCapacity(settings.FlinkJobmanagerJvmMemoryDirectTotalCapacity),
		metricFlinkJobmanagerJvmMemoryDirectUsed:                 newMetricFlinkJobmanagerJvmMemoryDirectUsed(settings.FlinkJobmanagerJvmMemoryDirectUsed),
		metricFlinkJobmanagerJvmMemoryHeapCommitted:              newMetricFlinkJobmanagerJvmMemoryHeapCommitted(settings.FlinkJobmanagerJvmMemoryHeapCommitted),
		metricFlinkJobmanagerJvmMemoryHeapMax:                    newMetricFlinkJobmanagerJvmMemoryHeapMax(settings.FlinkJobmanagerJvmMemoryHeapMax),
		metricFlinkJobmanagerJvmMemoryHeapUsed:                   newMetricFlinkJobmanagerJvmMemoryHeapUsed(settings.FlinkJobmanagerJvmMemoryHeapUsed),
		metricFlinkJobmanagerJvmMemoryMappedTotalCapacity:        newMetricFlinkJobmanagerJvmMemoryMappedTotalCapacity(settings.FlinkJobmanagerJvmMemoryMappedTotalCapacity),
		metricFlinkJobmanagerJvmMemoryMappedUsed:                 newMetricFlinkJobmanagerJvmMemoryMappedUsed(settings.FlinkJobmanagerJvmMemoryMappedUsed),
		metricFlinkJobmanagerJvmMemoryMetaspaceCommitted:         newMetricFlinkJobmanagerJvmMemoryMetaspaceCommitted(settings.FlinkJobmanagerJvmMemoryMetaspaceCommitted),
		metricFlinkJobmanagerJvmMemoryMetaspaceMax:               newMetricFlinkJobmanagerJvmMemoryMetaspaceMax(settings.FlinkJobmanagerJvmMemoryMetaspaceMax),
		metricFlinkJobmanagerJvmMemoryMetaspaceUsed:              newMetricFlinkJobmanagerJvmMemoryMetaspaceUsed(settings.FlinkJobmanagerJvmMemoryMetaspaceUsed),
		metricFlinkJobmanagerJvmMemoryNonHeapCommitted:           newMetricFlinkJobmanagerJvmMemoryNonHeapCommitted(settings.FlinkJobmanagerJvmMemoryNonHeapCommitted),
		metricFlinkJobmanagerJvmMemoryNonHeapMax:                 newMetricFlinkJobmanagerJvmMemoryNonHeapMax(settings.FlinkJobmanagerJvmMemoryNonHeapMax),
		metricFlinkJobmanagerJvmMemoryNonHeapUsed:                newMetricFlinkJobmanagerJvmMemoryNonHeapUsed(settings.FlinkJobmanagerJvmMemoryNonHeapUsed),
		metricFlinkJobmanagerJvmThreadsCount:                     newMetricFlinkJobmanagerJvmThreadsCount(settings.FlinkJobmanagerJvmThreadsCount),
		metricFlinkJobmanagerMemoryManagedTotal:                  newMetricFlinkJobmanagerMemoryManagedTotal(settings.FlinkJobmanagerMemoryManagedTotal),
		metricFlinkJobmanagerMemoryManagedUsed:                   newMetricFlinkJobmanagerMemoryManagedUsed(settings.FlinkJobmanagerMemoryManagedUsed),
		metricFlinkOperatorRecordCount:                           newMetricFlinkOperatorRecordCount(settings.FlinkOperatorRecordCount),
		metricFlinkOperatorWatermarkOutput:                       newMetricFlinkOperatorWatermarkOutput(settings.FlinkOperatorWatermarkOutput),
		metricFlinkTaskRecordCount:                               newMetricFlinkTaskRecordCount(settings.FlinkTaskRecordCount),
		metricFlinkTaskmanagerJvmClassLoaderClassesLoaded:        newMetricFlinkTaskmanagerJvmClassLoaderClassesLoaded(settings.FlinkTaskmanagerJvmClassLoaderClassesLoaded),
		metricFlinkTaskmanagerJvmCPULoad:                         newMetricFlinkTaskmanagerJvmCPULoad(settings.FlinkTaskmanagerJvmCPULoad),
		metricFlinkTaskmanagerJvmCPUTime:                         newMetricFlinkTaskmanagerJvmCPUTime(settings.FlinkTaskmanagerJvmCPUTime),
		metricFlinkTaskmanagerJvmGarbageCollectorCollectionCount: newMetricFlinkTaskmanagerJvmGarbageCollectorCollectionCount(settings.FlinkTaskmanagerJvmGarbageCollectorCollectionCount),
		metricFlinkTaskmanagerJvmGarbageCollectorCollectionTime:  newMetricFlinkTaskmanagerJvmGarbageCollectorCollectionTime(settings.FlinkTaskmanagerJvmGarbageCollectorCollectionTime),
		metricFlinkTaskmanagerJvmMemoryDirectTotalCapacity:       newMetricFlinkTaskmanagerJvmMemoryDirectTotalCapacity(settings.FlinkTaskmanagerJvmMemoryDirectTotalCapacity),
		metricFlinkTaskmanagerJvmMemoryDirectUsed:                newMetricFlinkTaskmanagerJvmMemoryDirectUsed(settings.FlinkTaskmanagerJvmMemoryDirectUsed),
		metricFlinkTaskmanagerJvmMemoryHeapCommitted:             newMetricFlinkTaskmanagerJvmMemoryHeapCommitted(settings.FlinkTaskmanagerJvmMemoryHeapCommitted),
		metricFlinkTaskmanagerJvmMemoryHeapMax:                   newMetricFlinkTaskmanagerJvmMemoryHeapMax(settings.FlinkTaskmanagerJvmMemoryHeapMax),
		metricFlinkTaskmanagerJvmMemoryHeapUsed:                  newMetricFlinkTaskmanagerJvmMemoryHeapUsed(settings.FlinkTaskmanagerJvmMemoryHeapUsed),
		metricFlinkTaskmanagerJvmMemoryMappedTotalCapacity:       newMetricFlinkTaskmanagerJvmMemoryMappedTotalCapacity(settings.FlinkTaskmanagerJvmMemoryMappedTotalCapacity),
		metricFlinkTaskmanagerJvmMemoryMappedUsed:                newMetricFlinkTaskmanagerJvmMemoryMappedUsed(settings.FlinkTaskmanagerJvmMemoryMappedUsed),
		metricFlinkTaskmanagerJvmMemoryMetaspaceCommitted:        newMetricFlinkTaskmanagerJvmMemoryMetaspaceCommitted(settings.FlinkTaskmanagerJvmMemoryMetaspaceCommitted),
		metricFlinkTaskmanagerJvmMemoryMetaspaceMax:              newMetricFlinkTaskmanagerJvmMemoryMetaspaceMax(settings.FlinkTaskmanagerJvmMemoryMetaspaceMax),
		metricFlinkTaskmanagerJvmMemoryMetaspaceUsed:             newMetricFlinkTaskmanagerJvmMemoryMetaspaceUsed(settings.FlinkTaskmanagerJvmMemoryMetaspaceUsed),
		metricFlinkTaskmanagerJvmMemoryNonHeapCommitted:          newMetricFlinkTaskmanagerJvmMemoryNonHeapCommitted(settings.FlinkTaskmanagerJvmMemoryNonHeapCommitted),
		metricFlinkTaskmanagerJvmMemoryNonHeapMax:                newMetricFlinkTaskmanagerJvmMemoryNonHeapMax(settings.FlinkTaskmanagerJvmMemoryNonHeapMax),
		metricFlinkTaskmanagerJvmMemoryNonHeapUsed:               newMetricFlinkTaskmanagerJvmMemoryNonHeapUsed(settings.FlinkTaskmanagerJvmMemoryNonHeapUsed),
		metricFlinkTaskmanagerJvmThreadsCount:                    newMetricFlinkTaskmanagerJvmThreadsCount(settings.FlinkTaskmanagerJvmThreadsCount),
		metricFlinkTaskmanagerMemoryManagedTotal:                 newMetricFlinkTaskmanagerMemoryManagedTotal(settings.FlinkTaskmanagerMemoryManagedTotal),
		metricFlinkTaskmanagerMemoryManagedUsed:                  newMetricFlinkTaskmanagerMemoryManagedUsed(settings.FlinkTaskmanagerMemoryManagedUsed),
	}
	for _, op := range options {
		op(mb)
	}
	return mb
}

// updateCapacity updates max length of metrics and resource attributes that will be used for the slice capacity.
func (mb *MetricsBuilder) updateCapacity(rm pmetric.ResourceMetrics) {
	if mb.metricsCapacity < rm.ScopeMetrics().At(0).Metrics().Len() {
		mb.metricsCapacity = rm.ScopeMetrics().At(0).Metrics().Len()
	}
	if mb.resourceCapacity < rm.Resource().Attributes().Len() {
		mb.resourceCapacity = rm.Resource().Attributes().Len()
	}
}

// ResourceMetricsOption applies changes to provided resource metrics.
type ResourceMetricsOption func(pmetric.ResourceMetrics)

// WithFlinkJobName sets provided value as "flink.job.name" attribute for current resource.
func WithFlinkJobName(val string) ResourceMetricsOption {
	return func(rm pmetric.ResourceMetrics) {
		rm.Resource().Attributes().UpsertString("flink.job.name", val)
	}
}

// WithFlinkSubtaskIndex sets provided value as "flink.subtask.index" attribute for current resource.
func WithFlinkSubtaskIndex(val string) ResourceMetricsOption {
	return func(rm pmetric.ResourceMetrics) {
		rm.Resource().Attributes().UpsertString("flink.subtask.index", val)
	}
}

// WithFlinkTaskName sets provided value as "flink.task.name" attribute for current resource.
func WithFlinkTaskName(val string) ResourceMetricsOption {
	return func(rm pmetric.ResourceMetrics) {
		rm.Resource().Attributes().UpsertString("flink.task.name", val)
	}
}

// WithFlinkTaskmanagerID sets provided value as "flink.taskmanager.id" attribute for current resource.
func WithFlinkTaskmanagerID(val string) ResourceMetricsOption {
	return func(rm pmetric.ResourceMetrics) {
		rm.Resource().Attributes().UpsertString("flink.taskmanager.id", val)
	}
}

// WithHostName sets provided value as "host.name" attribute for current resource.
func WithHostName(val string) ResourceMetricsOption {
	return func(rm pmetric.ResourceMetrics) {
		rm.Resource().Attributes().UpsertString("host.name", val)
	}
}

// WithStartTimeOverride overrides start time for all the resource metrics data points.
// This option should be only used if different start time has to be set on metrics coming from different resources.
func WithStartTimeOverride(start pcommon.Timestamp) ResourceMetricsOption {
	return func(rm pmetric.ResourceMetrics) {
		var dps pmetric.NumberDataPointSlice
		metrics := rm.ScopeMetrics().At(0).Metrics()
		for i := 0; i < metrics.Len(); i++ {
			switch metrics.At(i).DataType() {
			case pmetric.MetricDataTypeGauge:
				dps = metrics.At(i).Gauge().DataPoints()
			case pmetric.MetricDataTypeSum:
				dps = metrics.At(i).Sum().DataPoints()
			}
			for j := 0; j < dps.Len(); j++ {
				dps.At(j).SetStartTimestamp(start)
			}
		}
	}
}

// EmitForResource saves all the generated metrics under a new resource and updates the internal state to be ready for
// recording another set of data points as part of another resource. This function can be helpful when one scraper
// needs to emit metrics from several resources. Otherwise calling this function is not required,
// just `Emit` function can be called instead.
// Resource attributes should be provided as ResourceMetricsOption arguments.
func (mb *MetricsBuilder) EmitForResource(rmo ...ResourceMetricsOption) {
	rm := pmetric.NewResourceMetrics()
	rm.Resource().Attributes().EnsureCapacity(mb.resourceCapacity)
	ils := rm.ScopeMetrics().AppendEmpty()
	ils.Scope().SetName("otelcol/flinkmetricsreceiver")
	ils.Scope().SetVersion(mb.buildInfo.Version)
	ils.Metrics().EnsureCapacity(mb.metricsCapacity)
	mb.metricFlinkJobCheckpointsCount.emit(ils.Metrics())
	mb.metricFlinkJobLastCheckpointSize.emit(ils.Metrics())
	mb.metricFlinkJobLastCheckpointTime.emit(ils.Metrics())
	mb.metricFlinkJobRestartCount.emit(ils.Metrics())
	mb.metricFlinkJobmanagerJvmClassLoaderClassesLoaded.emit(ils.Metrics())
	mb.metricFlinkJobmanagerJvmCPULoad.emit(ils.Metrics())
	mb.metricFlinkJobmanagerJvmCPUTime.emit(ils.Metrics())
	mb.metricFlinkJobmanagerJvmGarbageCollectorCollectionCount.emit(ils.Metrics())
	mb.metricFlinkJobmanagerJvmGarbageCollectorCollectionTime.emit(ils.Metrics())
	mb.metricFlinkJobmanagerJvmMemoryDirectTotalCapacity.emit(ils.Metrics())
	mb.metricFlinkJobmanagerJvmMemoryDirectUsed.emit(ils.Metrics())
	mb.metricFlinkJobmanagerJvmMemoryHeapCommitted.emit(ils.Metrics())
	mb.metricFlinkJobmanagerJvmMemoryHeapMax.emit(ils.Metrics())
	mb.metricFlinkJobmanagerJvmMemoryHeapUsed.emit(ils.Metrics())
	mb.metricFlinkJobmanagerJvmMemoryMappedTotalCapacity.emit(ils.Metrics())
	mb.metricFlinkJobmanagerJvmMemoryMappedUsed.emit(ils.Metrics())
	mb.metricFlinkJobmanagerJvmMemoryMetaspaceCommitted.emit(ils.Metrics())
	mb.metricFlinkJobmanagerJvmMemoryMetaspaceMax.emit(ils.Metrics())
	mb.metricFlinkJobmanagerJvmMemoryMetaspaceUsed.emit(ils.Metrics())
	mb.metricFlinkJobmanagerJvmMemoryNonHeapCommitted.emit(ils.Metrics())
	mb.metricFlinkJobmanagerJvmMemoryNonHeapMax.emit(ils.Metrics())
	mb.metricFlinkJobmanagerJvmMemoryNonHeapUsed.emit(ils.Metrics())
	mb.metricFlinkJobmanagerJvmThreadsCount.emit(ils.Metrics())
	mb.metricFlinkJobmanagerMemoryManagedTotal.emit(ils.Metrics())
	mb.metricFlinkJobmanagerMemoryManagedUsed.emit(ils.Metrics())
	mb.metricFlinkOperatorRecordCount.emit(ils.Metrics())
	mb.metricFlinkOperatorWatermarkOutput.emit(ils.Metrics())
	mb.metricFlinkTaskRecordCount.emit(ils.Metrics())
	mb.metricFlinkTaskmanagerJvmClassLoaderClassesLoaded.emit(ils.Metrics())
	mb.metricFlinkTaskmanagerJvmCPULoad.emit(ils.Metrics())
	mb.metricFlinkTaskmanagerJvmCPUTime.emit(ils.Metrics())
	mb.metricFlinkTaskmanagerJvmGarbageCollectorCollectionCount.emit(ils.Metrics())
	mb.metricFlinkTaskmanagerJvmGarbageCollectorCollectionTime.emit(ils.Metrics())
	mb.metricFlinkTaskmanagerJvmMemoryDirectTotalCapacity.emit(ils.Metrics())
	mb.metricFlinkTaskmanagerJvmMemoryDirectUsed.emit(ils.Metrics())
	mb.metricFlinkTaskmanagerJvmMemoryHeapCommitted.emit(ils.Metrics())
	mb.metricFlinkTaskmanagerJvmMemoryHeapMax.emit(ils.Metrics())
	mb.metricFlinkTaskmanagerJvmMemoryHeapUsed.emit(ils.Metrics())
	mb.metricFlinkTaskmanagerJvmMemoryMappedTotalCapacity.emit(ils.Metrics())
	mb.metricFlinkTaskmanagerJvmMemoryMappedUsed.emit(ils.Metrics())
	mb.metricFlinkTaskmanagerJvmMemoryMetaspaceCommitted.emit(ils.Metrics())
	mb.metricFlinkTaskmanagerJvmMemoryMetaspaceMax.emit(ils.Metrics())
	mb.metricFlinkTaskmanagerJvmMemoryMetaspaceUsed.emit(ils.Metrics())
	mb.metricFlinkTaskmanagerJvmMemoryNonHeapCommitted.emit(ils.Metrics())
	mb.metricFlinkTaskmanagerJvmMemoryNonHeapMax.emit(ils.Metrics())
	mb.metricFlinkTaskmanagerJvmMemoryNonHeapUsed.emit(ils.Metrics())
	mb.metricFlinkTaskmanagerJvmThreadsCount.emit(ils.Metrics())
	mb.metricFlinkTaskmanagerMemoryManagedTotal.emit(ils.Metrics())
	mb.metricFlinkTaskmanagerMemoryManagedUsed.emit(ils.Metrics())
	for _, op := range rmo {
		op(rm)
	}
	if ils.Metrics().Len() > 0 {
		mb.updateCapacity(rm)
		rm.MoveTo(mb.metricsBuffer.ResourceMetrics().AppendEmpty())
	}
}

// Emit returns all the metrics accumulated by the metrics builder and updates the internal state to be ready for
// recording another set of metrics. This function will be responsible for applying all the transformations required to
// produce metric representation defined in metadata and user settings, e.g. delta or cumulative.
func (mb *MetricsBuilder) Emit(rmo ...ResourceMetricsOption) pmetric.Metrics {
	mb.EmitForResource(rmo...)
	metrics := pmetric.NewMetrics()
	mb.metricsBuffer.MoveTo(metrics)
	return metrics
}

// RecordFlinkJobCheckpointsCountDataPoint adds a data point to flink.job.checkpoints.count metric.
func (mb *MetricsBuilder) RecordFlinkJobCheckpointsCountDataPoint(ts pcommon.Timestamp, inputVal string, checkpointAttributeValue AttributeCheckpoint) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkJobCheckpointsCount, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkJobCheckpointsCount.recordDataPoint(mb.startTime, ts, val, checkpointAttributeValue.String())
	return nil
}

// RecordFlinkJobLastCheckpointSizeDataPoint adds a data point to flink.job.last_checkpoint.size metric.
func (mb *MetricsBuilder) RecordFlinkJobLastCheckpointSizeDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkJobLastCheckpointSize, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkJobLastCheckpointSize.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkJobLastCheckpointTimeDataPoint adds a data point to flink.job.last_checkpoint.time metric.
func (mb *MetricsBuilder) RecordFlinkJobLastCheckpointTimeDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkJobLastCheckpointTime, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkJobLastCheckpointTime.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkJobRestartCountDataPoint adds a data point to flink.job.restart.count metric.
func (mb *MetricsBuilder) RecordFlinkJobRestartCountDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkJobRestartCount, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkJobRestartCount.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkJobmanagerJvmClassLoaderClassesLoadedDataPoint adds a data point to flink.jobmanager.jvm.class_loader.classes_loaded metric.
func (mb *MetricsBuilder) RecordFlinkJobmanagerJvmClassLoaderClassesLoadedDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkJobmanagerJvmClassLoaderClassesLoaded, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkJobmanagerJvmClassLoaderClassesLoaded.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkJobmanagerJvmCPULoadDataPoint adds a data point to flink.jobmanager.jvm.cpu.load metric.
func (mb *MetricsBuilder) RecordFlinkJobmanagerJvmCPULoadDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseFloat(inputVal, 64)
	if err != nil {
		return fmt.Errorf("failed to parse float64 for FlinkJobmanagerJvmCPULoad, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkJobmanagerJvmCPULoad.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkJobmanagerJvmCPUTimeDataPoint adds a data point to flink.jobmanager.jvm.cpu.time metric.
func (mb *MetricsBuilder) RecordFlinkJobmanagerJvmCPUTimeDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkJobmanagerJvmCPUTime, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkJobmanagerJvmCPUTime.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkJobmanagerJvmGarbageCollectorCollectionCountDataPoint adds a data point to flink.jobmanager.jvm.garbage_collector.collection.count metric.
func (mb *MetricsBuilder) RecordFlinkJobmanagerJvmGarbageCollectorCollectionCountDataPoint(ts pcommon.Timestamp, inputVal string, garbageCollectorNameAttributeValue string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkJobmanagerJvmGarbageCollectorCollectionCount, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkJobmanagerJvmGarbageCollectorCollectionCount.recordDataPoint(mb.startTime, ts, val, garbageCollectorNameAttributeValue)
	return nil
}

// RecordFlinkJobmanagerJvmGarbageCollectorCollectionTimeDataPoint adds a data point to flink.jobmanager.jvm.garbage_collector.collection.time metric.
func (mb *MetricsBuilder) RecordFlinkJobmanagerJvmGarbageCollectorCollectionTimeDataPoint(ts pcommon.Timestamp, inputVal string, garbageCollectorNameAttributeValue string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkJobmanagerJvmGarbageCollectorCollectionTime, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkJobmanagerJvmGarbageCollectorCollectionTime.recordDataPoint(mb.startTime, ts, val, garbageCollectorNameAttributeValue)
	return nil
}

// RecordFlinkJobmanagerJvmMemoryDirectTotalCapacityDataPoint adds a data point to flink.jobmanager.jvm.memory.direct.total_capacity metric.
func (mb *MetricsBuilder) RecordFlinkJobmanagerJvmMemoryDirectTotalCapacityDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkJobmanagerJvmMemoryDirectTotalCapacity, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkJobmanagerJvmMemoryDirectTotalCapacity.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkJobmanagerJvmMemoryDirectUsedDataPoint adds a data point to flink.jobmanager.jvm.memory.direct.used metric.
func (mb *MetricsBuilder) RecordFlinkJobmanagerJvmMemoryDirectUsedDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkJobmanagerJvmMemoryDirectUsed, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkJobmanagerJvmMemoryDirectUsed.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkJobmanagerJvmMemoryHeapCommittedDataPoint adds a data point to flink.jobmanager.jvm.memory.heap.committed metric.
func (mb *MetricsBuilder) RecordFlinkJobmanagerJvmMemoryHeapCommittedDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkJobmanagerJvmMemoryHeapCommitted, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkJobmanagerJvmMemoryHeapCommitted.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkJobmanagerJvmMemoryHeapMaxDataPoint adds a data point to flink.jobmanager.jvm.memory.heap.max metric.
func (mb *MetricsBuilder) RecordFlinkJobmanagerJvmMemoryHeapMaxDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkJobmanagerJvmMemoryHeapMax, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkJobmanagerJvmMemoryHeapMax.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkJobmanagerJvmMemoryHeapUsedDataPoint adds a data point to flink.jobmanager.jvm.memory.heap.used metric.
func (mb *MetricsBuilder) RecordFlinkJobmanagerJvmMemoryHeapUsedDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkJobmanagerJvmMemoryHeapUsed, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkJobmanagerJvmMemoryHeapUsed.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkJobmanagerJvmMemoryMappedTotalCapacityDataPoint adds a data point to flink.jobmanager.jvm.memory.mapped.total_capacity metric.
func (mb *MetricsBuilder) RecordFlinkJobmanagerJvmMemoryMappedTotalCapacityDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkJobmanagerJvmMemoryMappedTotalCapacity, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkJobmanagerJvmMemoryMappedTotalCapacity.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkJobmanagerJvmMemoryMappedUsedDataPoint adds a data point to flink.jobmanager.jvm.memory.mapped.used metric.
func (mb *MetricsBuilder) RecordFlinkJobmanagerJvmMemoryMappedUsedDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkJobmanagerJvmMemoryMappedUsed, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkJobmanagerJvmMemoryMappedUsed.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkJobmanagerJvmMemoryMetaspaceCommittedDataPoint adds a data point to flink.jobmanager.jvm.memory.metaspace.committed metric.
func (mb *MetricsBuilder) RecordFlinkJobmanagerJvmMemoryMetaspaceCommittedDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkJobmanagerJvmMemoryMetaspaceCommitted, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkJobmanagerJvmMemoryMetaspaceCommitted.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkJobmanagerJvmMemoryMetaspaceMaxDataPoint adds a data point to flink.jobmanager.jvm.memory.metaspace.max metric.
func (mb *MetricsBuilder) RecordFlinkJobmanagerJvmMemoryMetaspaceMaxDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkJobmanagerJvmMemoryMetaspaceMax, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkJobmanagerJvmMemoryMetaspaceMax.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkJobmanagerJvmMemoryMetaspaceUsedDataPoint adds a data point to flink.jobmanager.jvm.memory.metaspace.used metric.
func (mb *MetricsBuilder) RecordFlinkJobmanagerJvmMemoryMetaspaceUsedDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkJobmanagerJvmMemoryMetaspaceUsed, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkJobmanagerJvmMemoryMetaspaceUsed.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkJobmanagerJvmMemoryNonHeapCommittedDataPoint adds a data point to flink.jobmanager.jvm.memory.non_heap.committed metric.
func (mb *MetricsBuilder) RecordFlinkJobmanagerJvmMemoryNonHeapCommittedDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkJobmanagerJvmMemoryNonHeapCommitted, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkJobmanagerJvmMemoryNonHeapCommitted.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkJobmanagerJvmMemoryNonHeapMaxDataPoint adds a data point to flink.jobmanager.jvm.memory.non_heap.max metric.
func (mb *MetricsBuilder) RecordFlinkJobmanagerJvmMemoryNonHeapMaxDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkJobmanagerJvmMemoryNonHeapMax, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkJobmanagerJvmMemoryNonHeapMax.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkJobmanagerJvmMemoryNonHeapUsedDataPoint adds a data point to flink.jobmanager.jvm.memory.non_heap.used metric.
func (mb *MetricsBuilder) RecordFlinkJobmanagerJvmMemoryNonHeapUsedDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkJobmanagerJvmMemoryNonHeapUsed, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkJobmanagerJvmMemoryNonHeapUsed.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkJobmanagerJvmThreadsCountDataPoint adds a data point to flink.jobmanager.jvm.threads.count metric.
func (mb *MetricsBuilder) RecordFlinkJobmanagerJvmThreadsCountDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkJobmanagerJvmThreadsCount, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkJobmanagerJvmThreadsCount.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkJobmanagerMemoryManagedTotalDataPoint adds a data point to flink.jobmanager.memory.managed.total metric.
func (mb *MetricsBuilder) RecordFlinkJobmanagerMemoryManagedTotalDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkJobmanagerMemoryManagedTotal, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkJobmanagerMemoryManagedTotal.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkJobmanagerMemoryManagedUsedDataPoint adds a data point to flink.jobmanager.memory.managed.used metric.
func (mb *MetricsBuilder) RecordFlinkJobmanagerMemoryManagedUsedDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkJobmanagerMemoryManagedUsed, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkJobmanagerMemoryManagedUsed.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkOperatorRecordCountDataPoint adds a data point to flink.operator.record.count metric.
func (mb *MetricsBuilder) RecordFlinkOperatorRecordCountDataPoint(ts pcommon.Timestamp, inputVal string, operatorNameAttributeValue string, recordAttributeValue AttributeRecord) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkOperatorRecordCount, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkOperatorRecordCount.recordDataPoint(mb.startTime, ts, val, operatorNameAttributeValue, recordAttributeValue.String())
	return nil
}

// RecordFlinkOperatorWatermarkOutputDataPoint adds a data point to flink.operator.watermark.output metric.
func (mb *MetricsBuilder) RecordFlinkOperatorWatermarkOutputDataPoint(ts pcommon.Timestamp, inputVal string, operatorNameAttributeValue string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkOperatorWatermarkOutput, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkOperatorWatermarkOutput.recordDataPoint(mb.startTime, ts, val, operatorNameAttributeValue)
	return nil
}

// RecordFlinkTaskRecordCountDataPoint adds a data point to flink.task.record.count metric.
func (mb *MetricsBuilder) RecordFlinkTaskRecordCountDataPoint(ts pcommon.Timestamp, inputVal string, recordAttributeValue AttributeRecord) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkTaskRecordCount, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkTaskRecordCount.recordDataPoint(mb.startTime, ts, val, recordAttributeValue.String())
	return nil
}

// RecordFlinkTaskmanagerJvmClassLoaderClassesLoadedDataPoint adds a data point to flink.taskmanager.jvm.class_loader.classes_loaded metric.
func (mb *MetricsBuilder) RecordFlinkTaskmanagerJvmClassLoaderClassesLoadedDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkTaskmanagerJvmClassLoaderClassesLoaded, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkTaskmanagerJvmClassLoaderClassesLoaded.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkTaskmanagerJvmCPULoadDataPoint adds a data point to flink.taskmanager.jvm.cpu.load metric.
func (mb *MetricsBuilder) RecordFlinkTaskmanagerJvmCPULoadDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseFloat(inputVal, 64)
	if err != nil {
		return fmt.Errorf("failed to parse float64 for FlinkTaskmanagerJvmCPULoad, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkTaskmanagerJvmCPULoad.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkTaskmanagerJvmCPUTimeDataPoint adds a data point to flink.taskmanager.jvm.cpu.time metric.
func (mb *MetricsBuilder) RecordFlinkTaskmanagerJvmCPUTimeDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkTaskmanagerJvmCPUTime, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkTaskmanagerJvmCPUTime.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkTaskmanagerJvmGarbageCollectorCollectionCountDataPoint adds a data point to flink.taskmanager.jvm.garbage_collector.collection.count metric.
func (mb *MetricsBuilder) RecordFlinkTaskmanagerJvmGarbageCollectorCollectionCountDataPoint(ts pcommon.Timestamp, inputVal string, garbageCollectorNameAttributeValue string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkTaskmanagerJvmGarbageCollectorCollectionCount, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkTaskmanagerJvmGarbageCollectorCollectionCount.recordDataPoint(mb.startTime, ts, val, garbageCollectorNameAttributeValue)
	return nil
}

// RecordFlinkTaskmanagerJvmGarbageCollectorCollectionTimeDataPoint adds a data point to flink.taskmanager.jvm.garbage_collector.collection.time metric.
func (mb *MetricsBuilder) RecordFlinkTaskmanagerJvmGarbageCollectorCollectionTimeDataPoint(ts pcommon.Timestamp, inputVal string, garbageCollectorNameAttributeValue string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkTaskmanagerJvmGarbageCollectorCollectionTime, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkTaskmanagerJvmGarbageCollectorCollectionTime.recordDataPoint(mb.startTime, ts, val, garbageCollectorNameAttributeValue)
	return nil
}

// RecordFlinkTaskmanagerJvmMemoryDirectTotalCapacityDataPoint adds a data point to flink.taskmanager.jvm.memory.direct.total_capacity metric.
func (mb *MetricsBuilder) RecordFlinkTaskmanagerJvmMemoryDirectTotalCapacityDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkTaskmanagerJvmMemoryDirectTotalCapacity, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkTaskmanagerJvmMemoryDirectTotalCapacity.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkTaskmanagerJvmMemoryDirectUsedDataPoint adds a data point to flink.taskmanager.jvm.memory.direct.used metric.
func (mb *MetricsBuilder) RecordFlinkTaskmanagerJvmMemoryDirectUsedDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkTaskmanagerJvmMemoryDirectUsed, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkTaskmanagerJvmMemoryDirectUsed.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkTaskmanagerJvmMemoryHeapCommittedDataPoint adds a data point to flink.taskmanager.jvm.memory.heap.committed metric.
func (mb *MetricsBuilder) RecordFlinkTaskmanagerJvmMemoryHeapCommittedDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkTaskmanagerJvmMemoryHeapCommitted, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkTaskmanagerJvmMemoryHeapCommitted.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkTaskmanagerJvmMemoryHeapMaxDataPoint adds a data point to flink.taskmanager.jvm.memory.heap.max metric.
func (mb *MetricsBuilder) RecordFlinkTaskmanagerJvmMemoryHeapMaxDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkTaskmanagerJvmMemoryHeapMax, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkTaskmanagerJvmMemoryHeapMax.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkTaskmanagerJvmMemoryHeapUsedDataPoint adds a data point to flink.taskmanager.jvm.memory.heap.used metric.
func (mb *MetricsBuilder) RecordFlinkTaskmanagerJvmMemoryHeapUsedDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkTaskmanagerJvmMemoryHeapUsed, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkTaskmanagerJvmMemoryHeapUsed.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkTaskmanagerJvmMemoryMappedTotalCapacityDataPoint adds a data point to flink.taskmanager.jvm.memory.mapped.total_capacity metric.
func (mb *MetricsBuilder) RecordFlinkTaskmanagerJvmMemoryMappedTotalCapacityDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkTaskmanagerJvmMemoryMappedTotalCapacity, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkTaskmanagerJvmMemoryMappedTotalCapacity.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkTaskmanagerJvmMemoryMappedUsedDataPoint adds a data point to flink.taskmanager.jvm.memory.mapped.used metric.
func (mb *MetricsBuilder) RecordFlinkTaskmanagerJvmMemoryMappedUsedDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkTaskmanagerJvmMemoryMappedUsed, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkTaskmanagerJvmMemoryMappedUsed.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkTaskmanagerJvmMemoryMetaspaceCommittedDataPoint adds a data point to flink.taskmanager.jvm.memory.metaspace.committed metric.
func (mb *MetricsBuilder) RecordFlinkTaskmanagerJvmMemoryMetaspaceCommittedDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkTaskmanagerJvmMemoryMetaspaceCommitted, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkTaskmanagerJvmMemoryMetaspaceCommitted.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkTaskmanagerJvmMemoryMetaspaceMaxDataPoint adds a data point to flink.taskmanager.jvm.memory.metaspace.max metric.
func (mb *MetricsBuilder) RecordFlinkTaskmanagerJvmMemoryMetaspaceMaxDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkTaskmanagerJvmMemoryMetaspaceMax, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkTaskmanagerJvmMemoryMetaspaceMax.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkTaskmanagerJvmMemoryMetaspaceUsedDataPoint adds a data point to flink.taskmanager.jvm.memory.metaspace.used metric.
func (mb *MetricsBuilder) RecordFlinkTaskmanagerJvmMemoryMetaspaceUsedDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkTaskmanagerJvmMemoryMetaspaceUsed, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkTaskmanagerJvmMemoryMetaspaceUsed.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkTaskmanagerJvmMemoryNonHeapCommittedDataPoint adds a data point to flink.taskmanager.jvm.memory.non_heap.committed metric.
func (mb *MetricsBuilder) RecordFlinkTaskmanagerJvmMemoryNonHeapCommittedDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkTaskmanagerJvmMemoryNonHeapCommitted, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkTaskmanagerJvmMemoryNonHeapCommitted.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkTaskmanagerJvmMemoryNonHeapMaxDataPoint adds a data point to flink.taskmanager.jvm.memory.non_heap.max metric.
func (mb *MetricsBuilder) RecordFlinkTaskmanagerJvmMemoryNonHeapMaxDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkTaskmanagerJvmMemoryNonHeapMax, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkTaskmanagerJvmMemoryNonHeapMax.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkTaskmanagerJvmMemoryNonHeapUsedDataPoint adds a data point to flink.taskmanager.jvm.memory.non_heap.used metric.
func (mb *MetricsBuilder) RecordFlinkTaskmanagerJvmMemoryNonHeapUsedDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkTaskmanagerJvmMemoryNonHeapUsed, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkTaskmanagerJvmMemoryNonHeapUsed.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkTaskmanagerJvmThreadsCountDataPoint adds a data point to flink.taskmanager.jvm.threads.count metric.
func (mb *MetricsBuilder) RecordFlinkTaskmanagerJvmThreadsCountDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkTaskmanagerJvmThreadsCount, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkTaskmanagerJvmThreadsCount.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkTaskmanagerMemoryManagedTotalDataPoint adds a data point to flink.taskmanager.memory.managed.total metric.
func (mb *MetricsBuilder) RecordFlinkTaskmanagerMemoryManagedTotalDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkTaskmanagerMemoryManagedTotal, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkTaskmanagerMemoryManagedTotal.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordFlinkTaskmanagerMemoryManagedUsedDataPoint adds a data point to flink.taskmanager.memory.managed.used metric.
func (mb *MetricsBuilder) RecordFlinkTaskmanagerMemoryManagedUsedDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for FlinkTaskmanagerMemoryManagedUsed, value was %s: %w", inputVal, err)
	}
	mb.metricFlinkTaskmanagerMemoryManagedUsed.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// Reset resets metrics builder to its initial state. It should be used when external metrics source is restarted,
// and metrics builder should update its startTime and reset it's internal state accordingly.
func (mb *MetricsBuilder) Reset(options ...metricBuilderOption) {
	mb.startTime = pcommon.NewTimestampFromTime(time.Now())
	for _, op := range options {
		op(mb)
	}
}
