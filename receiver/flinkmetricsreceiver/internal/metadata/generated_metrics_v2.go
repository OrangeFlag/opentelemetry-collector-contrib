// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"fmt"
	"strconv"
	"time"

	"go.opentelemetry.io/collector/pdata/pcommon"
	"go.opentelemetry.io/collector/pdata/pmetric"
)

// MetricSettings provides common settings for a particular metric.
type MetricSettings struct {
	Enabled bool `mapstructure:"enabled"`
}

// MetricsSettings provides settings for flinkreceiver metrics.
type MetricsSettings struct {
	FlinkJobCheckpointsCount                                 MetricSettings `mapstructure:"flink.job.checkpoints.count"`
	FlinkJobLastCheckpointSize                               MetricSettings `mapstructure:"flink.job.last_checkpoint.size"`
	FlinkJobLastCheckpointTime                               MetricSettings `mapstructure:"flink.job.last_checkpoint.time"`
	FlinkJobRestartCount                                     MetricSettings `mapstructure:"flink.job.restart.count"`
	FlinkJobmanagerStatusFlinkMemoryManagedTotal             MetricSettings `mapstructure:"flink.jobmanager.status.flink.memory.managed.total"`
	FlinkJobmanagerStatusFlinkMemoryManagedUsed              MetricSettings `mapstructure:"flink.jobmanager.status.flink.memory.managed.used"`
	FlinkJobmanagerStatusJvmClassLoaderClassesLoaded         MetricSettings `mapstructure:"flink.jobmanager.status.jvm.class_loader.classes_loaded"`
	FlinkJobmanagerStatusJvmCPULoad                          MetricSettings `mapstructure:"flink.jobmanager.status.jvm.cpu.load"`
	FlinkJobmanagerStatusJvmCPUTime                          MetricSettings `mapstructure:"flink.jobmanager.status.jvm.cpu.time"`
	FlinkJobmanagerStatusJvmGarbageCollectorCollectionCount  MetricSettings `mapstructure:"flink.jobmanager.status.jvm.garbage_collector.collection.count"`
	FlinkJobmanagerStatusJvmGarbageCollectorCollectionTime   MetricSettings `mapstructure:"flink.jobmanager.status.jvm.garbage_collector.collection.time"`
	FlinkJobmanagerStatusJvmMemoryDirectTotalCapacity        MetricSettings `mapstructure:"flink.jobmanager.status.jvm.memory.direct.total_capacity"`
	FlinkJobmanagerStatusJvmMemoryDirectUsed                 MetricSettings `mapstructure:"flink.jobmanager.status.jvm.memory.direct.used"`
	FlinkJobmanagerStatusJvmMemoryHeapCommitted              MetricSettings `mapstructure:"flink.jobmanager.status.jvm.memory.heap.committed"`
	FlinkJobmanagerStatusJvmMemoryHeapMax                    MetricSettings `mapstructure:"flink.jobmanager.status.jvm.memory.heap.max"`
	FlinkJobmanagerStatusJvmMemoryHeapUsed                   MetricSettings `mapstructure:"flink.jobmanager.status.jvm.memory.heap.used"`
	FlinkJobmanagerStatusJvmMemoryMappedTotalCapacity        MetricSettings `mapstructure:"flink.jobmanager.status.jvm.memory.mapped.total_capacity"`
	FlinkJobmanagerStatusJvmMemoryMappedUsed                 MetricSettings `mapstructure:"flink.jobmanager.status.jvm.memory.mapped.used"`
	FlinkJobmanagerStatusJvmMemoryMetaspaceCommitted         MetricSettings `mapstructure:"flink.jobmanager.status.jvm.memory.metaspace.committed"`
	FlinkJobmanagerStatusJvmMemoryMetaspaceMax               MetricSettings `mapstructure:"flink.jobmanager.status.jvm.memory.metaspace.max"`
	FlinkJobmanagerStatusJvmMemoryMetaspaceUsed              MetricSettings `mapstructure:"flink.jobmanager.status.jvm.memory.metaspace.used"`
	FlinkJobmanagerStatusJvmMemoryNonHeapCommitted           MetricSettings `mapstructure:"flink.jobmanager.status.jvm.memory.non_heap.committed"`
	FlinkJobmanagerStatusJvmMemoryNonHeapMax                 MetricSettings `mapstructure:"flink.jobmanager.status.jvm.memory.non_heap.max"`
	FlinkJobmanagerStatusJvmMemoryNonHeapUsed                MetricSettings `mapstructure:"flink.jobmanager.status.jvm.memory.non_heap.used"`
	FlinkJobmanagerStatusJvmThreadsCount                     MetricSettings `mapstructure:"flink.jobmanager.status.jvm.threads.count"`
	FlinkOperatorRecordCount                                 MetricSettings `mapstructure:"flink.operator.record.count"`
	FlinkOperatorWatermarkOutput                             MetricSettings `mapstructure:"flink.operator.watermark.output"`
	FlinkTaskRecordCount                                     MetricSettings `mapstructure:"flink.task.record.count"`
	FlinkTaskmanagerStatusFlinkMemoryManagedTotal            MetricSettings `mapstructure:"flink.taskmanager.status.flink.memory.managed.total"`
	FlinkTaskmanagerStatusFlinkMemoryManagedUsed             MetricSettings `mapstructure:"flink.taskmanager.status.flink.memory.managed.used"`
	FlinkTaskmanagerStatusJvmClassLoaderClassesLoaded        MetricSettings `mapstructure:"flink.taskmanager.status.jvm.class_loader.classes_loaded"`
	FlinkTaskmanagerStatusJvmCPULoad                         MetricSettings `mapstructure:"flink.taskmanager.status.jvm.cpu.load"`
	FlinkTaskmanagerStatusJvmCPUTime                         MetricSettings `mapstructure:"flink.taskmanager.status.jvm.cpu.time"`
	FlinkTaskmanagerStatusJvmGarbageCollectorCollectionCount MetricSettings `mapstructure:"flink.taskmanager.status.jvm.garbage_collector.collection.count"`
	FlinkTaskmanagerStatusJvmGarbageCollectorCollectionTime  MetricSettings `mapstructure:"flink.taskmanager.status.jvm.garbage_collector.collection.time"`
	FlinkTaskmanagerStatusJvmMemoryDirectTotalCapacity       MetricSettings `mapstructure:"flink.taskmanager.status.jvm.memory.direct.total_capacity"`
	FlinkTaskmanagerStatusJvmMemoryDirectUsed                MetricSettings `mapstructure:"flink.taskmanager.status.jvm.memory.direct.used"`
	FlinkTaskmanagerStatusJvmMemoryHeapCommitted             MetricSettings `mapstructure:"flink.taskmanager.status.jvm.memory.heap.committed"`
	FlinkTaskmanagerStatusJvmMemoryHeapMax                   MetricSettings `mapstructure:"flink.taskmanager.status.jvm.memory.heap.max"`
	FlinkTaskmanagerStatusJvmMemoryHeapUsed                  MetricSettings `mapstructure:"flink.taskmanager.status.jvm.memory.heap.used"`
	FlinkTaskmanagerStatusJvmMemoryMappedTotalCapacity       MetricSettings `mapstructure:"flink.taskmanager.status.jvm.memory.mapped.total_capacity"`
	FlinkTaskmanagerStatusJvmMemoryMappedUsed                MetricSettings `mapstructure:"flink.taskmanager.status.jvm.memory.mapped.used"`
	FlinkTaskmanagerStatusJvmMemoryMetaspaceCommitted        MetricSettings `mapstructure:"flink.taskmanager.status.jvm.memory.metaspace.committed"`
	FlinkTaskmanagerStatusJvmMemoryMetaspaceMax              MetricSettings `mapstructure:"flink.taskmanager.status.jvm.memory.metaspace.max"`
	FlinkTaskmanagerStatusJvmMemoryMetaspaceUsed             MetricSettings `mapstructure:"flink.taskmanager.status.jvm.memory.metaspace.used"`
	FlinkTaskmanagerStatusJvmMemoryNonHeapCommitted          MetricSettings `mapstructure:"flink.taskmanager.status.jvm.memory.non_heap.committed"`
	FlinkTaskmanagerStatusJvmMemoryNonHeapMax                MetricSettings `mapstructure:"flink.taskmanager.status.jvm.memory.non_heap.max"`
	FlinkTaskmanagerStatusJvmMemoryNonHeapUsed               MetricSettings `mapstructure:"flink.taskmanager.status.jvm.memory.non_heap.used"`
	FlinkTaskmanagerStatusJvmThreadsCount                    MetricSettings `mapstructure:"flink.taskmanager.status.jvm.threads.count"`
}

func DefaultMetricsSettings() MetricsSettings {
	return MetricsSettings{
		FlinkJobCheckpointsCount: MetricSettings{
			Enabled: true,
		},
		FlinkJobLastCheckpointSize: MetricSettings{
			Enabled: true,
		},
		FlinkJobLastCheckpointTime: MetricSettings{
			Enabled: true,
		},
		FlinkJobRestartCount: MetricSettings{
			Enabled: true,
		},
		FlinkJobmanagerStatusFlinkMemoryManagedTotal: MetricSettings{
			Enabled: true,
		},
		FlinkJobmanagerStatusFlinkMemoryManagedUsed: MetricSettings{
			Enabled: true,
		},
		FlinkJobmanagerStatusJvmClassLoaderClassesLoaded: MetricSettings{
			Enabled: true,
		},
		FlinkJobmanagerStatusJvmCPULoad: MetricSettings{
			Enabled: true,
		},
		FlinkJobmanagerStatusJvmCPUTime: MetricSettings{
			Enabled: true,
		},
		FlinkJobmanagerStatusJvmGarbageCollectorCollectionCount: MetricSettings{
			Enabled: true,
		},
		FlinkJobmanagerStatusJvmGarbageCollectorCollectionTime: MetricSettings{
			Enabled: true,
		},
		FlinkJobmanagerStatusJvmMemoryDirectTotalCapacity: MetricSettings{
			Enabled: true,
		},
		FlinkJobmanagerStatusJvmMemoryDirectUsed: MetricSettings{
			Enabled: true,
		},
		FlinkJobmanagerStatusJvmMemoryHeapCommitted: MetricSettings{
			Enabled: true,
		},
		FlinkJobmanagerStatusJvmMemoryHeapMax: MetricSettings{
			Enabled: true,
		},
		FlinkJobmanagerStatusJvmMemoryHeapUsed: MetricSettings{
			Enabled: true,
		},
		FlinkJobmanagerStatusJvmMemoryMappedTotalCapacity: MetricSettings{
			Enabled: true,
		},
		FlinkJobmanagerStatusJvmMemoryMappedUsed: MetricSettings{
			Enabled: true,
		},
		FlinkJobmanagerStatusJvmMemoryMetaspaceCommitted: MetricSettings{
			Enabled: true,
		},
		FlinkJobmanagerStatusJvmMemoryMetaspaceMax: MetricSettings{
			Enabled: true,
		},
		FlinkJobmanagerStatusJvmMemoryMetaspaceUsed: MetricSettings{
			Enabled: true,
		},
		FlinkJobmanagerStatusJvmMemoryNonHeapCommitted: MetricSettings{
			Enabled: true,
		},
		FlinkJobmanagerStatusJvmMemoryNonHeapMax: MetricSettings{
			Enabled: true,
		},
		FlinkJobmanagerStatusJvmMemoryNonHeapUsed: MetricSettings{
			Enabled: true,
		},
		FlinkJobmanagerStatusJvmThreadsCount: MetricSettings{
			Enabled: true,
		},
		FlinkOperatorRecordCount: MetricSettings{
			Enabled: true,
		},
		FlinkOperatorWatermarkOutput: MetricSettings{
			Enabled: true,
		},
		FlinkTaskRecordCount: MetricSettings{
			Enabled: true,
		},
		FlinkTaskmanagerStatusFlinkMemoryManagedTotal: MetricSettings{
			Enabled: true,
		},
		FlinkTaskmanagerStatusFlinkMemoryManagedUsed: MetricSettings{
			Enabled: true,
		},
		FlinkTaskmanagerStatusJvmClassLoaderClassesLoaded: MetricSettings{
			Enabled: true,
		},
		FlinkTaskmanagerStatusJvmCPULoad: MetricSettings{
			Enabled: true,
		},
		FlinkTaskmanagerStatusJvmCPUTime: MetricSettings{
			Enabled: true,
		},
		FlinkTaskmanagerStatusJvmGarbageCollectorCollectionCount: MetricSettings{
			Enabled: true,
		},
		FlinkTaskmanagerStatusJvmGarbageCollectorCollectionTime: MetricSettings{
			Enabled: true,
		},
		FlinkTaskmanagerStatusJvmMemoryDirectTotalCapacity: MetricSettings{
			Enabled: true,
		},
		FlinkTaskmanagerStatusJvmMemoryDirectUsed: MetricSettings{
			Enabled: true,
		},
		FlinkTaskmanagerStatusJvmMemoryHeapCommitted: MetricSettings{
			Enabled: true,
		},
		FlinkTaskmanagerStatusJvmMemoryHeapMax: MetricSettings{
			Enabled: true,
		},
		FlinkTaskmanagerStatusJvmMemoryHeapUsed: MetricSettings{
			Enabled: true,
		},
		FlinkTaskmanagerStatusJvmMemoryMappedTotalCapacity: MetricSettings{
			Enabled: true,
		},
		FlinkTaskmanagerStatusJvmMemoryMappedUsed: MetricSettings{
			Enabled: true,
		},
		FlinkTaskmanagerStatusJvmMemoryMetaspaceCommitted: MetricSettings{
			Enabled: true,
		},
		FlinkTaskmanagerStatusJvmMemoryMetaspaceMax: MetricSettings{
			Enabled: true,
		},
		FlinkTaskmanagerStatusJvmMemoryMetaspaceUsed: MetricSettings{
			Enabled: true,
		},
		FlinkTaskmanagerStatusJvmMemoryNonHeapCommitted: MetricSettings{
			Enabled: true,
		},
		FlinkTaskmanagerStatusJvmMemoryNonHeapMax: MetricSettings{
			Enabled: true,
		},
		FlinkTaskmanagerStatusJvmMemoryNonHeapUsed: MetricSettings{
			Enabled: true,
		},
		FlinkTaskmanagerStatusJvmThreadsCount: MetricSettings{
			Enabled: true,
		},
	}
}

// AttributeCheckpoint specifies the a value checkpoint attribute.
type AttributeCheckpoint int

const (
	_ AttributeCheckpoint = iota
	AttributeCheckpointInProgress
	AttributeCheckpointCompleted
	AttributeCheckpointFailed
)

// String returns the string representation of the AttributeCheckpoint.
func (av AttributeCheckpoint) String() string {
	switch av {
	case AttributeCheckpointInProgress:
		return "in_progress"
	case AttributeCheckpointCompleted:
		return "completed"
	case AttributeCheckpointFailed:
		return "failed"
	}
	return ""
}

// MapAttributeCheckpoint is a helper map of string to AttributeCheckpoint attribute value.
var MapAttributeCheckpoint = map[string]AttributeCheckpoint{
	"in_progress": AttributeCheckpointInProgress,
	"completed":   AttributeCheckpointCompleted,
	"failed":      AttributeCheckpointFailed,
}

// AttributeRecord specifies the a value record attribute.
type AttributeRecord int

const (
	_ AttributeRecord = iota
	AttributeRecordIn
	AttributeRecordOut
	AttributeRecordLateRecordsDropped
)

// String returns the string representation of the AttributeRecord.
func (av AttributeRecord) String() string {
	switch av {
	case AttributeRecordIn:
		return "in"
	case AttributeRecordOut:
		return "out"
	case AttributeRecordLateRecordsDropped:
		return "late_records_dropped"
	}
	return ""
}

// MapAttributeRecord is a helper map of string to AttributeRecord attribute value.
var MapAttributeRecord = map[string]AttributeRecord{
	"in":                   AttributeRecordIn,
	"out":                  AttributeRecordOut,
	"late_records_dropped": AttributeRecordLateRecordsDropped,
}

type metricFlinkJobCheckpointsCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.job.checkpoints.count metric with initial data.
func (m *metricFlinkJobCheckpointsCount) init() {
	m.data.SetName("flink.job.checkpoints.count")
	m.data.SetDescription("The number of checkpoints by type.")
	m.data.SetUnit("{checkpoints}")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkJobCheckpointsCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostAttributeValue string, jobNameAttributeValue string, checkpointAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Host, pcommon.NewValueString(hostAttributeValue))
	dp.Attributes().Insert(A.JobName, pcommon.NewValueString(jobNameAttributeValue))
	dp.Attributes().Insert(A.Checkpoint, pcommon.NewValueString(checkpointAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkJobCheckpointsCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkJobCheckpointsCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkJobCheckpointsCount(settings MetricSettings) metricFlinkJobCheckpointsCount {
	m := metricFlinkJobCheckpointsCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkJobLastCheckpointSize struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.job.last_checkpoint.size metric with initial data.
func (m *metricFlinkJobLastCheckpointSize) init() {
	m.data.SetName("flink.job.last_checkpoint.size")
	m.data.SetDescription("The total size of the last checkpoint.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkJobLastCheckpointSize) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostAttributeValue string, jobNameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Host, pcommon.NewValueString(hostAttributeValue))
	dp.Attributes().Insert(A.JobName, pcommon.NewValueString(jobNameAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkJobLastCheckpointSize) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkJobLastCheckpointSize) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkJobLastCheckpointSize(settings MetricSettings) metricFlinkJobLastCheckpointSize {
	m := metricFlinkJobLastCheckpointSize{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkJobLastCheckpointTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.job.last_checkpoint.time metric with initial data.
func (m *metricFlinkJobLastCheckpointTime) init() {
	m.data.SetName("flink.job.last_checkpoint.time")
	m.data.SetDescription("The time it took to complete the last checkpoint.")
	m.data.SetUnit("milliseconds")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkJobLastCheckpointTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostAttributeValue string, jobNameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Host, pcommon.NewValueString(hostAttributeValue))
	dp.Attributes().Insert(A.JobName, pcommon.NewValueString(jobNameAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkJobLastCheckpointTime) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkJobLastCheckpointTime) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkJobLastCheckpointTime(settings MetricSettings) metricFlinkJobLastCheckpointTime {
	m := metricFlinkJobLastCheckpointTime{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkJobRestartCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.job.restart.count metric with initial data.
func (m *metricFlinkJobRestartCount) init() {
	m.data.SetName("flink.job.restart.count")
	m.data.SetDescription("The total number of restarts since this job was submitted, including full restarts and fine-grained restarts.")
	m.data.SetUnit("{restarts}")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkJobRestartCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostAttributeValue string, jobNameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Host, pcommon.NewValueString(hostAttributeValue))
	dp.Attributes().Insert(A.JobName, pcommon.NewValueString(jobNameAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkJobRestartCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkJobRestartCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkJobRestartCount(settings MetricSettings) metricFlinkJobRestartCount {
	m := metricFlinkJobRestartCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkJobmanagerStatusFlinkMemoryManagedTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.jobmanager.status.flink.memory.managed.total metric with initial data.
func (m *metricFlinkJobmanagerStatusFlinkMemoryManagedTotal) init() {
	m.data.SetName("flink.jobmanager.status.flink.memory.managed.total")
	m.data.SetDescription("The total amount of managed memory.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkJobmanagerStatusFlinkMemoryManagedTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Host, pcommon.NewValueString(hostAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkJobmanagerStatusFlinkMemoryManagedTotal) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkJobmanagerStatusFlinkMemoryManagedTotal) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkJobmanagerStatusFlinkMemoryManagedTotal(settings MetricSettings) metricFlinkJobmanagerStatusFlinkMemoryManagedTotal {
	m := metricFlinkJobmanagerStatusFlinkMemoryManagedTotal{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkJobmanagerStatusFlinkMemoryManagedUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.jobmanager.status.flink.memory.managed.used metric with initial data.
func (m *metricFlinkJobmanagerStatusFlinkMemoryManagedUsed) init() {
	m.data.SetName("flink.jobmanager.status.flink.memory.managed.used")
	m.data.SetDescription("The amount of managed memory currently used.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkJobmanagerStatusFlinkMemoryManagedUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Host, pcommon.NewValueString(hostAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkJobmanagerStatusFlinkMemoryManagedUsed) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkJobmanagerStatusFlinkMemoryManagedUsed) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkJobmanagerStatusFlinkMemoryManagedUsed(settings MetricSettings) metricFlinkJobmanagerStatusFlinkMemoryManagedUsed {
	m := metricFlinkJobmanagerStatusFlinkMemoryManagedUsed{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkJobmanagerStatusJvmClassLoaderClassesLoaded struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.jobmanager.status.jvm.class_loader.classes_loaded metric with initial data.
func (m *metricFlinkJobmanagerStatusJvmClassLoaderClassesLoaded) init() {
	m.data.SetName("flink.jobmanager.status.jvm.class_loader.classes_loaded")
	m.data.SetDescription("The total number of classes loaded since the start of the JVM.")
	m.data.SetUnit("{classes}")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkJobmanagerStatusJvmClassLoaderClassesLoaded) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Host, pcommon.NewValueString(hostAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkJobmanagerStatusJvmClassLoaderClassesLoaded) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkJobmanagerStatusJvmClassLoaderClassesLoaded) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkJobmanagerStatusJvmClassLoaderClassesLoaded(settings MetricSettings) metricFlinkJobmanagerStatusJvmClassLoaderClassesLoaded {
	m := metricFlinkJobmanagerStatusJvmClassLoaderClassesLoaded{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkJobmanagerStatusJvmCPULoad struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.jobmanager.status.jvm.cpu.load metric with initial data.
func (m *metricFlinkJobmanagerStatusJvmCPULoad) init() {
	m.data.SetName("flink.jobmanager.status.jvm.cpu.load")
	m.data.SetDescription("The recent CPU usage of the JVM.")
	m.data.SetUnit("1")
	m.data.SetDataType(pmetric.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkJobmanagerStatusJvmCPULoad) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, hostAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.Host, pcommon.NewValueString(hostAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkJobmanagerStatusJvmCPULoad) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkJobmanagerStatusJvmCPULoad) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkJobmanagerStatusJvmCPULoad(settings MetricSettings) metricFlinkJobmanagerStatusJvmCPULoad {
	m := metricFlinkJobmanagerStatusJvmCPULoad{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkJobmanagerStatusJvmCPUTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.jobmanager.status.jvm.cpu.time metric with initial data.
func (m *metricFlinkJobmanagerStatusJvmCPUTime) init() {
	m.data.SetName("flink.jobmanager.status.jvm.cpu.time")
	m.data.SetDescription("The CPU time used by the JVM.")
	m.data.SetUnit("ns")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkJobmanagerStatusJvmCPUTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Host, pcommon.NewValueString(hostAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkJobmanagerStatusJvmCPUTime) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkJobmanagerStatusJvmCPUTime) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkJobmanagerStatusJvmCPUTime(settings MetricSettings) metricFlinkJobmanagerStatusJvmCPUTime {
	m := metricFlinkJobmanagerStatusJvmCPUTime{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkJobmanagerStatusJvmGarbageCollectorCollectionCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.jobmanager.status.jvm.garbage_collector.collection.count metric with initial data.
func (m *metricFlinkJobmanagerStatusJvmGarbageCollectorCollectionCount) init() {
	m.data.SetName("flink.jobmanager.status.jvm.garbage_collector.collection.count")
	m.data.SetDescription("The total number of collections that have occurred.")
	m.data.SetUnit("{collections}")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkJobmanagerStatusJvmGarbageCollectorCollectionCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostAttributeValue string, garbageCollectorNameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Host, pcommon.NewValueString(hostAttributeValue))
	dp.Attributes().Insert(A.GarbageCollectorName, pcommon.NewValueString(garbageCollectorNameAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkJobmanagerStatusJvmGarbageCollectorCollectionCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkJobmanagerStatusJvmGarbageCollectorCollectionCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkJobmanagerStatusJvmGarbageCollectorCollectionCount(settings MetricSettings) metricFlinkJobmanagerStatusJvmGarbageCollectorCollectionCount {
	m := metricFlinkJobmanagerStatusJvmGarbageCollectorCollectionCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkJobmanagerStatusJvmGarbageCollectorCollectionTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.jobmanager.status.jvm.garbage_collector.collection.time metric with initial data.
func (m *metricFlinkJobmanagerStatusJvmGarbageCollectorCollectionTime) init() {
	m.data.SetName("flink.jobmanager.status.jvm.garbage_collector.collection.time")
	m.data.SetDescription("The total time spent performing garbage collection.")
	m.data.SetUnit("milliseconds")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkJobmanagerStatusJvmGarbageCollectorCollectionTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostAttributeValue string, garbageCollectorNameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Host, pcommon.NewValueString(hostAttributeValue))
	dp.Attributes().Insert(A.GarbageCollectorName, pcommon.NewValueString(garbageCollectorNameAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkJobmanagerStatusJvmGarbageCollectorCollectionTime) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkJobmanagerStatusJvmGarbageCollectorCollectionTime) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkJobmanagerStatusJvmGarbageCollectorCollectionTime(settings MetricSettings) metricFlinkJobmanagerStatusJvmGarbageCollectorCollectionTime {
	m := metricFlinkJobmanagerStatusJvmGarbageCollectorCollectionTime{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkJobmanagerStatusJvmMemoryDirectTotalCapacity struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.jobmanager.status.jvm.memory.direct.total_capacity metric with initial data.
func (m *metricFlinkJobmanagerStatusJvmMemoryDirectTotalCapacity) init() {
	m.data.SetName("flink.jobmanager.status.jvm.memory.direct.total_capacity")
	m.data.SetDescription("The total capacity of all buffers in the direct buffer pool.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkJobmanagerStatusJvmMemoryDirectTotalCapacity) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Host, pcommon.NewValueString(hostAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkJobmanagerStatusJvmMemoryDirectTotalCapacity) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkJobmanagerStatusJvmMemoryDirectTotalCapacity) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkJobmanagerStatusJvmMemoryDirectTotalCapacity(settings MetricSettings) metricFlinkJobmanagerStatusJvmMemoryDirectTotalCapacity {
	m := metricFlinkJobmanagerStatusJvmMemoryDirectTotalCapacity{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkJobmanagerStatusJvmMemoryDirectUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.jobmanager.status.jvm.memory.direct.used metric with initial data.
func (m *metricFlinkJobmanagerStatusJvmMemoryDirectUsed) init() {
	m.data.SetName("flink.jobmanager.status.jvm.memory.direct.used")
	m.data.SetDescription("The amount of memory used by the JVM for the direct buffer pool.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkJobmanagerStatusJvmMemoryDirectUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Host, pcommon.NewValueString(hostAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkJobmanagerStatusJvmMemoryDirectUsed) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkJobmanagerStatusJvmMemoryDirectUsed) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkJobmanagerStatusJvmMemoryDirectUsed(settings MetricSettings) metricFlinkJobmanagerStatusJvmMemoryDirectUsed {
	m := metricFlinkJobmanagerStatusJvmMemoryDirectUsed{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkJobmanagerStatusJvmMemoryHeapCommitted struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.jobmanager.status.jvm.memory.heap.committed metric with initial data.
func (m *metricFlinkJobmanagerStatusJvmMemoryHeapCommitted) init() {
	m.data.SetName("flink.jobmanager.status.jvm.memory.heap.committed")
	m.data.SetDescription("The amount of heap memory guaranteed to be available to the JVM.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkJobmanagerStatusJvmMemoryHeapCommitted) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Host, pcommon.NewValueString(hostAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkJobmanagerStatusJvmMemoryHeapCommitted) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkJobmanagerStatusJvmMemoryHeapCommitted) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkJobmanagerStatusJvmMemoryHeapCommitted(settings MetricSettings) metricFlinkJobmanagerStatusJvmMemoryHeapCommitted {
	m := metricFlinkJobmanagerStatusJvmMemoryHeapCommitted{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkJobmanagerStatusJvmMemoryHeapMax struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.jobmanager.status.jvm.memory.heap.max metric with initial data.
func (m *metricFlinkJobmanagerStatusJvmMemoryHeapMax) init() {
	m.data.SetName("flink.jobmanager.status.jvm.memory.heap.max")
	m.data.SetDescription("The maximum amount of heap memory that can be used for memory management.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkJobmanagerStatusJvmMemoryHeapMax) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Host, pcommon.NewValueString(hostAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkJobmanagerStatusJvmMemoryHeapMax) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkJobmanagerStatusJvmMemoryHeapMax) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkJobmanagerStatusJvmMemoryHeapMax(settings MetricSettings) metricFlinkJobmanagerStatusJvmMemoryHeapMax {
	m := metricFlinkJobmanagerStatusJvmMemoryHeapMax{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkJobmanagerStatusJvmMemoryHeapUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.jobmanager.status.jvm.memory.heap.used metric with initial data.
func (m *metricFlinkJobmanagerStatusJvmMemoryHeapUsed) init() {
	m.data.SetName("flink.jobmanager.status.jvm.memory.heap.used")
	m.data.SetDescription("The amount of heap memory currently used.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkJobmanagerStatusJvmMemoryHeapUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Host, pcommon.NewValueString(hostAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkJobmanagerStatusJvmMemoryHeapUsed) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkJobmanagerStatusJvmMemoryHeapUsed) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkJobmanagerStatusJvmMemoryHeapUsed(settings MetricSettings) metricFlinkJobmanagerStatusJvmMemoryHeapUsed {
	m := metricFlinkJobmanagerStatusJvmMemoryHeapUsed{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkJobmanagerStatusJvmMemoryMappedTotalCapacity struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.jobmanager.status.jvm.memory.mapped.total_capacity metric with initial data.
func (m *metricFlinkJobmanagerStatusJvmMemoryMappedTotalCapacity) init() {
	m.data.SetName("flink.jobmanager.status.jvm.memory.mapped.total_capacity")
	m.data.SetDescription("The number of buffers in the mapped buffer pool.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkJobmanagerStatusJvmMemoryMappedTotalCapacity) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Host, pcommon.NewValueString(hostAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkJobmanagerStatusJvmMemoryMappedTotalCapacity) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkJobmanagerStatusJvmMemoryMappedTotalCapacity) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkJobmanagerStatusJvmMemoryMappedTotalCapacity(settings MetricSettings) metricFlinkJobmanagerStatusJvmMemoryMappedTotalCapacity {
	m := metricFlinkJobmanagerStatusJvmMemoryMappedTotalCapacity{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkJobmanagerStatusJvmMemoryMappedUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.jobmanager.status.jvm.memory.mapped.used metric with initial data.
func (m *metricFlinkJobmanagerStatusJvmMemoryMappedUsed) init() {
	m.data.SetName("flink.jobmanager.status.jvm.memory.mapped.used")
	m.data.SetDescription("The amount of memory used by the JVM for the mapped buffer pool.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkJobmanagerStatusJvmMemoryMappedUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Host, pcommon.NewValueString(hostAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkJobmanagerStatusJvmMemoryMappedUsed) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkJobmanagerStatusJvmMemoryMappedUsed) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkJobmanagerStatusJvmMemoryMappedUsed(settings MetricSettings) metricFlinkJobmanagerStatusJvmMemoryMappedUsed {
	m := metricFlinkJobmanagerStatusJvmMemoryMappedUsed{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkJobmanagerStatusJvmMemoryMetaspaceCommitted struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.jobmanager.status.jvm.memory.metaspace.committed metric with initial data.
func (m *metricFlinkJobmanagerStatusJvmMemoryMetaspaceCommitted) init() {
	m.data.SetName("flink.jobmanager.status.jvm.memory.metaspace.committed")
	m.data.SetDescription("The amount of memory guaranteed to be available to the JVM in the Metaspace memory pool.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkJobmanagerStatusJvmMemoryMetaspaceCommitted) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Host, pcommon.NewValueString(hostAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkJobmanagerStatusJvmMemoryMetaspaceCommitted) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkJobmanagerStatusJvmMemoryMetaspaceCommitted) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkJobmanagerStatusJvmMemoryMetaspaceCommitted(settings MetricSettings) metricFlinkJobmanagerStatusJvmMemoryMetaspaceCommitted {
	m := metricFlinkJobmanagerStatusJvmMemoryMetaspaceCommitted{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkJobmanagerStatusJvmMemoryMetaspaceMax struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.jobmanager.status.jvm.memory.metaspace.max metric with initial data.
func (m *metricFlinkJobmanagerStatusJvmMemoryMetaspaceMax) init() {
	m.data.SetName("flink.jobmanager.status.jvm.memory.metaspace.max")
	m.data.SetDescription("The maximum amount of memory that can be used in the Metaspace memory pool.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkJobmanagerStatusJvmMemoryMetaspaceMax) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Host, pcommon.NewValueString(hostAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkJobmanagerStatusJvmMemoryMetaspaceMax) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkJobmanagerStatusJvmMemoryMetaspaceMax) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkJobmanagerStatusJvmMemoryMetaspaceMax(settings MetricSettings) metricFlinkJobmanagerStatusJvmMemoryMetaspaceMax {
	m := metricFlinkJobmanagerStatusJvmMemoryMetaspaceMax{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkJobmanagerStatusJvmMemoryMetaspaceUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.jobmanager.status.jvm.memory.metaspace.used metric with initial data.
func (m *metricFlinkJobmanagerStatusJvmMemoryMetaspaceUsed) init() {
	m.data.SetName("flink.jobmanager.status.jvm.memory.metaspace.used")
	m.data.SetDescription("The amount of memory currently used in the Metaspace memory pool.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkJobmanagerStatusJvmMemoryMetaspaceUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Host, pcommon.NewValueString(hostAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkJobmanagerStatusJvmMemoryMetaspaceUsed) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkJobmanagerStatusJvmMemoryMetaspaceUsed) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkJobmanagerStatusJvmMemoryMetaspaceUsed(settings MetricSettings) metricFlinkJobmanagerStatusJvmMemoryMetaspaceUsed {
	m := metricFlinkJobmanagerStatusJvmMemoryMetaspaceUsed{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkJobmanagerStatusJvmMemoryNonHeapCommitted struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.jobmanager.status.jvm.memory.non_heap.committed metric with initial data.
func (m *metricFlinkJobmanagerStatusJvmMemoryNonHeapCommitted) init() {
	m.data.SetName("flink.jobmanager.status.jvm.memory.non_heap.committed")
	m.data.SetDescription("The amount of non-heap memory guaranteed to be available to the JVM.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkJobmanagerStatusJvmMemoryNonHeapCommitted) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Host, pcommon.NewValueString(hostAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkJobmanagerStatusJvmMemoryNonHeapCommitted) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkJobmanagerStatusJvmMemoryNonHeapCommitted) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkJobmanagerStatusJvmMemoryNonHeapCommitted(settings MetricSettings) metricFlinkJobmanagerStatusJvmMemoryNonHeapCommitted {
	m := metricFlinkJobmanagerStatusJvmMemoryNonHeapCommitted{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkJobmanagerStatusJvmMemoryNonHeapMax struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.jobmanager.status.jvm.memory.non_heap.max metric with initial data.
func (m *metricFlinkJobmanagerStatusJvmMemoryNonHeapMax) init() {
	m.data.SetName("flink.jobmanager.status.jvm.memory.non_heap.max")
	m.data.SetDescription("The maximum amount of non-heap memory that can be used for memory management.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkJobmanagerStatusJvmMemoryNonHeapMax) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Host, pcommon.NewValueString(hostAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkJobmanagerStatusJvmMemoryNonHeapMax) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkJobmanagerStatusJvmMemoryNonHeapMax) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkJobmanagerStatusJvmMemoryNonHeapMax(settings MetricSettings) metricFlinkJobmanagerStatusJvmMemoryNonHeapMax {
	m := metricFlinkJobmanagerStatusJvmMemoryNonHeapMax{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkJobmanagerStatusJvmMemoryNonHeapUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.jobmanager.status.jvm.memory.non_heap.used metric with initial data.
func (m *metricFlinkJobmanagerStatusJvmMemoryNonHeapUsed) init() {
	m.data.SetName("flink.jobmanager.status.jvm.memory.non_heap.used")
	m.data.SetDescription("The amount of non-heap memory currently used.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkJobmanagerStatusJvmMemoryNonHeapUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Host, pcommon.NewValueString(hostAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkJobmanagerStatusJvmMemoryNonHeapUsed) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkJobmanagerStatusJvmMemoryNonHeapUsed) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkJobmanagerStatusJvmMemoryNonHeapUsed(settings MetricSettings) metricFlinkJobmanagerStatusJvmMemoryNonHeapUsed {
	m := metricFlinkJobmanagerStatusJvmMemoryNonHeapUsed{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkJobmanagerStatusJvmThreadsCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.jobmanager.status.jvm.threads.count metric with initial data.
func (m *metricFlinkJobmanagerStatusJvmThreadsCount) init() {
	m.data.SetName("flink.jobmanager.status.jvm.threads.count")
	m.data.SetDescription("The total number of live threads.")
	m.data.SetUnit("{threads}")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkJobmanagerStatusJvmThreadsCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Host, pcommon.NewValueString(hostAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkJobmanagerStatusJvmThreadsCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkJobmanagerStatusJvmThreadsCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkJobmanagerStatusJvmThreadsCount(settings MetricSettings) metricFlinkJobmanagerStatusJvmThreadsCount {
	m := metricFlinkJobmanagerStatusJvmThreadsCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkOperatorRecordCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.operator.record.count metric with initial data.
func (m *metricFlinkOperatorRecordCount) init() {
	m.data.SetName("flink.operator.record.count")
	m.data.SetDescription("The number of records this operator type has.")
	m.data.SetUnit("{records}")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkOperatorRecordCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostAttributeValue string, taskmanagerIDAttributeValue string, jobNameAttributeValue string, operatorNameAttributeValue string, subtaskIndexAttributeValue string, recordAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Host, pcommon.NewValueString(hostAttributeValue))
	dp.Attributes().Insert(A.TaskmanagerID, pcommon.NewValueString(taskmanagerIDAttributeValue))
	dp.Attributes().Insert(A.JobName, pcommon.NewValueString(jobNameAttributeValue))
	dp.Attributes().Insert(A.OperatorName, pcommon.NewValueString(operatorNameAttributeValue))
	dp.Attributes().Insert(A.SubtaskIndex, pcommon.NewValueString(subtaskIndexAttributeValue))
	dp.Attributes().Insert(A.Record, pcommon.NewValueString(recordAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkOperatorRecordCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkOperatorRecordCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkOperatorRecordCount(settings MetricSettings) metricFlinkOperatorRecordCount {
	m := metricFlinkOperatorRecordCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkOperatorWatermarkOutput struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.operator.watermark.output metric with initial data.
func (m *metricFlinkOperatorWatermarkOutput) init() {
	m.data.SetName("flink.operator.watermark.output")
	m.data.SetDescription("The last watermark this operator has emitted.")
	m.data.SetUnit("milliseconds")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkOperatorWatermarkOutput) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostAttributeValue string, taskmanagerIDAttributeValue string, jobNameAttributeValue string, operatorNameAttributeValue string, subtaskIndexAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Host, pcommon.NewValueString(hostAttributeValue))
	dp.Attributes().Insert(A.TaskmanagerID, pcommon.NewValueString(taskmanagerIDAttributeValue))
	dp.Attributes().Insert(A.JobName, pcommon.NewValueString(jobNameAttributeValue))
	dp.Attributes().Insert(A.OperatorName, pcommon.NewValueString(operatorNameAttributeValue))
	dp.Attributes().Insert(A.SubtaskIndex, pcommon.NewValueString(subtaskIndexAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkOperatorWatermarkOutput) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkOperatorWatermarkOutput) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkOperatorWatermarkOutput(settings MetricSettings) metricFlinkOperatorWatermarkOutput {
	m := metricFlinkOperatorWatermarkOutput{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkTaskRecordCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.task.record.count metric with initial data.
func (m *metricFlinkTaskRecordCount) init() {
	m.data.SetName("flink.task.record.count")
	m.data.SetDescription("The number of records this task type has.")
	m.data.SetUnit("{records}")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkTaskRecordCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostAttributeValue string, taskmanagerIDAttributeValue string, jobNameAttributeValue string, taskNameAttributeValue string, subtaskIndexAttributeValue string, recordAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Host, pcommon.NewValueString(hostAttributeValue))
	dp.Attributes().Insert(A.TaskmanagerID, pcommon.NewValueString(taskmanagerIDAttributeValue))
	dp.Attributes().Insert(A.JobName, pcommon.NewValueString(jobNameAttributeValue))
	dp.Attributes().Insert(A.TaskName, pcommon.NewValueString(taskNameAttributeValue))
	dp.Attributes().Insert(A.SubtaskIndex, pcommon.NewValueString(subtaskIndexAttributeValue))
	dp.Attributes().Insert(A.Record, pcommon.NewValueString(recordAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkTaskRecordCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkTaskRecordCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkTaskRecordCount(settings MetricSettings) metricFlinkTaskRecordCount {
	m := metricFlinkTaskRecordCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkTaskmanagerStatusFlinkMemoryManagedTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.taskmanager.status.flink.memory.managed.total metric with initial data.
func (m *metricFlinkTaskmanagerStatusFlinkMemoryManagedTotal) init() {
	m.data.SetName("flink.taskmanager.status.flink.memory.managed.total")
	m.data.SetDescription("The total amount of managed memory.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkTaskmanagerStatusFlinkMemoryManagedTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostAttributeValue string, taskmanagerIDAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Host, pcommon.NewValueString(hostAttributeValue))
	dp.Attributes().Insert(A.TaskmanagerID, pcommon.NewValueString(taskmanagerIDAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkTaskmanagerStatusFlinkMemoryManagedTotal) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkTaskmanagerStatusFlinkMemoryManagedTotal) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkTaskmanagerStatusFlinkMemoryManagedTotal(settings MetricSettings) metricFlinkTaskmanagerStatusFlinkMemoryManagedTotal {
	m := metricFlinkTaskmanagerStatusFlinkMemoryManagedTotal{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkTaskmanagerStatusFlinkMemoryManagedUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.taskmanager.status.flink.memory.managed.used metric with initial data.
func (m *metricFlinkTaskmanagerStatusFlinkMemoryManagedUsed) init() {
	m.data.SetName("flink.taskmanager.status.flink.memory.managed.used")
	m.data.SetDescription("The amount of managed memory currently used.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkTaskmanagerStatusFlinkMemoryManagedUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostAttributeValue string, taskmanagerIDAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Host, pcommon.NewValueString(hostAttributeValue))
	dp.Attributes().Insert(A.TaskmanagerID, pcommon.NewValueString(taskmanagerIDAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkTaskmanagerStatusFlinkMemoryManagedUsed) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkTaskmanagerStatusFlinkMemoryManagedUsed) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkTaskmanagerStatusFlinkMemoryManagedUsed(settings MetricSettings) metricFlinkTaskmanagerStatusFlinkMemoryManagedUsed {
	m := metricFlinkTaskmanagerStatusFlinkMemoryManagedUsed{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkTaskmanagerStatusJvmClassLoaderClassesLoaded struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.taskmanager.status.jvm.class_loader.classes_loaded metric with initial data.
func (m *metricFlinkTaskmanagerStatusJvmClassLoaderClassesLoaded) init() {
	m.data.SetName("flink.taskmanager.status.jvm.class_loader.classes_loaded")
	m.data.SetDescription("The total number of classes loaded since the start of the JVM.")
	m.data.SetUnit("{classes}")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkTaskmanagerStatusJvmClassLoaderClassesLoaded) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostAttributeValue string, taskmanagerIDAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Host, pcommon.NewValueString(hostAttributeValue))
	dp.Attributes().Insert(A.TaskmanagerID, pcommon.NewValueString(taskmanagerIDAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkTaskmanagerStatusJvmClassLoaderClassesLoaded) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkTaskmanagerStatusJvmClassLoaderClassesLoaded) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkTaskmanagerStatusJvmClassLoaderClassesLoaded(settings MetricSettings) metricFlinkTaskmanagerStatusJvmClassLoaderClassesLoaded {
	m := metricFlinkTaskmanagerStatusJvmClassLoaderClassesLoaded{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkTaskmanagerStatusJvmCPULoad struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.taskmanager.status.jvm.cpu.load metric with initial data.
func (m *metricFlinkTaskmanagerStatusJvmCPULoad) init() {
	m.data.SetName("flink.taskmanager.status.jvm.cpu.load")
	m.data.SetDescription("The recent CPU usage of the JVM.")
	m.data.SetUnit("1")
	m.data.SetDataType(pmetric.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkTaskmanagerStatusJvmCPULoad) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, hostAttributeValue string, taskmanagerIDAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.Host, pcommon.NewValueString(hostAttributeValue))
	dp.Attributes().Insert(A.TaskmanagerID, pcommon.NewValueString(taskmanagerIDAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkTaskmanagerStatusJvmCPULoad) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkTaskmanagerStatusJvmCPULoad) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkTaskmanagerStatusJvmCPULoad(settings MetricSettings) metricFlinkTaskmanagerStatusJvmCPULoad {
	m := metricFlinkTaskmanagerStatusJvmCPULoad{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkTaskmanagerStatusJvmCPUTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.taskmanager.status.jvm.cpu.time metric with initial data.
func (m *metricFlinkTaskmanagerStatusJvmCPUTime) init() {
	m.data.SetName("flink.taskmanager.status.jvm.cpu.time")
	m.data.SetDescription("The CPU time used by the JVM.")
	m.data.SetUnit("ns")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkTaskmanagerStatusJvmCPUTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostAttributeValue string, taskmanagerIDAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Host, pcommon.NewValueString(hostAttributeValue))
	dp.Attributes().Insert(A.TaskmanagerID, pcommon.NewValueString(taskmanagerIDAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkTaskmanagerStatusJvmCPUTime) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkTaskmanagerStatusJvmCPUTime) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkTaskmanagerStatusJvmCPUTime(settings MetricSettings) metricFlinkTaskmanagerStatusJvmCPUTime {
	m := metricFlinkTaskmanagerStatusJvmCPUTime{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkTaskmanagerStatusJvmGarbageCollectorCollectionCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.taskmanager.status.jvm.garbage_collector.collection.count metric with initial data.
func (m *metricFlinkTaskmanagerStatusJvmGarbageCollectorCollectionCount) init() {
	m.data.SetName("flink.taskmanager.status.jvm.garbage_collector.collection.count")
	m.data.SetDescription("The total number of collections that have occurred.")
	m.data.SetUnit("{collections}")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkTaskmanagerStatusJvmGarbageCollectorCollectionCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostAttributeValue string, taskmanagerIDAttributeValue string, garbageCollectorNameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Host, pcommon.NewValueString(hostAttributeValue))
	dp.Attributes().Insert(A.TaskmanagerID, pcommon.NewValueString(taskmanagerIDAttributeValue))
	dp.Attributes().Insert(A.GarbageCollectorName, pcommon.NewValueString(garbageCollectorNameAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkTaskmanagerStatusJvmGarbageCollectorCollectionCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkTaskmanagerStatusJvmGarbageCollectorCollectionCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkTaskmanagerStatusJvmGarbageCollectorCollectionCount(settings MetricSettings) metricFlinkTaskmanagerStatusJvmGarbageCollectorCollectionCount {
	m := metricFlinkTaskmanagerStatusJvmGarbageCollectorCollectionCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkTaskmanagerStatusJvmGarbageCollectorCollectionTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.taskmanager.status.jvm.garbage_collector.collection.time metric with initial data.
func (m *metricFlinkTaskmanagerStatusJvmGarbageCollectorCollectionTime) init() {
	m.data.SetName("flink.taskmanager.status.jvm.garbage_collector.collection.time")
	m.data.SetDescription("The total time spent performing garbage collection.")
	m.data.SetUnit("{milliseconds}")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkTaskmanagerStatusJvmGarbageCollectorCollectionTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostAttributeValue string, taskmanagerIDAttributeValue string, garbageCollectorNameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Host, pcommon.NewValueString(hostAttributeValue))
	dp.Attributes().Insert(A.TaskmanagerID, pcommon.NewValueString(taskmanagerIDAttributeValue))
	dp.Attributes().Insert(A.GarbageCollectorName, pcommon.NewValueString(garbageCollectorNameAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkTaskmanagerStatusJvmGarbageCollectorCollectionTime) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkTaskmanagerStatusJvmGarbageCollectorCollectionTime) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkTaskmanagerStatusJvmGarbageCollectorCollectionTime(settings MetricSettings) metricFlinkTaskmanagerStatusJvmGarbageCollectorCollectionTime {
	m := metricFlinkTaskmanagerStatusJvmGarbageCollectorCollectionTime{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkTaskmanagerStatusJvmMemoryDirectTotalCapacity struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.taskmanager.status.jvm.memory.direct.total_capacity metric with initial data.
func (m *metricFlinkTaskmanagerStatusJvmMemoryDirectTotalCapacity) init() {
	m.data.SetName("flink.taskmanager.status.jvm.memory.direct.total_capacity")
	m.data.SetDescription("The total capacity of all buffers in the direct buffer pool.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkTaskmanagerStatusJvmMemoryDirectTotalCapacity) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostAttributeValue string, taskmanagerIDAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Host, pcommon.NewValueString(hostAttributeValue))
	dp.Attributes().Insert(A.TaskmanagerID, pcommon.NewValueString(taskmanagerIDAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkTaskmanagerStatusJvmMemoryDirectTotalCapacity) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkTaskmanagerStatusJvmMemoryDirectTotalCapacity) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkTaskmanagerStatusJvmMemoryDirectTotalCapacity(settings MetricSettings) metricFlinkTaskmanagerStatusJvmMemoryDirectTotalCapacity {
	m := metricFlinkTaskmanagerStatusJvmMemoryDirectTotalCapacity{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkTaskmanagerStatusJvmMemoryDirectUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.taskmanager.status.jvm.memory.direct.used metric with initial data.
func (m *metricFlinkTaskmanagerStatusJvmMemoryDirectUsed) init() {
	m.data.SetName("flink.taskmanager.status.jvm.memory.direct.used")
	m.data.SetDescription("The amount of memory used by the JVM for the direct buffer pool.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkTaskmanagerStatusJvmMemoryDirectUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostAttributeValue string, taskmanagerIDAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Host, pcommon.NewValueString(hostAttributeValue))
	dp.Attributes().Insert(A.TaskmanagerID, pcommon.NewValueString(taskmanagerIDAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkTaskmanagerStatusJvmMemoryDirectUsed) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkTaskmanagerStatusJvmMemoryDirectUsed) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkTaskmanagerStatusJvmMemoryDirectUsed(settings MetricSettings) metricFlinkTaskmanagerStatusJvmMemoryDirectUsed {
	m := metricFlinkTaskmanagerStatusJvmMemoryDirectUsed{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkTaskmanagerStatusJvmMemoryHeapCommitted struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.taskmanager.status.jvm.memory.heap.committed metric with initial data.
func (m *metricFlinkTaskmanagerStatusJvmMemoryHeapCommitted) init() {
	m.data.SetName("flink.taskmanager.status.jvm.memory.heap.committed")
	m.data.SetDescription("The amount of heap memory guaranteed to be available to the JVM.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkTaskmanagerStatusJvmMemoryHeapCommitted) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostAttributeValue string, taskmanagerIDAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Host, pcommon.NewValueString(hostAttributeValue))
	dp.Attributes().Insert(A.TaskmanagerID, pcommon.NewValueString(taskmanagerIDAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkTaskmanagerStatusJvmMemoryHeapCommitted) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkTaskmanagerStatusJvmMemoryHeapCommitted) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkTaskmanagerStatusJvmMemoryHeapCommitted(settings MetricSettings) metricFlinkTaskmanagerStatusJvmMemoryHeapCommitted {
	m := metricFlinkTaskmanagerStatusJvmMemoryHeapCommitted{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkTaskmanagerStatusJvmMemoryHeapMax struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.taskmanager.status.jvm.memory.heap.max metric with initial data.
func (m *metricFlinkTaskmanagerStatusJvmMemoryHeapMax) init() {
	m.data.SetName("flink.taskmanager.status.jvm.memory.heap.max")
	m.data.SetDescription("The maximum amount of heap memory that can be used for memory management.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkTaskmanagerStatusJvmMemoryHeapMax) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostAttributeValue string, taskmanagerIDAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Host, pcommon.NewValueString(hostAttributeValue))
	dp.Attributes().Insert(A.TaskmanagerID, pcommon.NewValueString(taskmanagerIDAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkTaskmanagerStatusJvmMemoryHeapMax) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkTaskmanagerStatusJvmMemoryHeapMax) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkTaskmanagerStatusJvmMemoryHeapMax(settings MetricSettings) metricFlinkTaskmanagerStatusJvmMemoryHeapMax {
	m := metricFlinkTaskmanagerStatusJvmMemoryHeapMax{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkTaskmanagerStatusJvmMemoryHeapUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.taskmanager.status.jvm.memory.heap.used metric with initial data.
func (m *metricFlinkTaskmanagerStatusJvmMemoryHeapUsed) init() {
	m.data.SetName("flink.taskmanager.status.jvm.memory.heap.used")
	m.data.SetDescription("The amount of heap memory currently used.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkTaskmanagerStatusJvmMemoryHeapUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostAttributeValue string, taskmanagerIDAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Host, pcommon.NewValueString(hostAttributeValue))
	dp.Attributes().Insert(A.TaskmanagerID, pcommon.NewValueString(taskmanagerIDAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkTaskmanagerStatusJvmMemoryHeapUsed) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkTaskmanagerStatusJvmMemoryHeapUsed) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkTaskmanagerStatusJvmMemoryHeapUsed(settings MetricSettings) metricFlinkTaskmanagerStatusJvmMemoryHeapUsed {
	m := metricFlinkTaskmanagerStatusJvmMemoryHeapUsed{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkTaskmanagerStatusJvmMemoryMappedTotalCapacity struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.taskmanager.status.jvm.memory.mapped.total_capacity metric with initial data.
func (m *metricFlinkTaskmanagerStatusJvmMemoryMappedTotalCapacity) init() {
	m.data.SetName("flink.taskmanager.status.jvm.memory.mapped.total_capacity")
	m.data.SetDescription("The number of buffers in the mapped buffer pool.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkTaskmanagerStatusJvmMemoryMappedTotalCapacity) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostAttributeValue string, taskmanagerIDAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Host, pcommon.NewValueString(hostAttributeValue))
	dp.Attributes().Insert(A.TaskmanagerID, pcommon.NewValueString(taskmanagerIDAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkTaskmanagerStatusJvmMemoryMappedTotalCapacity) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkTaskmanagerStatusJvmMemoryMappedTotalCapacity) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkTaskmanagerStatusJvmMemoryMappedTotalCapacity(settings MetricSettings) metricFlinkTaskmanagerStatusJvmMemoryMappedTotalCapacity {
	m := metricFlinkTaskmanagerStatusJvmMemoryMappedTotalCapacity{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkTaskmanagerStatusJvmMemoryMappedUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.taskmanager.status.jvm.memory.mapped.used metric with initial data.
func (m *metricFlinkTaskmanagerStatusJvmMemoryMappedUsed) init() {
	m.data.SetName("flink.taskmanager.status.jvm.memory.mapped.used")
	m.data.SetDescription("The amount of memory used by the JVM for the mapped buffer pool.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkTaskmanagerStatusJvmMemoryMappedUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostAttributeValue string, taskmanagerIDAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Host, pcommon.NewValueString(hostAttributeValue))
	dp.Attributes().Insert(A.TaskmanagerID, pcommon.NewValueString(taskmanagerIDAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkTaskmanagerStatusJvmMemoryMappedUsed) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkTaskmanagerStatusJvmMemoryMappedUsed) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkTaskmanagerStatusJvmMemoryMappedUsed(settings MetricSettings) metricFlinkTaskmanagerStatusJvmMemoryMappedUsed {
	m := metricFlinkTaskmanagerStatusJvmMemoryMappedUsed{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkTaskmanagerStatusJvmMemoryMetaspaceCommitted struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.taskmanager.status.jvm.memory.metaspace.committed metric with initial data.
func (m *metricFlinkTaskmanagerStatusJvmMemoryMetaspaceCommitted) init() {
	m.data.SetName("flink.taskmanager.status.jvm.memory.metaspace.committed")
	m.data.SetDescription("The amount of memory guaranteed to be available to the JVM in the Metaspace memory pool.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkTaskmanagerStatusJvmMemoryMetaspaceCommitted) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostAttributeValue string, taskmanagerIDAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Host, pcommon.NewValueString(hostAttributeValue))
	dp.Attributes().Insert(A.TaskmanagerID, pcommon.NewValueString(taskmanagerIDAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkTaskmanagerStatusJvmMemoryMetaspaceCommitted) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkTaskmanagerStatusJvmMemoryMetaspaceCommitted) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkTaskmanagerStatusJvmMemoryMetaspaceCommitted(settings MetricSettings) metricFlinkTaskmanagerStatusJvmMemoryMetaspaceCommitted {
	m := metricFlinkTaskmanagerStatusJvmMemoryMetaspaceCommitted{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkTaskmanagerStatusJvmMemoryMetaspaceMax struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.taskmanager.status.jvm.memory.metaspace.max metric with initial data.
func (m *metricFlinkTaskmanagerStatusJvmMemoryMetaspaceMax) init() {
	m.data.SetName("flink.taskmanager.status.jvm.memory.metaspace.max")
	m.data.SetDescription("The maximum amount of memory that can be used in the Metaspace memory pool.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkTaskmanagerStatusJvmMemoryMetaspaceMax) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostAttributeValue string, taskmanagerIDAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Host, pcommon.NewValueString(hostAttributeValue))
	dp.Attributes().Insert(A.TaskmanagerID, pcommon.NewValueString(taskmanagerIDAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkTaskmanagerStatusJvmMemoryMetaspaceMax) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkTaskmanagerStatusJvmMemoryMetaspaceMax) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkTaskmanagerStatusJvmMemoryMetaspaceMax(settings MetricSettings) metricFlinkTaskmanagerStatusJvmMemoryMetaspaceMax {
	m := metricFlinkTaskmanagerStatusJvmMemoryMetaspaceMax{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkTaskmanagerStatusJvmMemoryMetaspaceUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.taskmanager.status.jvm.memory.metaspace.used metric with initial data.
func (m *metricFlinkTaskmanagerStatusJvmMemoryMetaspaceUsed) init() {
	m.data.SetName("flink.taskmanager.status.jvm.memory.metaspace.used")
	m.data.SetDescription("The amount of memory currently used in the Metaspace memory pool.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkTaskmanagerStatusJvmMemoryMetaspaceUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostAttributeValue string, taskmanagerIDAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Host, pcommon.NewValueString(hostAttributeValue))
	dp.Attributes().Insert(A.TaskmanagerID, pcommon.NewValueString(taskmanagerIDAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkTaskmanagerStatusJvmMemoryMetaspaceUsed) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkTaskmanagerStatusJvmMemoryMetaspaceUsed) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkTaskmanagerStatusJvmMemoryMetaspaceUsed(settings MetricSettings) metricFlinkTaskmanagerStatusJvmMemoryMetaspaceUsed {
	m := metricFlinkTaskmanagerStatusJvmMemoryMetaspaceUsed{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkTaskmanagerStatusJvmMemoryNonHeapCommitted struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.taskmanager.status.jvm.memory.non_heap.committed metric with initial data.
func (m *metricFlinkTaskmanagerStatusJvmMemoryNonHeapCommitted) init() {
	m.data.SetName("flink.taskmanager.status.jvm.memory.non_heap.committed")
	m.data.SetDescription("The amount of non-heap memory guaranteed to be available to the JVM.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkTaskmanagerStatusJvmMemoryNonHeapCommitted) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostAttributeValue string, taskmanagerIDAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Host, pcommon.NewValueString(hostAttributeValue))
	dp.Attributes().Insert(A.TaskmanagerID, pcommon.NewValueString(taskmanagerIDAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkTaskmanagerStatusJvmMemoryNonHeapCommitted) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkTaskmanagerStatusJvmMemoryNonHeapCommitted) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkTaskmanagerStatusJvmMemoryNonHeapCommitted(settings MetricSettings) metricFlinkTaskmanagerStatusJvmMemoryNonHeapCommitted {
	m := metricFlinkTaskmanagerStatusJvmMemoryNonHeapCommitted{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkTaskmanagerStatusJvmMemoryNonHeapMax struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.taskmanager.status.jvm.memory.non_heap.max metric with initial data.
func (m *metricFlinkTaskmanagerStatusJvmMemoryNonHeapMax) init() {
	m.data.SetName("flink.taskmanager.status.jvm.memory.non_heap.max")
	m.data.SetDescription("The maximum amount of non-heap memory that can be used for memory management.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkTaskmanagerStatusJvmMemoryNonHeapMax) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostAttributeValue string, taskmanagerIDAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Host, pcommon.NewValueString(hostAttributeValue))
	dp.Attributes().Insert(A.TaskmanagerID, pcommon.NewValueString(taskmanagerIDAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkTaskmanagerStatusJvmMemoryNonHeapMax) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkTaskmanagerStatusJvmMemoryNonHeapMax) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkTaskmanagerStatusJvmMemoryNonHeapMax(settings MetricSettings) metricFlinkTaskmanagerStatusJvmMemoryNonHeapMax {
	m := metricFlinkTaskmanagerStatusJvmMemoryNonHeapMax{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkTaskmanagerStatusJvmMemoryNonHeapUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.taskmanager.status.jvm.memory.non_heap.used metric with initial data.
func (m *metricFlinkTaskmanagerStatusJvmMemoryNonHeapUsed) init() {
	m.data.SetName("flink.taskmanager.status.jvm.memory.non_heap.used")
	m.data.SetDescription("The amount of non-heap memory currently used.")
	m.data.SetUnit("bytes")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkTaskmanagerStatusJvmMemoryNonHeapUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostAttributeValue string, taskmanagerIDAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Host, pcommon.NewValueString(hostAttributeValue))
	dp.Attributes().Insert(A.TaskmanagerID, pcommon.NewValueString(taskmanagerIDAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkTaskmanagerStatusJvmMemoryNonHeapUsed) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkTaskmanagerStatusJvmMemoryNonHeapUsed) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkTaskmanagerStatusJvmMemoryNonHeapUsed(settings MetricSettings) metricFlinkTaskmanagerStatusJvmMemoryNonHeapUsed {
	m := metricFlinkTaskmanagerStatusJvmMemoryNonHeapUsed{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFlinkTaskmanagerStatusJvmThreadsCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills flink.taskmanager.status.jvm.threads.count metric with initial data.
func (m *metricFlinkTaskmanagerStatusJvmThreadsCount) init() {
	m.data.SetName("flink.taskmanager.status.jvm.threads.count")
	m.data.SetDescription("The total number of live threads.")
	m.data.SetUnit("{threads}")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFlinkTaskmanagerStatusJvmThreadsCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostAttributeValue string, taskmanagerIDAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Host, pcommon.NewValueString(hostAttributeValue))
	dp.Attributes().Insert(A.TaskmanagerID, pcommon.NewValueString(taskmanagerIDAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFlinkTaskmanagerStatusJvmThreadsCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFlinkTaskmanagerStatusJvmThreadsCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFlinkTaskmanagerStatusJvmThreadsCount(settings MetricSettings) metricFlinkTaskmanagerStatusJvmThreadsCount {
	m := metricFlinkTaskmanagerStatusJvmThreadsCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

// MetricsBuilder provides an interface for scrapers to report metrics while taking care of all the transformations
// required to produce metric representation defined in metadata and user settings.
type MetricsBuilder struct {
	startTime                                                      pcommon.Timestamp // start time that will be applied to all recorded data points.
	metricsCapacity                                                int               // maximum observed number of metrics per resource.
	resourceCapacity                                               int               // maximum observed number of resource attributes.
	metricsBuffer                                                  pmetric.Metrics   // accumulates metrics data before emitting.
	metricFlinkJobCheckpointsCount                                 metricFlinkJobCheckpointsCount
	metricFlinkJobLastCheckpointSize                               metricFlinkJobLastCheckpointSize
	metricFlinkJobLastCheckpointTime                               metricFlinkJobLastCheckpointTime
	metricFlinkJobRestartCount                                     metricFlinkJobRestartCount
	metricFlinkJobmanagerStatusFlinkMemoryManagedTotal             metricFlinkJobmanagerStatusFlinkMemoryManagedTotal
	metricFlinkJobmanagerStatusFlinkMemoryManagedUsed              metricFlinkJobmanagerStatusFlinkMemoryManagedUsed
	metricFlinkJobmanagerStatusJvmClassLoaderClassesLoaded         metricFlinkJobmanagerStatusJvmClassLoaderClassesLoaded
	metricFlinkJobmanagerStatusJvmCPULoad                          metricFlinkJobmanagerStatusJvmCPULoad
	metricFlinkJobmanagerStatusJvmCPUTime                          metricFlinkJobmanagerStatusJvmCPUTime
	metricFlinkJobmanagerStatusJvmGarbageCollectorCollectionCount  metricFlinkJobmanagerStatusJvmGarbageCollectorCollectionCount
	metricFlinkJobmanagerStatusJvmGarbageCollectorCollectionTime   metricFlinkJobmanagerStatusJvmGarbageCollectorCollectionTime
	metricFlinkJobmanagerStatusJvmMemoryDirectTotalCapacity        metricFlinkJobmanagerStatusJvmMemoryDirectTotalCapacity
	metricFlinkJobmanagerStatusJvmMemoryDirectUsed                 metricFlinkJobmanagerStatusJvmMemoryDirectUsed
	metricFlinkJobmanagerStatusJvmMemoryHeapCommitted              metricFlinkJobmanagerStatusJvmMemoryHeapCommitted
	metricFlinkJobmanagerStatusJvmMemoryHeapMax                    metricFlinkJobmanagerStatusJvmMemoryHeapMax
	metricFlinkJobmanagerStatusJvmMemoryHeapUsed                   metricFlinkJobmanagerStatusJvmMemoryHeapUsed
	metricFlinkJobmanagerStatusJvmMemoryMappedTotalCapacity        metricFlinkJobmanagerStatusJvmMemoryMappedTotalCapacity
	metricFlinkJobmanagerStatusJvmMemoryMappedUsed                 metricFlinkJobmanagerStatusJvmMemoryMappedUsed
	metricFlinkJobmanagerStatusJvmMemoryMetaspaceCommitted         metricFlinkJobmanagerStatusJvmMemoryMetaspaceCommitted
	metricFlinkJobmanagerStatusJvmMemoryMetaspaceMax               metricFlinkJobmanagerStatusJvmMemoryMetaspaceMax
	metricFlinkJobmanagerStatusJvmMemoryMetaspaceUsed              metricFlinkJobmanagerStatusJvmMemoryMetaspaceUsed
	metricFlinkJobmanagerStatusJvmMemoryNonHeapCommitted           metricFlinkJobmanagerStatusJvmMemoryNonHeapCommitted
	metricFlinkJobmanagerStatusJvmMemoryNonHeapMax                 metricFlinkJobmanagerStatusJvmMemoryNonHeapMax
	metricFlinkJobmanagerStatusJvmMemoryNonHeapUsed                metricFlinkJobmanagerStatusJvmMemoryNonHeapUsed
	metricFlinkJobmanagerStatusJvmThreadsCount                     metricFlinkJobmanagerStatusJvmThreadsCount
	metricFlinkOperatorRecordCount                                 metricFlinkOperatorRecordCount
	metricFlinkOperatorWatermarkOutput                             metricFlinkOperatorWatermarkOutput
	metricFlinkTaskRecordCount                                     metricFlinkTaskRecordCount
	metricFlinkTaskmanagerStatusFlinkMemoryManagedTotal            metricFlinkTaskmanagerStatusFlinkMemoryManagedTotal
	metricFlinkTaskmanagerStatusFlinkMemoryManagedUsed             metricFlinkTaskmanagerStatusFlinkMemoryManagedUsed
	metricFlinkTaskmanagerStatusJvmClassLoaderClassesLoaded        metricFlinkTaskmanagerStatusJvmClassLoaderClassesLoaded
	metricFlinkTaskmanagerStatusJvmCPULoad                         metricFlinkTaskmanagerStatusJvmCPULoad
	metricFlinkTaskmanagerStatusJvmCPUTime                         metricFlinkTaskmanagerStatusJvmCPUTime
	metricFlinkTaskmanagerStatusJvmGarbageCollectorCollectionCount metricFlinkTaskmanagerStatusJvmGarbageCollectorCollectionCount
	metricFlinkTaskmanagerStatusJvmGarbageCollectorCollectionTime  metricFlinkTaskmanagerStatusJvmGarbageCollectorCollectionTime
	metricFlinkTaskmanagerStatusJvmMemoryDirectTotalCapacity       metricFlinkTaskmanagerStatusJvmMemoryDirectTotalCapacity
	metricFlinkTaskmanagerStatusJvmMemoryDirectUsed                metricFlinkTaskmanagerStatusJvmMemoryDirectUsed
	metricFlinkTaskmanagerStatusJvmMemoryHeapCommitted             metricFlinkTaskmanagerStatusJvmMemoryHeapCommitted
	metricFlinkTaskmanagerStatusJvmMemoryHeapMax                   metricFlinkTaskmanagerStatusJvmMemoryHeapMax
	metricFlinkTaskmanagerStatusJvmMemoryHeapUsed                  metricFlinkTaskmanagerStatusJvmMemoryHeapUsed
	metricFlinkTaskmanagerStatusJvmMemoryMappedTotalCapacity       metricFlinkTaskmanagerStatusJvmMemoryMappedTotalCapacity
	metricFlinkTaskmanagerStatusJvmMemoryMappedUsed                metricFlinkTaskmanagerStatusJvmMemoryMappedUsed
	metricFlinkTaskmanagerStatusJvmMemoryMetaspaceCommitted        metricFlinkTaskmanagerStatusJvmMemoryMetaspaceCommitted
	metricFlinkTaskmanagerStatusJvmMemoryMetaspaceMax              metricFlinkTaskmanagerStatusJvmMemoryMetaspaceMax
	metricFlinkTaskmanagerStatusJvmMemoryMetaspaceUsed             metricFlinkTaskmanagerStatusJvmMemoryMetaspaceUsed
	metricFlinkTaskmanagerStatusJvmMemoryNonHeapCommitted          metricFlinkTaskmanagerStatusJvmMemoryNonHeapCommitted
	metricFlinkTaskmanagerStatusJvmMemoryNonHeapMax                metricFlinkTaskmanagerStatusJvmMemoryNonHeapMax
	metricFlinkTaskmanagerStatusJvmMemoryNonHeapUsed               metricFlinkTaskmanagerStatusJvmMemoryNonHeapUsed
	metricFlinkTaskmanagerStatusJvmThreadsCount                    metricFlinkTaskmanagerStatusJvmThreadsCount
}

// metricBuilderOption applies changes to default metrics builder.
type metricBuilderOption func(*MetricsBuilder)

// WithStartTime sets startTime on the metrics builder.
func WithStartTime(startTime pcommon.Timestamp) metricBuilderOption {
	return func(mb *MetricsBuilder) {
		mb.startTime = startTime
	}
}

func NewMetricsBuilder(settings MetricsSettings, options ...metricBuilderOption) *MetricsBuilder {
	mb := &MetricsBuilder{
		startTime:                                                      pcommon.NewTimestampFromTime(time.Now()),
		metricsBuffer:                                                  pmetric.NewMetrics(),
		metricFlinkJobCheckpointsCount:                                 newMetricFlinkJobCheckpointsCount(settings.FlinkJobCheckpointsCount),
		metricFlinkJobLastCheckpointSize:                               newMetricFlinkJobLastCheckpointSize(settings.FlinkJobLastCheckpointSize),
		metricFlinkJobLastCheckpointTime:                               newMetricFlinkJobLastCheckpointTime(settings.FlinkJobLastCheckpointTime),
		metricFlinkJobRestartCount:                                     newMetricFlinkJobRestartCount(settings.FlinkJobRestartCount),
		metricFlinkJobmanagerStatusFlinkMemoryManagedTotal:             newMetricFlinkJobmanagerStatusFlinkMemoryManagedTotal(settings.FlinkJobmanagerStatusFlinkMemoryManagedTotal),
		metricFlinkJobmanagerStatusFlinkMemoryManagedUsed:              newMetricFlinkJobmanagerStatusFlinkMemoryManagedUsed(settings.FlinkJobmanagerStatusFlinkMemoryManagedUsed),
		metricFlinkJobmanagerStatusJvmClassLoaderClassesLoaded:         newMetricFlinkJobmanagerStatusJvmClassLoaderClassesLoaded(settings.FlinkJobmanagerStatusJvmClassLoaderClassesLoaded),
		metricFlinkJobmanagerStatusJvmCPULoad:                          newMetricFlinkJobmanagerStatusJvmCPULoad(settings.FlinkJobmanagerStatusJvmCPULoad),
		metricFlinkJobmanagerStatusJvmCPUTime:                          newMetricFlinkJobmanagerStatusJvmCPUTime(settings.FlinkJobmanagerStatusJvmCPUTime),
		metricFlinkJobmanagerStatusJvmGarbageCollectorCollectionCount:  newMetricFlinkJobmanagerStatusJvmGarbageCollectorCollectionCount(settings.FlinkJobmanagerStatusJvmGarbageCollectorCollectionCount),
		metricFlinkJobmanagerStatusJvmGarbageCollectorCollectionTime:   newMetricFlinkJobmanagerStatusJvmGarbageCollectorCollectionTime(settings.FlinkJobmanagerStatusJvmGarbageCollectorCollectionTime),
		metricFlinkJobmanagerStatusJvmMemoryDirectTotalCapacity:        newMetricFlinkJobmanagerStatusJvmMemoryDirectTotalCapacity(settings.FlinkJobmanagerStatusJvmMemoryDirectTotalCapacity),
		metricFlinkJobmanagerStatusJvmMemoryDirectUsed:                 newMetricFlinkJobmanagerStatusJvmMemoryDirectUsed(settings.FlinkJobmanagerStatusJvmMemoryDirectUsed),
		metricFlinkJobmanagerStatusJvmMemoryHeapCommitted:              newMetricFlinkJobmanagerStatusJvmMemoryHeapCommitted(settings.FlinkJobmanagerStatusJvmMemoryHeapCommitted),
		metricFlinkJobmanagerStatusJvmMemoryHeapMax:                    newMetricFlinkJobmanagerStatusJvmMemoryHeapMax(settings.FlinkJobmanagerStatusJvmMemoryHeapMax),
		metricFlinkJobmanagerStatusJvmMemoryHeapUsed:                   newMetricFlinkJobmanagerStatusJvmMemoryHeapUsed(settings.FlinkJobmanagerStatusJvmMemoryHeapUsed),
		metricFlinkJobmanagerStatusJvmMemoryMappedTotalCapacity:        newMetricFlinkJobmanagerStatusJvmMemoryMappedTotalCapacity(settings.FlinkJobmanagerStatusJvmMemoryMappedTotalCapacity),
		metricFlinkJobmanagerStatusJvmMemoryMappedUsed:                 newMetricFlinkJobmanagerStatusJvmMemoryMappedUsed(settings.FlinkJobmanagerStatusJvmMemoryMappedUsed),
		metricFlinkJobmanagerStatusJvmMemoryMetaspaceCommitted:         newMetricFlinkJobmanagerStatusJvmMemoryMetaspaceCommitted(settings.FlinkJobmanagerStatusJvmMemoryMetaspaceCommitted),
		metricFlinkJobmanagerStatusJvmMemoryMetaspaceMax:               newMetricFlinkJobmanagerStatusJvmMemoryMetaspaceMax(settings.FlinkJobmanagerStatusJvmMemoryMetaspaceMax),
		metricFlinkJobmanagerStatusJvmMemoryMetaspaceUsed:              newMetricFlinkJobmanagerStatusJvmMemoryMetaspaceUsed(settings.FlinkJobmanagerStatusJvmMemoryMetaspaceUsed),
		metricFlinkJobmanagerStatusJvmMemoryNonHeapCommitted:           newMetricFlinkJobmanagerStatusJvmMemoryNonHeapCommitted(settings.FlinkJobmanagerStatusJvmMemoryNonHeapCommitted),
		metricFlinkJobmanagerStatusJvmMemoryNonHeapMax:                 newMetricFlinkJobmanagerStatusJvmMemoryNonHeapMax(settings.FlinkJobmanagerStatusJvmMemoryNonHeapMax),
		metricFlinkJobmanagerStatusJvmMemoryNonHeapUsed:                newMetricFlinkJobmanagerStatusJvmMemoryNonHeapUsed(settings.FlinkJobmanagerStatusJvmMemoryNonHeapUsed),
		metricFlinkJobmanagerStatusJvmThreadsCount:                     newMetricFlinkJobmanagerStatusJvmThreadsCount(settings.FlinkJobmanagerStatusJvmThreadsCount),
		metricFlinkOperatorRecordCount:                                 newMetricFlinkOperatorRecordCount(settings.FlinkOperatorRecordCount),
		metricFlinkOperatorWatermarkOutput:                             newMetricFlinkOperatorWatermarkOutput(settings.FlinkOperatorWatermarkOutput),
		metricFlinkTaskRecordCount:                                     newMetricFlinkTaskRecordCount(settings.FlinkTaskRecordCount),
		metricFlinkTaskmanagerStatusFlinkMemoryManagedTotal:            newMetricFlinkTaskmanagerStatusFlinkMemoryManagedTotal(settings.FlinkTaskmanagerStatusFlinkMemoryManagedTotal),
		metricFlinkTaskmanagerStatusFlinkMemoryManagedUsed:             newMetricFlinkTaskmanagerStatusFlinkMemoryManagedUsed(settings.FlinkTaskmanagerStatusFlinkMemoryManagedUsed),
		metricFlinkTaskmanagerStatusJvmClassLoaderClassesLoaded:        newMetricFlinkTaskmanagerStatusJvmClassLoaderClassesLoaded(settings.FlinkTaskmanagerStatusJvmClassLoaderClassesLoaded),
		metricFlinkTaskmanagerStatusJvmCPULoad:                         newMetricFlinkTaskmanagerStatusJvmCPULoad(settings.FlinkTaskmanagerStatusJvmCPULoad),
		metricFlinkTaskmanagerStatusJvmCPUTime:                         newMetricFlinkTaskmanagerStatusJvmCPUTime(settings.FlinkTaskmanagerStatusJvmCPUTime),
		metricFlinkTaskmanagerStatusJvmGarbageCollectorCollectionCount: newMetricFlinkTaskmanagerStatusJvmGarbageCollectorCollectionCount(settings.FlinkTaskmanagerStatusJvmGarbageCollectorCollectionCount),
		metricFlinkTaskmanagerStatusJvmGarbageCollectorCollectionTime:  newMetricFlinkTaskmanagerStatusJvmGarbageCollectorCollectionTime(settings.FlinkTaskmanagerStatusJvmGarbageCollectorCollectionTime),
		metricFlinkTaskmanagerStatusJvmMemoryDirectTotalCapacity:       newMetricFlinkTaskmanagerStatusJvmMemoryDirectTotalCapacity(settings.FlinkTaskmanagerStatusJvmMemoryDirectTotalCapacity),
		metricFlinkTaskmanagerStatusJvmMemoryDirectUsed:                newMetricFlinkTaskmanagerStatusJvmMemoryDirectUsed(settings.FlinkTaskmanagerStatusJvmMemoryDirectUsed),
		metricFlinkTaskmanagerStatusJvmMemoryHeapCommitted:             newMetricFlinkTaskmanagerStatusJvmMemoryHeapCommitted(settings.FlinkTaskmanagerStatusJvmMemoryHeapCommitted),
		metricFlinkTaskmanagerStatusJvmMemoryHeapMax:                   newMetricFlinkTaskmanagerStatusJvmMemoryHeapMax(settings.FlinkTaskmanagerStatusJvmMemoryHeapMax),
		metricFlinkTaskmanagerStatusJvmMemoryHeapUsed:                  newMetricFlinkTaskmanagerStatusJvmMemoryHeapUsed(settings.FlinkTaskmanagerStatusJvmMemoryHeapUsed),
		metricFlinkTaskmanagerStatusJvmMemoryMappedTotalCapacity:       newMetricFlinkTaskmanagerStatusJvmMemoryMappedTotalCapacity(settings.FlinkTaskmanagerStatusJvmMemoryMappedTotalCapacity),
		metricFlinkTaskmanagerStatusJvmMemoryMappedUsed:                newMetricFlinkTaskmanagerStatusJvmMemoryMappedUsed(settings.FlinkTaskmanagerStatusJvmMemoryMappedUsed),
		metricFlinkTaskmanagerStatusJvmMemoryMetaspaceCommitted:        newMetricFlinkTaskmanagerStatusJvmMemoryMetaspaceCommitted(settings.FlinkTaskmanagerStatusJvmMemoryMetaspaceCommitted),
		metricFlinkTaskmanagerStatusJvmMemoryMetaspaceMax:              newMetricFlinkTaskmanagerStatusJvmMemoryMetaspaceMax(settings.FlinkTaskmanagerStatusJvmMemoryMetaspaceMax),
		metricFlinkTaskmanagerStatusJvmMemoryMetaspaceUsed:             newMetricFlinkTaskmanagerStatusJvmMemoryMetaspaceUsed(settings.FlinkTaskmanagerStatusJvmMemoryMetaspaceUsed),
		metricFlinkTaskmanagerStatusJvmMemoryNonHeapCommitted:          newMetricFlinkTaskmanagerStatusJvmMemoryNonHeapCommitted(settings.FlinkTaskmanagerStatusJvmMemoryNonHeapCommitted),
		metricFlinkTaskmanagerStatusJvmMemoryNonHeapMax:                newMetricFlinkTaskmanagerStatusJvmMemoryNonHeapMax(settings.FlinkTaskmanagerStatusJvmMemoryNonHeapMax),
		metricFlinkTaskmanagerStatusJvmMemoryNonHeapUsed:               newMetricFlinkTaskmanagerStatusJvmMemoryNonHeapUsed(settings.FlinkTaskmanagerStatusJvmMemoryNonHeapUsed),
		metricFlinkTaskmanagerStatusJvmThreadsCount:                    newMetricFlinkTaskmanagerStatusJvmThreadsCount(settings.FlinkTaskmanagerStatusJvmThreadsCount),
	}
	for _, op := range options {
		op(mb)
	}
	return mb
}

// updateCapacity updates max length of metrics and resource attributes that will be used for the slice capacity.
func (mb *MetricsBuilder) updateCapacity(rm pmetric.ResourceMetrics) {
	if mb.metricsCapacity < rm.ScopeMetrics().At(0).Metrics().Len() {
		mb.metricsCapacity = rm.ScopeMetrics().At(0).Metrics().Len()
	}
	if mb.resourceCapacity < rm.Resource().Attributes().Len() {
		mb.resourceCapacity = rm.Resource().Attributes().Len()
	}
}

// ResourceOption applies changes to provided resource.
type ResourceOption func(pcommon.Resource)

// EmitForResource saves all the generated metrics under a new resource and updates the internal state to be ready for
// recording another set of data points as part of another resource. This function can be helpful when one scraper
// needs to emit metrics from several resources. Otherwise calling this function is not required,
// just `Emit` function can be called instead. Resource attributes should be provided as ResourceOption arguments.
func (mb *MetricsBuilder) EmitForResource(ro ...ResourceOption) {
	rm := pmetric.NewResourceMetrics()
	rm.Resource().Attributes().EnsureCapacity(mb.resourceCapacity)
	for _, op := range ro {
		op(rm.Resource())
	}
	ils := rm.ScopeMetrics().AppendEmpty()
	ils.Scope().SetName("otelcol/flinkreceiver")
	ils.Metrics().EnsureCapacity(mb.metricsCapacity)
	mb.metricFlinkJobCheckpointsCount.emit(ils.Metrics())
	mb.metricFlinkJobLastCheckpointSize.emit(ils.Metrics())
	mb.metricFlinkJobLastCheckpointTime.emit(ils.Metrics())
	mb.metricFlinkJobRestartCount.emit(ils.Metrics())
	mb.metricFlinkJobmanagerStatusFlinkMemoryManagedTotal.emit(ils.Metrics())
	mb.metricFlinkJobmanagerStatusFlinkMemoryManagedUsed.emit(ils.Metrics())
	mb.metricFlinkJobmanagerStatusJvmClassLoaderClassesLoaded.emit(ils.Metrics())
	mb.metricFlinkJobmanagerStatusJvmCPULoad.emit(ils.Metrics())
	mb.metricFlinkJobmanagerStatusJvmCPUTime.emit(ils.Metrics())
	mb.metricFlinkJobmanagerStatusJvmGarbageCollectorCollectionCount.emit(ils.Metrics())
	mb.metricFlinkJobmanagerStatusJvmGarbageCollectorCollectionTime.emit(ils.Metrics())
	mb.metricFlinkJobmanagerStatusJvmMemoryDirectTotalCapacity.emit(ils.Metrics())
	mb.metricFlinkJobmanagerStatusJvmMemoryDirectUsed.emit(ils.Metrics())
	mb.metricFlinkJobmanagerStatusJvmMemoryHeapCommitted.emit(ils.Metrics())
	mb.metricFlinkJobmanagerStatusJvmMemoryHeapMax.emit(ils.Metrics())
	mb.metricFlinkJobmanagerStatusJvmMemoryHeapUsed.emit(ils.Metrics())
	mb.metricFlinkJobmanagerStatusJvmMemoryMappedTotalCapacity.emit(ils.Metrics())
	mb.metricFlinkJobmanagerStatusJvmMemoryMappedUsed.emit(ils.Metrics())
	mb.metricFlinkJobmanagerStatusJvmMemoryMetaspaceCommitted.emit(ils.Metrics())
	mb.metricFlinkJobmanagerStatusJvmMemoryMetaspaceMax.emit(ils.Metrics())
	mb.metricFlinkJobmanagerStatusJvmMemoryMetaspaceUsed.emit(ils.Metrics())
	mb.metricFlinkJobmanagerStatusJvmMemoryNonHeapCommitted.emit(ils.Metrics())
	mb.metricFlinkJobmanagerStatusJvmMemoryNonHeapMax.emit(ils.Metrics())
	mb.metricFlinkJobmanagerStatusJvmMemoryNonHeapUsed.emit(ils.Metrics())
	mb.metricFlinkJobmanagerStatusJvmThreadsCount.emit(ils.Metrics())
	mb.metricFlinkOperatorRecordCount.emit(ils.Metrics())
	mb.metricFlinkOperatorWatermarkOutput.emit(ils.Metrics())
	mb.metricFlinkTaskRecordCount.emit(ils.Metrics())
	mb.metricFlinkTaskmanagerStatusFlinkMemoryManagedTotal.emit(ils.Metrics())
	mb.metricFlinkTaskmanagerStatusFlinkMemoryManagedUsed.emit(ils.Metrics())
	mb.metricFlinkTaskmanagerStatusJvmClassLoaderClassesLoaded.emit(ils.Metrics())
	mb.metricFlinkTaskmanagerStatusJvmCPULoad.emit(ils.Metrics())
	mb.metricFlinkTaskmanagerStatusJvmCPUTime.emit(ils.Metrics())
	mb.metricFlinkTaskmanagerStatusJvmGarbageCollectorCollectionCount.emit(ils.Metrics())
	mb.metricFlinkTaskmanagerStatusJvmGarbageCollectorCollectionTime.emit(ils.Metrics())
	mb.metricFlinkTaskmanagerStatusJvmMemoryDirectTotalCapacity.emit(ils.Metrics())
	mb.metricFlinkTaskmanagerStatusJvmMemoryDirectUsed.emit(ils.Metrics())
	mb.metricFlinkTaskmanagerStatusJvmMemoryHeapCommitted.emit(ils.Metrics())
	mb.metricFlinkTaskmanagerStatusJvmMemoryHeapMax.emit(ils.Metrics())
	mb.metricFlinkTaskmanagerStatusJvmMemoryHeapUsed.emit(ils.Metrics())
	mb.metricFlinkTaskmanagerStatusJvmMemoryMappedTotalCapacity.emit(ils.Metrics())
	mb.metricFlinkTaskmanagerStatusJvmMemoryMappedUsed.emit(ils.Metrics())
	mb.metricFlinkTaskmanagerStatusJvmMemoryMetaspaceCommitted.emit(ils.Metrics())
	mb.metricFlinkTaskmanagerStatusJvmMemoryMetaspaceMax.emit(ils.Metrics())
	mb.metricFlinkTaskmanagerStatusJvmMemoryMetaspaceUsed.emit(ils.Metrics())
	mb.metricFlinkTaskmanagerStatusJvmMemoryNonHeapCommitted.emit(ils.Metrics())
	mb.metricFlinkTaskmanagerStatusJvmMemoryNonHeapMax.emit(ils.Metrics())
	mb.metricFlinkTaskmanagerStatusJvmMemoryNonHeapUsed.emit(ils.Metrics())
	mb.metricFlinkTaskmanagerStatusJvmThreadsCount.emit(ils.Metrics())
	if ils.Metrics().Len() > 0 {
		mb.updateCapacity(rm)
		rm.MoveTo(mb.metricsBuffer.ResourceMetrics().AppendEmpty())
	}
}

// Emit returns all the metrics accumulated by the metrics builder and updates the internal state to be ready for
// recording another set of metrics. This function will be responsible for applying all the transformations required to
// produce metric representation defined in metadata and user settings, e.g. delta or cumulative.
func (mb *MetricsBuilder) Emit(ro ...ResourceOption) pmetric.Metrics {
	mb.EmitForResource(ro...)
	metrics := pmetric.NewMetrics()
	mb.metricsBuffer.MoveTo(metrics)
	return metrics
}

// RecordFlinkJobCheckpointsCountDataPoint adds a data point to flink.job.checkpoints.count metric.
func (mb *MetricsBuilder) RecordFlinkJobCheckpointsCountDataPoint(ts pcommon.Timestamp, val string, hostAttributeValue string, jobNameAttributeValue string, checkpointAttributeValue AttributeCheckpoint) error {
	if i, err := strconv.ParseInt(val, 10, 64); err != nil {
		return fmt.Errorf("failed to parse int for FlinkJobCheckpointsCount, value was %s: %w", val, err)
	} else {
		mb.metricFlinkJobCheckpointsCount.recordDataPoint(mb.startTime, ts, i, hostAttributeValue, jobNameAttributeValue, checkpointAttributeValue.String())
	}
	return nil
}

// RecordFlinkJobLastCheckpointSizeDataPoint adds a data point to flink.job.last_checkpoint.size metric.
func (mb *MetricsBuilder) RecordFlinkJobLastCheckpointSizeDataPoint(ts pcommon.Timestamp, val string, hostAttributeValue string, jobNameAttributeValue string) error {
	if i, err := strconv.ParseInt(val, 10, 64); err != nil {
		return fmt.Errorf("failed to parse int for FlinkJobLastCheckpointSize, value was %s: %w", val, err)
	} else {
		mb.metricFlinkJobLastCheckpointSize.recordDataPoint(mb.startTime, ts, i, hostAttributeValue, jobNameAttributeValue)
	}
	return nil
}

// RecordFlinkJobLastCheckpointTimeDataPoint adds a data point to flink.job.last_checkpoint.time metric.
func (mb *MetricsBuilder) RecordFlinkJobLastCheckpointTimeDataPoint(ts pcommon.Timestamp, val string, hostAttributeValue string, jobNameAttributeValue string) error {
	if i, err := strconv.ParseInt(val, 10, 64); err != nil {
		return fmt.Errorf("failed to parse int for FlinkJobLastCheckpointTime, value was %s: %w", val, err)
	} else {
		mb.metricFlinkJobLastCheckpointTime.recordDataPoint(mb.startTime, ts, i, hostAttributeValue, jobNameAttributeValue)
	}
	return nil
}

// RecordFlinkJobRestartCountDataPoint adds a data point to flink.job.restart.count metric.
func (mb *MetricsBuilder) RecordFlinkJobRestartCountDataPoint(ts pcommon.Timestamp, val string, hostAttributeValue string, jobNameAttributeValue string) error {
	if i, err := strconv.ParseInt(val, 10, 64); err != nil {
		return fmt.Errorf("failed to parse int for FlinkJobRestartCount, value was %s: %w", val, err)
	} else {
		mb.metricFlinkJobRestartCount.recordDataPoint(mb.startTime, ts, i, hostAttributeValue, jobNameAttributeValue)
	}
	return nil
}

// RecordFlinkJobmanagerStatusFlinkMemoryManagedTotalDataPoint adds a data point to flink.jobmanager.status.flink.memory.managed.total metric.
func (mb *MetricsBuilder) RecordFlinkJobmanagerStatusFlinkMemoryManagedTotalDataPoint(ts pcommon.Timestamp, val string, hostAttributeValue string) error {
	if i, err := strconv.ParseInt(val, 10, 64); err != nil {
		return fmt.Errorf("failed to parse int for FlinkJobmanagerStatusFlinkMemoryManagedTotal, value was %s: %w", val, err)
	} else {
		mb.metricFlinkJobmanagerStatusFlinkMemoryManagedTotal.recordDataPoint(mb.startTime, ts, i, hostAttributeValue)
	}
	return nil
}

// RecordFlinkJobmanagerStatusFlinkMemoryManagedUsedDataPoint adds a data point to flink.jobmanager.status.flink.memory.managed.used metric.
func (mb *MetricsBuilder) RecordFlinkJobmanagerStatusFlinkMemoryManagedUsedDataPoint(ts pcommon.Timestamp, val string, hostAttributeValue string) error {
	if i, err := strconv.ParseInt(val, 10, 64); err != nil {
		return fmt.Errorf("failed to parse int for FlinkJobmanagerStatusFlinkMemoryManagedUsed, value was %s: %w", val, err)
	} else {
		mb.metricFlinkJobmanagerStatusFlinkMemoryManagedUsed.recordDataPoint(mb.startTime, ts, i, hostAttributeValue)
	}
	return nil
}

// RecordFlinkJobmanagerStatusJvmClassLoaderClassesLoadedDataPoint adds a data point to flink.jobmanager.status.jvm.class_loader.classes_loaded metric.
func (mb *MetricsBuilder) RecordFlinkJobmanagerStatusJvmClassLoaderClassesLoadedDataPoint(ts pcommon.Timestamp, val string, hostAttributeValue string) error {
	if i, err := strconv.ParseInt(val, 10, 64); err != nil {
		return fmt.Errorf("failed to parse int for FlinkJobmanagerStatusJvmClassLoaderClassesLoaded, value was %s: %w", val, err)
	} else {
		mb.metricFlinkJobmanagerStatusJvmClassLoaderClassesLoaded.recordDataPoint(mb.startTime, ts, i, hostAttributeValue)
	}
	return nil
}

// RecordFlinkJobmanagerStatusJvmCPULoadDataPoint adds a data point to flink.jobmanager.status.jvm.cpu.load metric.
func (mb *MetricsBuilder) RecordFlinkJobmanagerStatusJvmCPULoadDataPoint(ts pcommon.Timestamp, val string, hostAttributeValue string) error {
	if f, err := strconv.ParseFloat(val, 64); err != nil {
		return fmt.Errorf("failed to parse float for FlinkJobmanagerStatusJvmCPULoad, value was %s: %w", val, err)
	} else {
		mb.metricFlinkJobmanagerStatusJvmCPULoad.recordDataPoint(mb.startTime, ts, f, hostAttributeValue)
	}
	return nil
}

// RecordFlinkJobmanagerStatusJvmCPUTimeDataPoint adds a data point to flink.jobmanager.status.jvm.cpu.time metric.
func (mb *MetricsBuilder) RecordFlinkJobmanagerStatusJvmCPUTimeDataPoint(ts pcommon.Timestamp, val string, hostAttributeValue string) error {
	if i, err := strconv.ParseInt(val, 10, 64); err != nil {
		return fmt.Errorf("failed to parse int for FlinkJobmanagerStatusJvmCPUTime, value was %s: %w", val, err)
	} else {
		mb.metricFlinkJobmanagerStatusJvmCPUTime.recordDataPoint(mb.startTime, ts, i, hostAttributeValue)
	}
	return nil
}

// RecordFlinkJobmanagerStatusJvmGarbageCollectorCollectionCountDataPoint adds a data point to flink.jobmanager.status.jvm.garbage_collector.collection.count metric.
func (mb *MetricsBuilder) RecordFlinkJobmanagerStatusJvmGarbageCollectorCollectionCountDataPoint(ts pcommon.Timestamp, val string, hostAttributeValue string, garbageCollectorNameAttributeValue string) error {
	if i, err := strconv.ParseInt(val, 10, 64); err != nil {
		return fmt.Errorf("failed to parse int for FlinkJobmanagerStatusJvmGarbageCollectorCollectionCount, value was %s: %w", val, err)
	} else {
		mb.metricFlinkJobmanagerStatusJvmGarbageCollectorCollectionCount.recordDataPoint(mb.startTime, ts, i, hostAttributeValue, garbageCollectorNameAttributeValue)
	}
	return nil
}

// RecordFlinkJobmanagerStatusJvmGarbageCollectorCollectionTimeDataPoint adds a data point to flink.jobmanager.status.jvm.garbage_collector.collection.time metric.
func (mb *MetricsBuilder) RecordFlinkJobmanagerStatusJvmGarbageCollectorCollectionTimeDataPoint(ts pcommon.Timestamp, val string, hostAttributeValue string, garbageCollectorNameAttributeValue string) error {
	if i, err := strconv.ParseInt(val, 10, 64); err != nil {
		return fmt.Errorf("failed to parse int for FlinkJobmanagerStatusJvmGarbageCollectorCollectionTime, value was %s: %w", val, err)
	} else {
		mb.metricFlinkJobmanagerStatusJvmGarbageCollectorCollectionTime.recordDataPoint(mb.startTime, ts, i, hostAttributeValue, garbageCollectorNameAttributeValue)
	}
	return nil
}

// RecordFlinkJobmanagerStatusJvmMemoryDirectTotalCapacityDataPoint adds a data point to flink.jobmanager.status.jvm.memory.direct.total_capacity metric.
func (mb *MetricsBuilder) RecordFlinkJobmanagerStatusJvmMemoryDirectTotalCapacityDataPoint(ts pcommon.Timestamp, val string, hostAttributeValue string) error {
	if i, err := strconv.ParseInt(val, 10, 64); err != nil {
		return fmt.Errorf("failed to parse int for FlinkJobmanagerStatusJvmMemoryDirectTotalCapacity, value was %s: %w", val, err)
	} else {
		mb.metricFlinkJobmanagerStatusJvmMemoryDirectTotalCapacity.recordDataPoint(mb.startTime, ts, i, hostAttributeValue)
	}
	return nil
}

// RecordFlinkJobmanagerStatusJvmMemoryDirectUsedDataPoint adds a data point to flink.jobmanager.status.jvm.memory.direct.used metric.
func (mb *MetricsBuilder) RecordFlinkJobmanagerStatusJvmMemoryDirectUsedDataPoint(ts pcommon.Timestamp, val string, hostAttributeValue string) error {
	if i, err := strconv.ParseInt(val, 10, 64); err != nil {
		return fmt.Errorf("failed to parse int for FlinkJobmanagerStatusJvmMemoryDirectUsed, value was %s: %w", val, err)
	} else {
		mb.metricFlinkJobmanagerStatusJvmMemoryDirectUsed.recordDataPoint(mb.startTime, ts, i, hostAttributeValue)
	}
	return nil
}

// RecordFlinkJobmanagerStatusJvmMemoryHeapCommittedDataPoint adds a data point to flink.jobmanager.status.jvm.memory.heap.committed metric.
func (mb *MetricsBuilder) RecordFlinkJobmanagerStatusJvmMemoryHeapCommittedDataPoint(ts pcommon.Timestamp, val string, hostAttributeValue string) error {
	if i, err := strconv.ParseInt(val, 10, 64); err != nil {
		return fmt.Errorf("failed to parse int for FlinkJobmanagerStatusJvmMemoryHeapCommitted, value was %s: %w", val, err)
	} else {
		mb.metricFlinkJobmanagerStatusJvmMemoryHeapCommitted.recordDataPoint(mb.startTime, ts, i, hostAttributeValue)
	}
	return nil
}

// RecordFlinkJobmanagerStatusJvmMemoryHeapMaxDataPoint adds a data point to flink.jobmanager.status.jvm.memory.heap.max metric.
func (mb *MetricsBuilder) RecordFlinkJobmanagerStatusJvmMemoryHeapMaxDataPoint(ts pcommon.Timestamp, val string, hostAttributeValue string) error {
	if i, err := strconv.ParseInt(val, 10, 64); err != nil {
		return fmt.Errorf("failed to parse int for FlinkJobmanagerStatusJvmMemoryHeapMax, value was %s: %w", val, err)
	} else {
		mb.metricFlinkJobmanagerStatusJvmMemoryHeapMax.recordDataPoint(mb.startTime, ts, i, hostAttributeValue)
	}
	return nil
}

// RecordFlinkJobmanagerStatusJvmMemoryHeapUsedDataPoint adds a data point to flink.jobmanager.status.jvm.memory.heap.used metric.
func (mb *MetricsBuilder) RecordFlinkJobmanagerStatusJvmMemoryHeapUsedDataPoint(ts pcommon.Timestamp, val string, hostAttributeValue string) error {
	if i, err := strconv.ParseInt(val, 10, 64); err != nil {
		return fmt.Errorf("failed to parse int for FlinkJobmanagerStatusJvmMemoryHeapUsed, value was %s: %w", val, err)
	} else {
		mb.metricFlinkJobmanagerStatusJvmMemoryHeapUsed.recordDataPoint(mb.startTime, ts, i, hostAttributeValue)
	}
	return nil
}

// RecordFlinkJobmanagerStatusJvmMemoryMappedTotalCapacityDataPoint adds a data point to flink.jobmanager.status.jvm.memory.mapped.total_capacity metric.
func (mb *MetricsBuilder) RecordFlinkJobmanagerStatusJvmMemoryMappedTotalCapacityDataPoint(ts pcommon.Timestamp, val string, hostAttributeValue string) error {
	if i, err := strconv.ParseInt(val, 10, 64); err != nil {
		return fmt.Errorf("failed to parse int for FlinkJobmanagerStatusJvmMemoryMappedTotalCapacity, value was %s: %w", val, err)
	} else {
		mb.metricFlinkJobmanagerStatusJvmMemoryMappedTotalCapacity.recordDataPoint(mb.startTime, ts, i, hostAttributeValue)
	}
	return nil
}

// RecordFlinkJobmanagerStatusJvmMemoryMappedUsedDataPoint adds a data point to flink.jobmanager.status.jvm.memory.mapped.used metric.
func (mb *MetricsBuilder) RecordFlinkJobmanagerStatusJvmMemoryMappedUsedDataPoint(ts pcommon.Timestamp, val string, hostAttributeValue string) error {
	if i, err := strconv.ParseInt(val, 10, 64); err != nil {
		return fmt.Errorf("failed to parse int for FlinkJobmanagerStatusJvmMemoryMappedUsed, value was %s: %w", val, err)
	} else {
		mb.metricFlinkJobmanagerStatusJvmMemoryMappedUsed.recordDataPoint(mb.startTime, ts, i, hostAttributeValue)
	}
	return nil
}

// RecordFlinkJobmanagerStatusJvmMemoryMetaspaceCommittedDataPoint adds a data point to flink.jobmanager.status.jvm.memory.metaspace.committed metric.
func (mb *MetricsBuilder) RecordFlinkJobmanagerStatusJvmMemoryMetaspaceCommittedDataPoint(ts pcommon.Timestamp, val string, hostAttributeValue string) error {
	if i, err := strconv.ParseInt(val, 10, 64); err != nil {
		return fmt.Errorf("failed to parse int for FlinkJobmanagerStatusJvmMemoryMetaspaceCommitted, value was %s: %w", val, err)
	} else {
		mb.metricFlinkJobmanagerStatusJvmMemoryMetaspaceCommitted.recordDataPoint(mb.startTime, ts, i, hostAttributeValue)
	}
	return nil
}

// RecordFlinkJobmanagerStatusJvmMemoryMetaspaceMaxDataPoint adds a data point to flink.jobmanager.status.jvm.memory.metaspace.max metric.
func (mb *MetricsBuilder) RecordFlinkJobmanagerStatusJvmMemoryMetaspaceMaxDataPoint(ts pcommon.Timestamp, val string, hostAttributeValue string) error {
	if i, err := strconv.ParseInt(val, 10, 64); err != nil {
		return fmt.Errorf("failed to parse int for FlinkJobmanagerStatusJvmMemoryMetaspaceMax, value was %s: %w", val, err)
	} else {
		mb.metricFlinkJobmanagerStatusJvmMemoryMetaspaceMax.recordDataPoint(mb.startTime, ts, i, hostAttributeValue)
	}
	return nil
}

// RecordFlinkJobmanagerStatusJvmMemoryMetaspaceUsedDataPoint adds a data point to flink.jobmanager.status.jvm.memory.metaspace.used metric.
func (mb *MetricsBuilder) RecordFlinkJobmanagerStatusJvmMemoryMetaspaceUsedDataPoint(ts pcommon.Timestamp, val string, hostAttributeValue string) error {
	if i, err := strconv.ParseInt(val, 10, 64); err != nil {
		return fmt.Errorf("failed to parse int for FlinkJobmanagerStatusJvmMemoryMetaspaceUsed, value was %s: %w", val, err)
	} else {
		mb.metricFlinkJobmanagerStatusJvmMemoryMetaspaceUsed.recordDataPoint(mb.startTime, ts, i, hostAttributeValue)
	}
	return nil
}

// RecordFlinkJobmanagerStatusJvmMemoryNonHeapCommittedDataPoint adds a data point to flink.jobmanager.status.jvm.memory.non_heap.committed metric.
func (mb *MetricsBuilder) RecordFlinkJobmanagerStatusJvmMemoryNonHeapCommittedDataPoint(ts pcommon.Timestamp, val string, hostAttributeValue string) error {
	if i, err := strconv.ParseInt(val, 10, 64); err != nil {
		return fmt.Errorf("failed to parse int for FlinkJobmanagerStatusJvmMemoryNonHeapCommitted, value was %s: %w", val, err)
	} else {
		mb.metricFlinkJobmanagerStatusJvmMemoryNonHeapCommitted.recordDataPoint(mb.startTime, ts, i, hostAttributeValue)
	}
	return nil
}

// RecordFlinkJobmanagerStatusJvmMemoryNonHeapMaxDataPoint adds a data point to flink.jobmanager.status.jvm.memory.non_heap.max metric.
func (mb *MetricsBuilder) RecordFlinkJobmanagerStatusJvmMemoryNonHeapMaxDataPoint(ts pcommon.Timestamp, val string, hostAttributeValue string) error {
	if i, err := strconv.ParseInt(val, 10, 64); err != nil {
		return fmt.Errorf("failed to parse int for FlinkJobmanagerStatusJvmMemoryNonHeapMax, value was %s: %w", val, err)
	} else {
		mb.metricFlinkJobmanagerStatusJvmMemoryNonHeapMax.recordDataPoint(mb.startTime, ts, i, hostAttributeValue)
	}
	return nil
}

// RecordFlinkJobmanagerStatusJvmMemoryNonHeapUsedDataPoint adds a data point to flink.jobmanager.status.jvm.memory.non_heap.used metric.
func (mb *MetricsBuilder) RecordFlinkJobmanagerStatusJvmMemoryNonHeapUsedDataPoint(ts pcommon.Timestamp, val string, hostAttributeValue string) error {
	if i, err := strconv.ParseInt(val, 10, 64); err != nil {
		return fmt.Errorf("failed to parse int for FlinkJobmanagerStatusJvmMemoryNonHeapUsed, value was %s: %w", val, err)
	} else {
		mb.metricFlinkJobmanagerStatusJvmMemoryNonHeapUsed.recordDataPoint(mb.startTime, ts, i, hostAttributeValue)
	}
	return nil
}

// RecordFlinkJobmanagerStatusJvmThreadsCountDataPoint adds a data point to flink.jobmanager.status.jvm.threads.count metric.
func (mb *MetricsBuilder) RecordFlinkJobmanagerStatusJvmThreadsCountDataPoint(ts pcommon.Timestamp, val string, hostAttributeValue string) error {
	if i, err := strconv.ParseInt(val, 10, 64); err != nil {
		return fmt.Errorf("failed to parse int for FlinkJobmanagerStatusJvmThreadsCount, value was %s: %w", val, err)
	} else {
		mb.metricFlinkJobmanagerStatusJvmThreadsCount.recordDataPoint(mb.startTime, ts, i, hostAttributeValue)
	}
	return nil
}

// RecordFlinkOperatorRecordCountDataPoint adds a data point to flink.operator.record.count metric.
func (mb *MetricsBuilder) RecordFlinkOperatorRecordCountDataPoint(ts pcommon.Timestamp, val string, hostAttributeValue string, taskmanagerIDAttributeValue string, jobNameAttributeValue string, operatorNameAttributeValue string, subtaskIndexAttributeValue string, recordAttributeValue AttributeRecord) error {
	if i, err := strconv.ParseInt(val, 10, 64); err != nil {
		return fmt.Errorf("failed to parse int for FlinkOperatorRecordCount, value was %s: %w", val, err)
	} else {
		mb.metricFlinkOperatorRecordCount.recordDataPoint(mb.startTime, ts, i, hostAttributeValue, taskmanagerIDAttributeValue, jobNameAttributeValue, operatorNameAttributeValue, subtaskIndexAttributeValue, recordAttributeValue.String())
	}
	return nil
}

// RecordFlinkOperatorWatermarkOutputDataPoint adds a data point to flink.operator.watermark.output metric.
func (mb *MetricsBuilder) RecordFlinkOperatorWatermarkOutputDataPoint(ts pcommon.Timestamp, val string, hostAttributeValue string, taskmanagerIDAttributeValue string, jobNameAttributeValue string, operatorNameAttributeValue string, subtaskIndexAttributeValue string) error {
	if i, err := strconv.ParseInt(val, 10, 64); err != nil {
		return fmt.Errorf("failed to parse int for FlinkOperatorWatermarkOutput, value was %s: %w", val, err)
	} else {
		mb.metricFlinkOperatorWatermarkOutput.recordDataPoint(mb.startTime, ts, i, hostAttributeValue, taskmanagerIDAttributeValue, jobNameAttributeValue, operatorNameAttributeValue, subtaskIndexAttributeValue)
	}
	return nil
}

// RecordFlinkTaskRecordCountDataPoint adds a data point to flink.task.record.count metric.
func (mb *MetricsBuilder) RecordFlinkTaskRecordCountDataPoint(ts pcommon.Timestamp, val string, hostAttributeValue string, taskmanagerIDAttributeValue string, jobNameAttributeValue string, taskNameAttributeValue string, subtaskIndexAttributeValue string, recordAttributeValue AttributeRecord) error {
	if i, err := strconv.ParseInt(val, 10, 64); err != nil {
		return fmt.Errorf("failed to parse int for FlinkTaskRecordCount, value was %s: %w", val, err)
	} else {
		mb.metricFlinkTaskRecordCount.recordDataPoint(mb.startTime, ts, i, hostAttributeValue, taskmanagerIDAttributeValue, jobNameAttributeValue, taskNameAttributeValue, subtaskIndexAttributeValue, recordAttributeValue.String())
	}
	return nil
}

// RecordFlinkTaskmanagerStatusFlinkMemoryManagedTotalDataPoint adds a data point to flink.taskmanager.status.flink.memory.managed.total metric.
func (mb *MetricsBuilder) RecordFlinkTaskmanagerStatusFlinkMemoryManagedTotalDataPoint(ts pcommon.Timestamp, val string, hostAttributeValue string, taskmanagerIDAttributeValue string) error {
	if i, err := strconv.ParseInt(val, 10, 64); err != nil {
		return fmt.Errorf("failed to parse int for FlinkTaskmanagerStatusFlinkMemoryManagedTotal, value was %s: %w", val, err)
	} else {
		mb.metricFlinkTaskmanagerStatusFlinkMemoryManagedTotal.recordDataPoint(mb.startTime, ts, i, hostAttributeValue, taskmanagerIDAttributeValue)
	}
	return nil
}

// RecordFlinkTaskmanagerStatusFlinkMemoryManagedUsedDataPoint adds a data point to flink.taskmanager.status.flink.memory.managed.used metric.
func (mb *MetricsBuilder) RecordFlinkTaskmanagerStatusFlinkMemoryManagedUsedDataPoint(ts pcommon.Timestamp, val string, hostAttributeValue string, taskmanagerIDAttributeValue string) error {
	if i, err := strconv.ParseInt(val, 10, 64); err != nil {
		return fmt.Errorf("failed to parse int for FlinkTaskmanagerStatusFlinkMemoryManagedUsed, value was %s: %w", val, err)
	} else {
		mb.metricFlinkTaskmanagerStatusFlinkMemoryManagedUsed.recordDataPoint(mb.startTime, ts, i, hostAttributeValue, taskmanagerIDAttributeValue)
	}
	return nil
}

// RecordFlinkTaskmanagerStatusJvmClassLoaderClassesLoadedDataPoint adds a data point to flink.taskmanager.status.jvm.class_loader.classes_loaded metric.
func (mb *MetricsBuilder) RecordFlinkTaskmanagerStatusJvmClassLoaderClassesLoadedDataPoint(ts pcommon.Timestamp, val string, hostAttributeValue string, taskmanagerIDAttributeValue string) error {
	if i, err := strconv.ParseInt(val, 10, 64); err != nil {
		return fmt.Errorf("failed to parse int for FlinkTaskmanagerStatusJvmClassLoaderClassesLoaded, value was %s: %w", val, err)
	} else {
		mb.metricFlinkTaskmanagerStatusJvmClassLoaderClassesLoaded.recordDataPoint(mb.startTime, ts, i, hostAttributeValue, taskmanagerIDAttributeValue)
	}
	return nil
}

// RecordFlinkTaskmanagerStatusJvmCPULoadDataPoint adds a data point to flink.taskmanager.status.jvm.cpu.load metric.
func (mb *MetricsBuilder) RecordFlinkTaskmanagerStatusJvmCPULoadDataPoint(ts pcommon.Timestamp, val string, hostAttributeValue string, taskmanagerIDAttributeValue string) error {
	if f, err := strconv.ParseFloat(val, 64); err != nil {
		return fmt.Errorf("failed to parse float for FlinkTaskmanagerStatusJvmCPULoad, value was %s: %w", val, err)
	} else {
		mb.metricFlinkTaskmanagerStatusJvmCPULoad.recordDataPoint(mb.startTime, ts, f, hostAttributeValue, taskmanagerIDAttributeValue)
	}
	return nil
}

// RecordFlinkTaskmanagerStatusJvmCPUTimeDataPoint adds a data point to flink.taskmanager.status.jvm.cpu.time metric.
func (mb *MetricsBuilder) RecordFlinkTaskmanagerStatusJvmCPUTimeDataPoint(ts pcommon.Timestamp, val string, hostAttributeValue string, taskmanagerIDAttributeValue string) error {
	if i, err := strconv.ParseInt(val, 10, 64); err != nil {
		return fmt.Errorf("failed to parse int for FlinkTaskmanagerStatusJvmCPUTime, value was %s: %w", val, err)
	} else {
		mb.metricFlinkTaskmanagerStatusJvmCPUTime.recordDataPoint(mb.startTime, ts, i, hostAttributeValue, taskmanagerIDAttributeValue)
	}
	return nil
}

// RecordFlinkTaskmanagerStatusJvmGarbageCollectorCollectionCountDataPoint adds a data point to flink.taskmanager.status.jvm.garbage_collector.collection.count metric.
func (mb *MetricsBuilder) RecordFlinkTaskmanagerStatusJvmGarbageCollectorCollectionCountDataPoint(ts pcommon.Timestamp, val string, hostAttributeValue string, taskmanagerIDAttributeValue string, garbageCollectorNameAttributeValue string) error {
	if i, err := strconv.ParseInt(val, 10, 64); err != nil {
		return fmt.Errorf("failed to parse int for FlinkTaskmanagerStatusJvmGarbageCollectorCollectionCount, value was %s: %w", val, err)
	} else {
		mb.metricFlinkTaskmanagerStatusJvmGarbageCollectorCollectionCount.recordDataPoint(mb.startTime, ts, i, hostAttributeValue, taskmanagerIDAttributeValue, garbageCollectorNameAttributeValue)
	}
	return nil
}

// RecordFlinkTaskmanagerStatusJvmGarbageCollectorCollectionTimeDataPoint adds a data point to flink.taskmanager.status.jvm.garbage_collector.collection.time metric.
func (mb *MetricsBuilder) RecordFlinkTaskmanagerStatusJvmGarbageCollectorCollectionTimeDataPoint(ts pcommon.Timestamp, val string, hostAttributeValue string, taskmanagerIDAttributeValue string, garbageCollectorNameAttributeValue string) error {
	if i, err := strconv.ParseInt(val, 10, 64); err != nil {
		return fmt.Errorf("failed to parse int for FlinkTaskmanagerStatusJvmGarbageCollectorCollectionTime, value was %s: %w", val, err)
	} else {
		mb.metricFlinkTaskmanagerStatusJvmGarbageCollectorCollectionTime.recordDataPoint(mb.startTime, ts, i, hostAttributeValue, taskmanagerIDAttributeValue, garbageCollectorNameAttributeValue)
	}
	return nil
}

// RecordFlinkTaskmanagerStatusJvmMemoryDirectTotalCapacityDataPoint adds a data point to flink.taskmanager.status.jvm.memory.direct.total_capacity metric.
func (mb *MetricsBuilder) RecordFlinkTaskmanagerStatusJvmMemoryDirectTotalCapacityDataPoint(ts pcommon.Timestamp, val string, hostAttributeValue string, taskmanagerIDAttributeValue string) error {
	if i, err := strconv.ParseInt(val, 10, 64); err != nil {
		return fmt.Errorf("failed to parse int for FlinkTaskmanagerStatusJvmMemoryDirectTotalCapacity, value was %s: %w", val, err)
	} else {
		mb.metricFlinkTaskmanagerStatusJvmMemoryDirectTotalCapacity.recordDataPoint(mb.startTime, ts, i, hostAttributeValue, taskmanagerIDAttributeValue)
	}
	return nil
}

// RecordFlinkTaskmanagerStatusJvmMemoryDirectUsedDataPoint adds a data point to flink.taskmanager.status.jvm.memory.direct.used metric.
func (mb *MetricsBuilder) RecordFlinkTaskmanagerStatusJvmMemoryDirectUsedDataPoint(ts pcommon.Timestamp, val string, hostAttributeValue string, taskmanagerIDAttributeValue string) error {
	if i, err := strconv.ParseInt(val, 10, 64); err != nil {
		return fmt.Errorf("failed to parse int for FlinkTaskmanagerStatusJvmMemoryDirectUsed, value was %s: %w", val, err)
	} else {
		mb.metricFlinkTaskmanagerStatusJvmMemoryDirectUsed.recordDataPoint(mb.startTime, ts, i, hostAttributeValue, taskmanagerIDAttributeValue)
	}
	return nil
}

// RecordFlinkTaskmanagerStatusJvmMemoryHeapCommittedDataPoint adds a data point to flink.taskmanager.status.jvm.memory.heap.committed metric.
func (mb *MetricsBuilder) RecordFlinkTaskmanagerStatusJvmMemoryHeapCommittedDataPoint(ts pcommon.Timestamp, val string, hostAttributeValue string, taskmanagerIDAttributeValue string) error {
	if i, err := strconv.ParseInt(val, 10, 64); err != nil {
		return fmt.Errorf("failed to parse int for FlinkTaskmanagerStatusJvmMemoryHeapCommitted, value was %s: %w", val, err)
	} else {
		mb.metricFlinkTaskmanagerStatusJvmMemoryHeapCommitted.recordDataPoint(mb.startTime, ts, i, hostAttributeValue, taskmanagerIDAttributeValue)
	}
	return nil
}

// RecordFlinkTaskmanagerStatusJvmMemoryHeapMaxDataPoint adds a data point to flink.taskmanager.status.jvm.memory.heap.max metric.
func (mb *MetricsBuilder) RecordFlinkTaskmanagerStatusJvmMemoryHeapMaxDataPoint(ts pcommon.Timestamp, val string, hostAttributeValue string, taskmanagerIDAttributeValue string) error {
	if i, err := strconv.ParseInt(val, 10, 64); err != nil {
		return fmt.Errorf("failed to parse int for FlinkTaskmanagerStatusJvmMemoryHeapMax, value was %s: %w", val, err)
	} else {
		mb.metricFlinkTaskmanagerStatusJvmMemoryHeapMax.recordDataPoint(mb.startTime, ts, i, hostAttributeValue, taskmanagerIDAttributeValue)
	}
	return nil
}

// RecordFlinkTaskmanagerStatusJvmMemoryHeapUsedDataPoint adds a data point to flink.taskmanager.status.jvm.memory.heap.used metric.
func (mb *MetricsBuilder) RecordFlinkTaskmanagerStatusJvmMemoryHeapUsedDataPoint(ts pcommon.Timestamp, val string, hostAttributeValue string, taskmanagerIDAttributeValue string) error {
	if i, err := strconv.ParseInt(val, 10, 64); err != nil {
		return fmt.Errorf("failed to parse int for FlinkTaskmanagerStatusJvmMemoryHeapUsed, value was %s: %w", val, err)
	} else {
		mb.metricFlinkTaskmanagerStatusJvmMemoryHeapUsed.recordDataPoint(mb.startTime, ts, i, hostAttributeValue, taskmanagerIDAttributeValue)
	}
	return nil
}

// RecordFlinkTaskmanagerStatusJvmMemoryMappedTotalCapacityDataPoint adds a data point to flink.taskmanager.status.jvm.memory.mapped.total_capacity metric.
func (mb *MetricsBuilder) RecordFlinkTaskmanagerStatusJvmMemoryMappedTotalCapacityDataPoint(ts pcommon.Timestamp, val string, hostAttributeValue string, taskmanagerIDAttributeValue string) error {
	if i, err := strconv.ParseInt(val, 10, 64); err != nil {
		return fmt.Errorf("failed to parse int for FlinkTaskmanagerStatusJvmMemoryMappedTotalCapacity, value was %s: %w", val, err)
	} else {
		mb.metricFlinkTaskmanagerStatusJvmMemoryMappedTotalCapacity.recordDataPoint(mb.startTime, ts, i, hostAttributeValue, taskmanagerIDAttributeValue)
	}
	return nil
}

// RecordFlinkTaskmanagerStatusJvmMemoryMappedUsedDataPoint adds a data point to flink.taskmanager.status.jvm.memory.mapped.used metric.
func (mb *MetricsBuilder) RecordFlinkTaskmanagerStatusJvmMemoryMappedUsedDataPoint(ts pcommon.Timestamp, val string, hostAttributeValue string, taskmanagerIDAttributeValue string) error {
	if i, err := strconv.ParseInt(val, 10, 64); err != nil {
		return fmt.Errorf("failed to parse int for FlinkTaskmanagerStatusJvmMemoryMappedUsed, value was %s: %w", val, err)
	} else {
		mb.metricFlinkTaskmanagerStatusJvmMemoryMappedUsed.recordDataPoint(mb.startTime, ts, i, hostAttributeValue, taskmanagerIDAttributeValue)
	}
	return nil
}

// RecordFlinkTaskmanagerStatusJvmMemoryMetaspaceCommittedDataPoint adds a data point to flink.taskmanager.status.jvm.memory.metaspace.committed metric.
func (mb *MetricsBuilder) RecordFlinkTaskmanagerStatusJvmMemoryMetaspaceCommittedDataPoint(ts pcommon.Timestamp, val string, hostAttributeValue string, taskmanagerIDAttributeValue string) error {
	if i, err := strconv.ParseInt(val, 10, 64); err != nil {
		return fmt.Errorf("failed to parse int for FlinkTaskmanagerStatusJvmMemoryMetaspaceCommitted, value was %s: %w", val, err)
	} else {
		mb.metricFlinkTaskmanagerStatusJvmMemoryMetaspaceCommitted.recordDataPoint(mb.startTime, ts, i, hostAttributeValue, taskmanagerIDAttributeValue)
	}
	return nil
}

// RecordFlinkTaskmanagerStatusJvmMemoryMetaspaceMaxDataPoint adds a data point to flink.taskmanager.status.jvm.memory.metaspace.max metric.
func (mb *MetricsBuilder) RecordFlinkTaskmanagerStatusJvmMemoryMetaspaceMaxDataPoint(ts pcommon.Timestamp, val string, hostAttributeValue string, taskmanagerIDAttributeValue string) error {
	if i, err := strconv.ParseInt(val, 10, 64); err != nil {
		return fmt.Errorf("failed to parse int for FlinkTaskmanagerStatusJvmMemoryMetaspaceMax, value was %s: %w", val, err)
	} else {
		mb.metricFlinkTaskmanagerStatusJvmMemoryMetaspaceMax.recordDataPoint(mb.startTime, ts, i, hostAttributeValue, taskmanagerIDAttributeValue)
	}
	return nil
}

// RecordFlinkTaskmanagerStatusJvmMemoryMetaspaceUsedDataPoint adds a data point to flink.taskmanager.status.jvm.memory.metaspace.used metric.
func (mb *MetricsBuilder) RecordFlinkTaskmanagerStatusJvmMemoryMetaspaceUsedDataPoint(ts pcommon.Timestamp, val string, hostAttributeValue string, taskmanagerIDAttributeValue string) error {
	if i, err := strconv.ParseInt(val, 10, 64); err != nil {
		return fmt.Errorf("failed to parse int for FlinkTaskmanagerStatusJvmMemoryMetaspaceUsed, value was %s: %w", val, err)
	} else {
		mb.metricFlinkTaskmanagerStatusJvmMemoryMetaspaceUsed.recordDataPoint(mb.startTime, ts, i, hostAttributeValue, taskmanagerIDAttributeValue)
	}
	return nil
}

// RecordFlinkTaskmanagerStatusJvmMemoryNonHeapCommittedDataPoint adds a data point to flink.taskmanager.status.jvm.memory.non_heap.committed metric.
func (mb *MetricsBuilder) RecordFlinkTaskmanagerStatusJvmMemoryNonHeapCommittedDataPoint(ts pcommon.Timestamp, val string, hostAttributeValue string, taskmanagerIDAttributeValue string) error {
	if i, err := strconv.ParseInt(val, 10, 64); err != nil {
		return fmt.Errorf("failed to parse int for FlinkTaskmanagerStatusJvmMemoryNonHeapCommitted, value was %s: %w", val, err)
	} else {
		mb.metricFlinkTaskmanagerStatusJvmMemoryNonHeapCommitted.recordDataPoint(mb.startTime, ts, i, hostAttributeValue, taskmanagerIDAttributeValue)
	}
	return nil
}

// RecordFlinkTaskmanagerStatusJvmMemoryNonHeapMaxDataPoint adds a data point to flink.taskmanager.status.jvm.memory.non_heap.max metric.
func (mb *MetricsBuilder) RecordFlinkTaskmanagerStatusJvmMemoryNonHeapMaxDataPoint(ts pcommon.Timestamp, val string, hostAttributeValue string, taskmanagerIDAttributeValue string) error {
	if i, err := strconv.ParseInt(val, 10, 64); err != nil {
		return fmt.Errorf("failed to parse int for FlinkTaskmanagerStatusJvmMemoryNonHeapMax, value was %s: %w", val, err)
	} else {
		mb.metricFlinkTaskmanagerStatusJvmMemoryNonHeapMax.recordDataPoint(mb.startTime, ts, i, hostAttributeValue, taskmanagerIDAttributeValue)
	}
	return nil
}

// RecordFlinkTaskmanagerStatusJvmMemoryNonHeapUsedDataPoint adds a data point to flink.taskmanager.status.jvm.memory.non_heap.used metric.
func (mb *MetricsBuilder) RecordFlinkTaskmanagerStatusJvmMemoryNonHeapUsedDataPoint(ts pcommon.Timestamp, val string, hostAttributeValue string, taskmanagerIDAttributeValue string) error {
	if i, err := strconv.ParseInt(val, 10, 64); err != nil {
		return fmt.Errorf("failed to parse int for FlinkTaskmanagerStatusJvmMemoryNonHeapUsed, value was %s: %w", val, err)
	} else {
		mb.metricFlinkTaskmanagerStatusJvmMemoryNonHeapUsed.recordDataPoint(mb.startTime, ts, i, hostAttributeValue, taskmanagerIDAttributeValue)
	}
	return nil
}

// RecordFlinkTaskmanagerStatusJvmThreadsCountDataPoint adds a data point to flink.taskmanager.status.jvm.threads.count metric.
func (mb *MetricsBuilder) RecordFlinkTaskmanagerStatusJvmThreadsCountDataPoint(ts pcommon.Timestamp, val string, hostAttributeValue string, taskmanagerIDAttributeValue string) error {
	if i, err := strconv.ParseInt(val, 10, 64); err != nil {
		return fmt.Errorf("failed to parse int for FlinkTaskmanagerStatusJvmThreadsCount, value was %s: %w", val, err)
	} else {
		mb.metricFlinkTaskmanagerStatusJvmThreadsCount.recordDataPoint(mb.startTime, ts, i, hostAttributeValue, taskmanagerIDAttributeValue)
	}
	return nil
}

// Reset resets metrics builder to its initial state. It should be used when external metrics source is restarted,
// and metrics builder should update its startTime and reset it's internal state accordingly.
func (mb *MetricsBuilder) Reset(options ...metricBuilderOption) {
	mb.startTime = pcommon.NewTimestampFromTime(time.Now())
	for _, op := range options {
		op(mb)
	}
}

// Attributes contains the possible metric attributes that can be used.
var Attributes = struct {
	// Checkpoint (The amount of checkpoints of a given type.)
	Checkpoint string
	// GarbageCollectorName (The garbage collector name.)
	GarbageCollectorName string
	// Host (The host, used to distinguish different jobmanager metrics.)
	Host string
	// JobName (The job name, used to distinguish job metrics.)
	JobName string
	// OperatorName (The operator name, used to distinguish operator metrics.)
	OperatorName string
	// Record (The amount of records of a given type.)
	Record string
	// SubtaskIndex (The subtask index, used to distinguish operator metrics.)
	SubtaskIndex string
	// TaskName (The task name, used to distinguish tasks metrics.)
	TaskName string
	// TaskmanagerID (The taskmanager ID, used to distinguish taskmanager metrics.)
	TaskmanagerID string
}{
	"checkpoint",
	"garbage_collector_name",
	"host",
	"job_name",
	"operator_name",
	"record",
	"subtask_index",
	"task_name",
	"taskmanager_id",
}

// A is an alias for Attributes.
var A = Attributes
