// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"time"

	"go.opentelemetry.io/collector/model/pdata"
)

// MetricSettings provides common settings for a particular metric.
type MetricSettings struct {
	Enabled bool `mapstructure:"enabled"`
}

// MetricsSettings provides settings for vmwarevcenterreceiver metrics.
type MetricsSettings struct {
	VcenterClusterCPUAvailable      MetricSettings `mapstructure:"vcenter.cluster.cpu.available"`
	VcenterClusterCPUEffective      MetricSettings `mapstructure:"vcenter.cluster.cpu.effective"`
	VcenterClusterCPUUsed           MetricSettings `mapstructure:"vcenter.cluster.cpu.used"`
	VcenterClusterHostCount         MetricSettings `mapstructure:"vcenter.cluster.host.count"`
	VcenterClusterMemoryAvailable   MetricSettings `mapstructure:"vcenter.cluster.memory.available"`
	VcenterClusterMemoryEffective   MetricSettings `mapstructure:"vcenter.cluster.memory.effective"`
	VcenterClusterMemoryUsed        MetricSettings `mapstructure:"vcenter.cluster.memory.used"`
	VcenterClusterVMCount           MetricSettings `mapstructure:"vcenter.cluster.vm.count"`
	VcenterClusterVsanCongestions   MetricSettings `mapstructure:"vcenter.cluster.vsan.congestions"`
	VcenterClusterVsanLatencyAvg    MetricSettings `mapstructure:"vcenter.cluster.vsan.latency.avg"`
	VcenterClusterVsanOperations    MetricSettings `mapstructure:"vcenter.cluster.vsan.operations"`
	VcenterClusterVsanOutstandingIo MetricSettings `mapstructure:"vcenter.cluster.vsan.outstanding_io"`
	VcenterClusterVsanThroughput    MetricSettings `mapstructure:"vcenter.cluster.vsan.throughput"`
	VcenterDatastoreDiskUsage       MetricSettings `mapstructure:"vcenter.datastore.disk.usage"`
	VcenterDatastoreDiskUtilization MetricSettings `mapstructure:"vcenter.datastore.disk.utilization"`
	VcenterHostCPUUsage             MetricSettings `mapstructure:"vcenter.host.cpu.usage"`
	VcenterHostCPUUtilization       MetricSettings `mapstructure:"vcenter.host.cpu.utilization"`
	VcenterHostDiskLatencyAvg       MetricSettings `mapstructure:"vcenter.host.disk.latency.avg"`
	VcenterHostDiskLatencyTotal     MetricSettings `mapstructure:"vcenter.host.disk.latency.total"`
	VcenterHostDiskThroughput       MetricSettings `mapstructure:"vcenter.host.disk.throughput"`
	VcenterHostMemoryUsage          MetricSettings `mapstructure:"vcenter.host.memory.usage"`
	VcenterHostMemoryUtilization    MetricSettings `mapstructure:"vcenter.host.memory.utilization"`
	VcenterHostNetworkErrors        MetricSettings `mapstructure:"vcenter.host.network.errors"`
	VcenterHostNetworkPackets       MetricSettings `mapstructure:"vcenter.host.network.packets"`
	VcenterHostNetworkThroughput    MetricSettings `mapstructure:"vcenter.host.network.throughput"`
	VcenterHostNetworkUsage         MetricSettings `mapstructure:"vcenter.host.network.usage"`
	VcenterHostVsanCacheHitRate     MetricSettings `mapstructure:"vcenter.host.vsan.cache.hit_rate"`
	VcenterHostVsanCacheReads       MetricSettings `mapstructure:"vcenter.host.vsan.cache.reads"`
	VcenterHostVsanCongestions      MetricSettings `mapstructure:"vcenter.host.vsan.congestions"`
	VcenterHostVsanLatencyAvg       MetricSettings `mapstructure:"vcenter.host.vsan.latency.avg"`
	VcenterHostVsanOperations       MetricSettings `mapstructure:"vcenter.host.vsan.operations"`
	VcenterHostVsanOutstandingIo    MetricSettings `mapstructure:"vcenter.host.vsan.outstanding_io"`
	VcenterHostVsanThroughput       MetricSettings `mapstructure:"vcenter.host.vsan.throughput"`
	VcenterResourcePoolCPUShares    MetricSettings `mapstructure:"vcenter.resource_pool.cpu.shares"`
	VcenterResourcePoolCPUUsage     MetricSettings `mapstructure:"vcenter.resource_pool.cpu.usage"`
	VcenterResourcePoolMemoryShares MetricSettings `mapstructure:"vcenter.resource_pool.memory.shares"`
	VcenterResourcePoolMemoryUsage  MetricSettings `mapstructure:"vcenter.resource_pool.memory.usage"`
	VcenterVMCPUUtilization         MetricSettings `mapstructure:"vcenter.vm.cpu.utilization"`
	VcenterVMDiskLatencyAvg         MetricSettings `mapstructure:"vcenter.vm.disk.latency.avg"`
	VcenterVMDiskLatencyMax         MetricSettings `mapstructure:"vcenter.vm.disk.latency.max"`
	VcenterVMDiskThroughput         MetricSettings `mapstructure:"vcenter.vm.disk.throughput"`
	VcenterVMDiskUsage              MetricSettings `mapstructure:"vcenter.vm.disk.usage"`
	VcenterVMDiskUtilization        MetricSettings `mapstructure:"vcenter.vm.disk.utilization"`
	VcenterVMMemoryBallooned        MetricSettings `mapstructure:"vcenter.vm.memory.ballooned"`
	VcenterVMMemoryUsage            MetricSettings `mapstructure:"vcenter.vm.memory.usage"`
	VcenterVMNetworkPackets         MetricSettings `mapstructure:"vcenter.vm.network.packets"`
	VcenterVMNetworkThroughput      MetricSettings `mapstructure:"vcenter.vm.network.throughput"`
	VcenterVMNetworkUsage           MetricSettings `mapstructure:"vcenter.vm.network.usage"`
	VcenterVMVsanLatencyAvg         MetricSettings `mapstructure:"vcenter.vm.vsan.latency.avg"`
	VcenterVMVsanOperations         MetricSettings `mapstructure:"vcenter.vm.vsan.operations"`
	VcenterVMVsanThroughput         MetricSettings `mapstructure:"vcenter.vm.vsan.throughput"`
}

func DefaultMetricsSettings() MetricsSettings {
	return MetricsSettings{
		VcenterClusterCPUAvailable: MetricSettings{
			Enabled: true,
		},
		VcenterClusterCPUEffective: MetricSettings{
			Enabled: true,
		},
		VcenterClusterCPUUsed: MetricSettings{
			Enabled: true,
		},
		VcenterClusterHostCount: MetricSettings{
			Enabled: true,
		},
		VcenterClusterMemoryAvailable: MetricSettings{
			Enabled: true,
		},
		VcenterClusterMemoryEffective: MetricSettings{
			Enabled: true,
		},
		VcenterClusterMemoryUsed: MetricSettings{
			Enabled: true,
		},
		VcenterClusterVMCount: MetricSettings{
			Enabled: true,
		},
		VcenterClusterVsanCongestions: MetricSettings{
			Enabled: true,
		},
		VcenterClusterVsanLatencyAvg: MetricSettings{
			Enabled: true,
		},
		VcenterClusterVsanOperations: MetricSettings{
			Enabled: true,
		},
		VcenterClusterVsanOutstandingIo: MetricSettings{
			Enabled: true,
		},
		VcenterClusterVsanThroughput: MetricSettings{
			Enabled: true,
		},
		VcenterDatastoreDiskUsage: MetricSettings{
			Enabled: true,
		},
		VcenterDatastoreDiskUtilization: MetricSettings{
			Enabled: true,
		},
		VcenterHostCPUUsage: MetricSettings{
			Enabled: true,
		},
		VcenterHostCPUUtilization: MetricSettings{
			Enabled: true,
		},
		VcenterHostDiskLatencyAvg: MetricSettings{
			Enabled: true,
		},
		VcenterHostDiskLatencyTotal: MetricSettings{
			Enabled: true,
		},
		VcenterHostDiskThroughput: MetricSettings{
			Enabled: true,
		},
		VcenterHostMemoryUsage: MetricSettings{
			Enabled: true,
		},
		VcenterHostMemoryUtilization: MetricSettings{
			Enabled: true,
		},
		VcenterHostNetworkErrors: MetricSettings{
			Enabled: true,
		},
		VcenterHostNetworkPackets: MetricSettings{
			Enabled: true,
		},
		VcenterHostNetworkThroughput: MetricSettings{
			Enabled: true,
		},
		VcenterHostNetworkUsage: MetricSettings{
			Enabled: true,
		},
		VcenterHostVsanCacheHitRate: MetricSettings{
			Enabled: true,
		},
		VcenterHostVsanCacheReads: MetricSettings{
			Enabled: true,
		},
		VcenterHostVsanCongestions: MetricSettings{
			Enabled: true,
		},
		VcenterHostVsanLatencyAvg: MetricSettings{
			Enabled: true,
		},
		VcenterHostVsanOperations: MetricSettings{
			Enabled: true,
		},
		VcenterHostVsanOutstandingIo: MetricSettings{
			Enabled: true,
		},
		VcenterHostVsanThroughput: MetricSettings{
			Enabled: true,
		},
		VcenterResourcePoolCPUShares: MetricSettings{
			Enabled: true,
		},
		VcenterResourcePoolCPUUsage: MetricSettings{
			Enabled: true,
		},
		VcenterResourcePoolMemoryShares: MetricSettings{
			Enabled: true,
		},
		VcenterResourcePoolMemoryUsage: MetricSettings{
			Enabled: true,
		},
		VcenterVMCPUUtilization: MetricSettings{
			Enabled: true,
		},
		VcenterVMDiskLatencyAvg: MetricSettings{
			Enabled: true,
		},
		VcenterVMDiskLatencyMax: MetricSettings{
			Enabled: true,
		},
		VcenterVMDiskThroughput: MetricSettings{
			Enabled: true,
		},
		VcenterVMDiskUsage: MetricSettings{
			Enabled: true,
		},
		VcenterVMDiskUtilization: MetricSettings{
			Enabled: true,
		},
		VcenterVMMemoryBallooned: MetricSettings{
			Enabled: true,
		},
		VcenterVMMemoryUsage: MetricSettings{
			Enabled: true,
		},
		VcenterVMNetworkPackets: MetricSettings{
			Enabled: true,
		},
		VcenterVMNetworkThroughput: MetricSettings{
			Enabled: true,
		},
		VcenterVMNetworkUsage: MetricSettings{
			Enabled: true,
		},
		VcenterVMVsanLatencyAvg: MetricSettings{
			Enabled: true,
		},
		VcenterVMVsanOperations: MetricSettings{
			Enabled: true,
		},
		VcenterVMVsanThroughput: MetricSettings{
			Enabled: true,
		},
	}
}

type metricVcenterClusterCPUAvailable struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.cluster.cpu.available metric with initial data.
func (m *metricVcenterClusterCPUAvailable) init() {
	m.data.SetName("vcenter.cluster.cpu.available")
	m.data.SetDescription("The amount of CPU available to the cluster")
	m.data.SetUnit("{MHz}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricVcenterClusterCPUAvailable) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterClusterCPUAvailable) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterClusterCPUAvailable) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterClusterCPUAvailable(settings MetricSettings) metricVcenterClusterCPUAvailable {
	m := metricVcenterClusterCPUAvailable{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterClusterCPUEffective struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.cluster.cpu.effective metric with initial data.
func (m *metricVcenterClusterCPUEffective) init() {
	m.data.SetName("vcenter.cluster.cpu.effective")
	m.data.SetDescription("The effective CPU available to the cluster. This value excludes memory from hosts in maintenance mode or are unresponsive.")
	m.data.SetUnit("{MHz}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricVcenterClusterCPUEffective) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterClusterCPUEffective) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterClusterCPUEffective) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterClusterCPUEffective(settings MetricSettings) metricVcenterClusterCPUEffective {
	m := metricVcenterClusterCPUEffective{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterClusterCPUUsed struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.cluster.cpu.used metric with initial data.
func (m *metricVcenterClusterCPUUsed) init() {
	m.data.SetName("vcenter.cluster.cpu.used")
	m.data.SetDescription("The amount of CPU used by the cluster")
	m.data.SetUnit("{MHz}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricVcenterClusterCPUUsed) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterClusterCPUUsed) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterClusterCPUUsed) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterClusterCPUUsed(settings MetricSettings) metricVcenterClusterCPUUsed {
	m := metricVcenterClusterCPUUsed{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterClusterHostCount struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.cluster.host.count metric with initial data.
func (m *metricVcenterClusterHostCount) init() {
	m.data.SetName("vcenter.cluster.host.count")
	m.data.SetDescription("The number of hosts in the datacenter")
	m.data.SetUnit("{hosts}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterClusterHostCount) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, hostEffectiveAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.HostEffective, pdata.NewValueString(hostEffectiveAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterClusterHostCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterClusterHostCount) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterClusterHostCount(settings MetricSettings) metricVcenterClusterHostCount {
	m := metricVcenterClusterHostCount{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterClusterMemoryAvailable struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.cluster.memory.available metric with initial data.
func (m *metricVcenterClusterMemoryAvailable) init() {
	m.data.SetName("vcenter.cluster.memory.available")
	m.data.SetDescription("The available memory of the cluster.")
	m.data.SetUnit("By")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricVcenterClusterMemoryAvailable) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterClusterMemoryAvailable) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterClusterMemoryAvailable) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterClusterMemoryAvailable(settings MetricSettings) metricVcenterClusterMemoryAvailable {
	m := metricVcenterClusterMemoryAvailable{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterClusterMemoryEffective struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.cluster.memory.effective metric with initial data.
func (m *metricVcenterClusterMemoryEffective) init() {
	m.data.SetName("vcenter.cluster.memory.effective")
	m.data.SetDescription("The available memory of the cluster.")
	m.data.SetUnit("By")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricVcenterClusterMemoryEffective) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterClusterMemoryEffective) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterClusterMemoryEffective) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterClusterMemoryEffective(settings MetricSettings) metricVcenterClusterMemoryEffective {
	m := metricVcenterClusterMemoryEffective{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterClusterMemoryUsed struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.cluster.memory.used metric with initial data.
func (m *metricVcenterClusterMemoryUsed) init() {
	m.data.SetName("vcenter.cluster.memory.used")
	m.data.SetDescription("The memory that is currently used by the cluster")
	m.data.SetUnit("By")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricVcenterClusterMemoryUsed) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterClusterMemoryUsed) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterClusterMemoryUsed) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterClusterMemoryUsed(settings MetricSettings) metricVcenterClusterMemoryUsed {
	m := metricVcenterClusterMemoryUsed{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterClusterVMCount struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.cluster.vm.count metric with initial data.
func (m *metricVcenterClusterVMCount) init() {
	m.data.SetName("vcenter.cluster.vm.count")
	m.data.SetDescription("the number of virtual machines in the datacenter")
	m.data.SetUnit("{virtual_machines}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterClusterVMCount) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, vmCountPowerStateAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.VMCountPowerState, pdata.NewValueString(vmCountPowerStateAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterClusterVMCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterClusterVMCount) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterClusterVMCount(settings MetricSettings) metricVcenterClusterVMCount {
	m := metricVcenterClusterVMCount{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterClusterVsanCongestions struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.cluster.vsan.congestions metric with initial data.
func (m *metricVcenterClusterVsanCongestions) init() {
	m.data.SetName("vcenter.cluster.vsan.congestions")
	m.data.SetDescription("Congestions consumed by all vSAN clients in the cluster, such as virtual machines, stats objects, etc.")
	m.data.SetUnit("{congestions/sec}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricVcenterClusterVsanCongestions) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterClusterVsanCongestions) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterClusterVsanCongestions) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterClusterVsanCongestions(settings MetricSettings) metricVcenterClusterVsanCongestions {
	m := metricVcenterClusterVsanCongestions{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterClusterVsanLatencyAvg struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.cluster.vsan.latency.avg metric with initial data.
func (m *metricVcenterClusterVsanLatencyAvg) init() {
	m.data.SetName("vcenter.cluster.vsan.latency.avg")
	m.data.SetDescription("Average latency of IOs generated by all vSAN clients in the cluster.")
	m.data.SetUnit("µs")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterClusterVsanLatencyAvg) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, vsanLatencyTypeAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.VsanLatencyType, pdata.NewValueString(vsanLatencyTypeAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterClusterVsanLatencyAvg) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterClusterVsanLatencyAvg) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterClusterVsanLatencyAvg(settings MetricSettings) metricVcenterClusterVsanLatencyAvg {
	m := metricVcenterClusterVsanLatencyAvg{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterClusterVsanOperations struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.cluster.vsan.operations metric with initial data.
func (m *metricVcenterClusterVsanOperations) init() {
	m.data.SetName("vcenter.cluster.vsan.operations")
	m.data.SetDescription("IOPS consumed by all vSAN clients in the cluster")
	m.data.SetUnit("{operations/sec}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterClusterVsanOperations) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, vsanOperationTypeAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.VsanOperationType, pdata.NewValueString(vsanOperationTypeAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterClusterVsanOperations) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterClusterVsanOperations) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterClusterVsanOperations(settings MetricSettings) metricVcenterClusterVsanOperations {
	m := metricVcenterClusterVsanOperations{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterClusterVsanOutstandingIo struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.cluster.vsan.outstanding_io metric with initial data.
func (m *metricVcenterClusterVsanOutstandingIo) init() {
	m.data.SetName("vcenter.cluster.vsan.outstanding_io")
	m.data.SetDescription("Outstanding IO from all vSAN clients in the cluster")
	m.data.SetUnit("{operations}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricVcenterClusterVsanOutstandingIo) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterClusterVsanOutstandingIo) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterClusterVsanOutstandingIo) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterClusterVsanOutstandingIo(settings MetricSettings) metricVcenterClusterVsanOutstandingIo {
	m := metricVcenterClusterVsanOutstandingIo{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterClusterVsanThroughput struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.cluster.vsan.throughput metric with initial data.
func (m *metricVcenterClusterVsanThroughput) init() {
	m.data.SetName("vcenter.cluster.vsan.throughput")
	m.data.SetDescription("Throughput consumed by all vSAN clients in the cluster.")
	m.data.SetUnit("By/sec")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterClusterVsanThroughput) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, vsanThroughputDirectionAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.VsanThroughputDirection, pdata.NewValueString(vsanThroughputDirectionAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterClusterVsanThroughput) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterClusterVsanThroughput) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterClusterVsanThroughput(settings MetricSettings) metricVcenterClusterVsanThroughput {
	m := metricVcenterClusterVsanThroughput{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterDatastoreDiskUsage struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.datastore.disk.usage metric with initial data.
func (m *metricVcenterDatastoreDiskUsage) init() {
	m.data.SetName("vcenter.datastore.disk.usage")
	m.data.SetDescription("The amount of space in the datastore.")
	m.data.SetUnit("By")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterDatastoreDiskUsage) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, diskStateAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.DiskState, pdata.NewValueString(diskStateAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterDatastoreDiskUsage) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterDatastoreDiskUsage) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterDatastoreDiskUsage(settings MetricSettings) metricVcenterDatastoreDiskUsage {
	m := metricVcenterDatastoreDiskUsage{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterDatastoreDiskUtilization struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.datastore.disk.utilization metric with initial data.
func (m *metricVcenterDatastoreDiskUtilization) init() {
	m.data.SetName("vcenter.datastore.disk.utilization")
	m.data.SetDescription("The utilization of the datastore")
	m.data.SetUnit("%")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricVcenterDatastoreDiskUtilization) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterDatastoreDiskUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterDatastoreDiskUtilization) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterDatastoreDiskUtilization(settings MetricSettings) metricVcenterDatastoreDiskUtilization {
	m := metricVcenterDatastoreDiskUtilization{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterHostCPUUsage struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.host.cpu.usage metric with initial data.
func (m *metricVcenterHostCPUUsage) init() {
	m.data.SetName("vcenter.host.cpu.usage")
	m.data.SetDescription("The amount of CPU in Hz used by the host")
	m.data.SetUnit("MHz")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricVcenterHostCPUUsage) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterHostCPUUsage) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterHostCPUUsage) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterHostCPUUsage(settings MetricSettings) metricVcenterHostCPUUsage {
	m := metricVcenterHostCPUUsage{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterHostCPUUtilization struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.host.cpu.utilization metric with initial data.
func (m *metricVcenterHostCPUUtilization) init() {
	m.data.SetName("vcenter.host.cpu.utilization")
	m.data.SetDescription("The CPU utilization of the host system")
	m.data.SetUnit("%")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricVcenterHostCPUUtilization) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterHostCPUUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterHostCPUUtilization) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterHostCPUUtilization(settings MetricSettings) metricVcenterHostCPUUtilization {
	m := metricVcenterHostCPUUtilization{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterHostDiskLatencyAvg struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.host.disk.latency.avg metric with initial data.
func (m *metricVcenterHostDiskLatencyAvg) init() {
	m.data.SetName("vcenter.host.disk.latency.avg")
	m.data.SetDescription("The latency of operations to the host system's disk.")
	m.data.SetUnit("ms")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterHostDiskLatencyAvg) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, latencyDirectionAttributeValue string, latencyTypeAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.LatencyDirection, pdata.NewValueString(latencyDirectionAttributeValue))
	dp.Attributes().Insert(A.LatencyType, pdata.NewValueString(latencyTypeAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterHostDiskLatencyAvg) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterHostDiskLatencyAvg) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterHostDiskLatencyAvg(settings MetricSettings) metricVcenterHostDiskLatencyAvg {
	m := metricVcenterHostDiskLatencyAvg{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterHostDiskLatencyTotal struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.host.disk.latency.total metric with initial data.
func (m *metricVcenterHostDiskLatencyTotal) init() {
	m.data.SetName("vcenter.host.disk.latency.total")
	m.data.SetDescription("The total reported total latency (device and kernel times)")
	m.data.SetUnit("ms")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterHostDiskLatencyTotal) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, latencyDirectionAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.LatencyDirection, pdata.NewValueString(latencyDirectionAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterHostDiskLatencyTotal) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterHostDiskLatencyTotal) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterHostDiskLatencyTotal(settings MetricSettings) metricVcenterHostDiskLatencyTotal {
	m := metricVcenterHostDiskLatencyTotal{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterHostDiskThroughput struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.host.disk.throughput metric with initial data.
func (m *metricVcenterHostDiskThroughput) init() {
	m.data.SetName("vcenter.host.disk.throughput")
	m.data.SetDescription("The throughput to the host system's disk")
	m.data.SetUnit("By/s")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricVcenterHostDiskThroughput) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterHostDiskThroughput) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterHostDiskThroughput) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterHostDiskThroughput(settings MetricSettings) metricVcenterHostDiskThroughput {
	m := metricVcenterHostDiskThroughput{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterHostMemoryUsage struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.host.memory.usage metric with initial data.
func (m *metricVcenterHostMemoryUsage) init() {
	m.data.SetName("vcenter.host.memory.usage")
	m.data.SetDescription("The amount of memory the host system is using")
	m.data.SetUnit("MBy")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricVcenterHostMemoryUsage) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterHostMemoryUsage) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterHostMemoryUsage) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterHostMemoryUsage(settings MetricSettings) metricVcenterHostMemoryUsage {
	m := metricVcenterHostMemoryUsage{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterHostMemoryUtilization struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.host.memory.utilization metric with initial data.
func (m *metricVcenterHostMemoryUtilization) init() {
	m.data.SetName("vcenter.host.memory.utilization")
	m.data.SetDescription("The percentage of the host system's memory capacity that is being utilized")
	m.data.SetUnit("%")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricVcenterHostMemoryUtilization) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterHostMemoryUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterHostMemoryUtilization) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterHostMemoryUtilization(settings MetricSettings) metricVcenterHostMemoryUtilization {
	m := metricVcenterHostMemoryUtilization{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterHostNetworkErrors struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.host.network.errors metric with initial data.
func (m *metricVcenterHostNetworkErrors) init() {
	m.data.SetName("vcenter.host.network.errors")
	m.data.SetDescription("The summation of errors on the host network.")
	m.data.SetUnit("{errors}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterHostNetworkErrors) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, throughputDirectionAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.ThroughputDirection, pdata.NewValueString(throughputDirectionAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterHostNetworkErrors) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterHostNetworkErrors) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterHostNetworkErrors(settings MetricSettings) metricVcenterHostNetworkErrors {
	m := metricVcenterHostNetworkErrors{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterHostNetworkPackets struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.host.network.packets metric with initial data.
func (m *metricVcenterHostNetworkPackets) init() {
	m.data.SetName("vcenter.host.network.packets")
	m.data.SetDescription("The number of packets sent over an interval")
	m.data.SetUnit("{packets/sec}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterHostNetworkPackets) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, throughputDirectionAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.ThroughputDirection, pdata.NewValueString(throughputDirectionAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterHostNetworkPackets) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterHostNetworkPackets) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterHostNetworkPackets(settings MetricSettings) metricVcenterHostNetworkPackets {
	m := metricVcenterHostNetworkPackets{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterHostNetworkThroughput struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.host.network.throughput metric with initial data.
func (m *metricVcenterHostNetworkThroughput) init() {
	m.data.SetName("vcenter.host.network.throughput")
	m.data.SetDescription("The amount of data that was sent or received over the network by the host")
	m.data.SetUnit("{KBy/s}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterHostNetworkThroughput) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, throughputDirectionAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.ThroughputDirection, pdata.NewValueString(throughputDirectionAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterHostNetworkThroughput) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterHostNetworkThroughput) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterHostNetworkThroughput(settings MetricSettings) metricVcenterHostNetworkThroughput {
	m := metricVcenterHostNetworkThroughput{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterHostNetworkUsage struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.host.network.usage metric with initial data.
func (m *metricVcenterHostNetworkUsage) init() {
	m.data.SetName("vcenter.host.network.usage")
	m.data.SetDescription("The sum of the data transmitted and received for all the NIC instances of the host.")
	m.data.SetUnit("{KBy/s}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricVcenterHostNetworkUsage) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterHostNetworkUsage) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterHostNetworkUsage) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterHostNetworkUsage(settings MetricSettings) metricVcenterHostNetworkUsage {
	m := metricVcenterHostNetworkUsage{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterHostVsanCacheHitRate struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.host.vsan.cache.hit_rate metric with initial data.
func (m *metricVcenterHostVsanCacheHitRate) init() {
	m.data.SetName("vcenter.host.vsan.cache.hit_rate")
	m.data.SetDescription("Percentage of read IOs which could be satisfied by the local client cache")
	m.data.SetUnit("%")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricVcenterHostVsanCacheHitRate) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterHostVsanCacheHitRate) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterHostVsanCacheHitRate) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterHostVsanCacheHitRate(settings MetricSettings) metricVcenterHostVsanCacheHitRate {
	m := metricVcenterHostVsanCacheHitRate{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterHostVsanCacheReads struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.host.vsan.cache.reads metric with initial data.
func (m *metricVcenterHostVsanCacheReads) init() {
	m.data.SetName("vcenter.host.vsan.cache.reads")
	m.data.SetDescription("Average latency of IOs generated by all vSAN clients on the host")
	m.data.SetUnit("{operations/sec}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricVcenterHostVsanCacheReads) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterHostVsanCacheReads) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterHostVsanCacheReads) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterHostVsanCacheReads(settings MetricSettings) metricVcenterHostVsanCacheReads {
	m := metricVcenterHostVsanCacheReads{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterHostVsanCongestions struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.host.vsan.congestions metric with initial data.
func (m *metricVcenterHostVsanCongestions) init() {
	m.data.SetName("vcenter.host.vsan.congestions")
	m.data.SetDescription("Congestions of IOs generated by all vSAN clients on the host")
	m.data.SetUnit("{congestions/sec}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricVcenterHostVsanCongestions) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterHostVsanCongestions) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterHostVsanCongestions) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterHostVsanCongestions(settings MetricSettings) metricVcenterHostVsanCongestions {
	m := metricVcenterHostVsanCongestions{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterHostVsanLatencyAvg struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.host.vsan.latency.avg metric with initial data.
func (m *metricVcenterHostVsanLatencyAvg) init() {
	m.data.SetName("vcenter.host.vsan.latency.avg")
	m.data.SetDescription("Average latency of IOs generated by all vSAN clients on the host.")
	m.data.SetUnit("µs")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterHostVsanLatencyAvg) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, vsanLatencyTypeAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.VsanLatencyType, pdata.NewValueString(vsanLatencyTypeAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterHostVsanLatencyAvg) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterHostVsanLatencyAvg) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterHostVsanLatencyAvg(settings MetricSettings) metricVcenterHostVsanLatencyAvg {
	m := metricVcenterHostVsanLatencyAvg{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterHostVsanOperations struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.host.vsan.operations metric with initial data.
func (m *metricVcenterHostVsanOperations) init() {
	m.data.SetName("vcenter.host.vsan.operations")
	m.data.SetDescription("IOPs consumed by all vSAN clients on the host.")
	m.data.SetUnit("{operations/sec}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterHostVsanOperations) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, vsanOperationTypeAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.VsanOperationType, pdata.NewValueString(vsanOperationTypeAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterHostVsanOperations) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterHostVsanOperations) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterHostVsanOperations(settings MetricSettings) metricVcenterHostVsanOperations {
	m := metricVcenterHostVsanOperations{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterHostVsanOutstandingIo struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.host.vsan.outstanding_io metric with initial data.
func (m *metricVcenterHostVsanOutstandingIo) init() {
	m.data.SetName("vcenter.host.vsan.outstanding_io")
	m.data.SetDescription("Outstanding IO from all vSAN clients in the host, such as virtual machines, stats object, etc.")
	m.data.SetUnit("{operations/sec}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricVcenterHostVsanOutstandingIo) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterHostVsanOutstandingIo) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterHostVsanOutstandingIo) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterHostVsanOutstandingIo(settings MetricSettings) metricVcenterHostVsanOutstandingIo {
	m := metricVcenterHostVsanOutstandingIo{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterHostVsanThroughput struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.host.vsan.throughput metric with initial data.
func (m *metricVcenterHostVsanThroughput) init() {
	m.data.SetName("vcenter.host.vsan.throughput")
	m.data.SetDescription("Throughput consumed by all vSAN clients on the host.")
	m.data.SetUnit("By/s")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterHostVsanThroughput) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, vsanThroughputDirectionAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.VsanThroughputDirection, pdata.NewValueString(vsanThroughputDirectionAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterHostVsanThroughput) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterHostVsanThroughput) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterHostVsanThroughput(settings MetricSettings) metricVcenterHostVsanThroughput {
	m := metricVcenterHostVsanThroughput{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterResourcePoolCPUShares struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.resource_pool.cpu.shares metric with initial data.
func (m *metricVcenterResourcePoolCPUShares) init() {
	m.data.SetName("vcenter.resource_pool.cpu.shares")
	m.data.SetDescription("The amount of shares of memory in the resource pool")
	m.data.SetUnit("{shares}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricVcenterResourcePoolCPUShares) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterResourcePoolCPUShares) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterResourcePoolCPUShares) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterResourcePoolCPUShares(settings MetricSettings) metricVcenterResourcePoolCPUShares {
	m := metricVcenterResourcePoolCPUShares{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterResourcePoolCPUUsage struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.resource_pool.cpu.usage metric with initial data.
func (m *metricVcenterResourcePoolCPUUsage) init() {
	m.data.SetName("vcenter.resource_pool.cpu.usage")
	m.data.SetDescription("The usage of the CPU used by the resource pool")
	m.data.SetUnit("{MHz}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricVcenterResourcePoolCPUUsage) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterResourcePoolCPUUsage) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterResourcePoolCPUUsage) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterResourcePoolCPUUsage(settings MetricSettings) metricVcenterResourcePoolCPUUsage {
	m := metricVcenterResourcePoolCPUUsage{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterResourcePoolMemoryShares struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.resource_pool.memory.shares metric with initial data.
func (m *metricVcenterResourcePoolMemoryShares) init() {
	m.data.SetName("vcenter.resource_pool.memory.shares")
	m.data.SetDescription("The amount of shares of memory in the resource pool")
	m.data.SetUnit("{shares}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricVcenterResourcePoolMemoryShares) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterResourcePoolMemoryShares) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterResourcePoolMemoryShares) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterResourcePoolMemoryShares(settings MetricSettings) metricVcenterResourcePoolMemoryShares {
	m := metricVcenterResourcePoolMemoryShares{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterResourcePoolMemoryUsage struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.resource_pool.memory.usage metric with initial data.
func (m *metricVcenterResourcePoolMemoryUsage) init() {
	m.data.SetName("vcenter.resource_pool.memory.usage")
	m.data.SetDescription("The usage of the memory by the resource pool")
	m.data.SetUnit("MBy")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricVcenterResourcePoolMemoryUsage) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterResourcePoolMemoryUsage) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterResourcePoolMemoryUsage) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterResourcePoolMemoryUsage(settings MetricSettings) metricVcenterResourcePoolMemoryUsage {
	m := metricVcenterResourcePoolMemoryUsage{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterVMCPUUtilization struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.vm.cpu.utilization metric with initial data.
func (m *metricVcenterVMCPUUtilization) init() {
	m.data.SetName("vcenter.vm.cpu.utilization")
	m.data.SetDescription("The CPU utilization of the virtual machine")
	m.data.SetUnit("%")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricVcenterVMCPUUtilization) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterVMCPUUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterVMCPUUtilization) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterVMCPUUtilization(settings MetricSettings) metricVcenterVMCPUUtilization {
	m := metricVcenterVMCPUUtilization{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterVMDiskLatencyAvg struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.vm.disk.latency.avg metric with initial data.
func (m *metricVcenterVMDiskLatencyAvg) init() {
	m.data.SetName("vcenter.vm.disk.latency.avg")
	m.data.SetDescription("The latency of operations to the virtual machine's disk")
	m.data.SetUnit("µs")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterVMDiskLatencyAvg) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, latencyDirectionAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.LatencyDirection, pdata.NewValueString(latencyDirectionAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterVMDiskLatencyAvg) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterVMDiskLatencyAvg) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterVMDiskLatencyAvg(settings MetricSettings) metricVcenterVMDiskLatencyAvg {
	m := metricVcenterVMDiskLatencyAvg{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterVMDiskLatencyMax struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.vm.disk.latency.max metric with initial data.
func (m *metricVcenterVMDiskLatencyMax) init() {
	m.data.SetName("vcenter.vm.disk.latency.max")
	m.data.SetDescription("The highest reported total latency (device and kernel times)")
	m.data.SetUnit("ms")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricVcenterVMDiskLatencyMax) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterVMDiskLatencyMax) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterVMDiskLatencyMax) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterVMDiskLatencyMax(settings MetricSettings) metricVcenterVMDiskLatencyMax {
	m := metricVcenterVMDiskLatencyMax{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterVMDiskThroughput struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.vm.disk.throughput metric with initial data.
func (m *metricVcenterVMDiskThroughput) init() {
	m.data.SetName("vcenter.vm.disk.throughput")
	m.data.SetDescription("The throughput of the virtual machine's disk")
	m.data.SetUnit("By/sec")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricVcenterVMDiskThroughput) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterVMDiskThroughput) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterVMDiskThroughput) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterVMDiskThroughput(settings MetricSettings) metricVcenterVMDiskThroughput {
	m := metricVcenterVMDiskThroughput{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterVMDiskUsage struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.vm.disk.usage metric with initial data.
func (m *metricVcenterVMDiskUsage) init() {
	m.data.SetName("vcenter.vm.disk.usage")
	m.data.SetDescription("The amount of storage space the virtual machine is using")
	m.data.SetUnit("By")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterVMDiskUsage) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, diskStateAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.DiskState, pdata.NewValueString(diskStateAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterVMDiskUsage) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterVMDiskUsage) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterVMDiskUsage(settings MetricSettings) metricVcenterVMDiskUsage {
	m := metricVcenterVMDiskUsage{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterVMDiskUtilization struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.vm.disk.utilization metric with initial data.
func (m *metricVcenterVMDiskUtilization) init() {
	m.data.SetName("vcenter.vm.disk.utilization")
	m.data.SetDescription("The utilization of storage on the virtual machine")
	m.data.SetUnit("%")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricVcenterVMDiskUtilization) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterVMDiskUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterVMDiskUtilization) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterVMDiskUtilization(settings MetricSettings) metricVcenterVMDiskUtilization {
	m := metricVcenterVMDiskUtilization{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterVMMemoryBallooned struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.vm.memory.ballooned metric with initial data.
func (m *metricVcenterVMMemoryBallooned) init() {
	m.data.SetName("vcenter.vm.memory.ballooned")
	m.data.SetDescription("The amount of memory that is ballooned due to virtualization.")
	m.data.SetUnit("By")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricVcenterVMMemoryBallooned) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterVMMemoryBallooned) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterVMMemoryBallooned) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterVMMemoryBallooned(settings MetricSettings) metricVcenterVMMemoryBallooned {
	m := metricVcenterVMMemoryBallooned{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterVMMemoryUsage struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.vm.memory.usage metric with initial data.
func (m *metricVcenterVMMemoryUsage) init() {
	m.data.SetName("vcenter.vm.memory.usage")
	m.data.SetDescription("The amount of memory that is used by the virtual machine")
	m.data.SetUnit("MBy")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricVcenterVMMemoryUsage) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterVMMemoryUsage) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterVMMemoryUsage) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterVMMemoryUsage(settings MetricSettings) metricVcenterVMMemoryUsage {
	m := metricVcenterVMMemoryUsage{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterVMNetworkPackets struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.vm.network.packets metric with initial data.
func (m *metricVcenterVMNetworkPackets) init() {
	m.data.SetName("vcenter.vm.network.packets")
	m.data.SetDescription("The amount of packets that was received or transmitted over the instance's network.")
	m.data.SetUnit("{packets/sec}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterVMNetworkPackets) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, throughputDirectionAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.ThroughputDirection, pdata.NewValueString(throughputDirectionAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterVMNetworkPackets) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterVMNetworkPackets) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterVMNetworkPackets(settings MetricSettings) metricVcenterVMNetworkPackets {
	m := metricVcenterVMNetworkPackets{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterVMNetworkThroughput struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.vm.network.throughput metric with initial data.
func (m *metricVcenterVMNetworkThroughput) init() {
	m.data.SetName("vcenter.vm.network.throughput")
	m.data.SetDescription("The amount of data that was received or sent over the network of the virtual machine.")
	m.data.SetUnit("By/sec")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterVMNetworkThroughput) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, throughputDirectionAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.ThroughputDirection, pdata.NewValueString(throughputDirectionAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterVMNetworkThroughput) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterVMNetworkThroughput) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterVMNetworkThroughput(settings MetricSettings) metricVcenterVMNetworkThroughput {
	m := metricVcenterVMNetworkThroughput{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterVMNetworkUsage struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.vm.network.usage metric with initial data.
func (m *metricVcenterVMNetworkUsage) init() {
	m.data.SetName("vcenter.vm.network.usage")
	m.data.SetDescription("The network utilization combined transmit and receive rates during an interval.")
	m.data.SetUnit("{KBy/s}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricVcenterVMNetworkUsage) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterVMNetworkUsage) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterVMNetworkUsage) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterVMNetworkUsage(settings MetricSettings) metricVcenterVMNetworkUsage {
	m := metricVcenterVMNetworkUsage{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterVMVsanLatencyAvg struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.vm.vsan.latency.avg metric with initial data.
func (m *metricVcenterVMVsanLatencyAvg) init() {
	m.data.SetName("vcenter.vm.vsan.latency.avg")
	m.data.SetDescription("The latency while accessing VSAN storage")
	m.data.SetUnit("us")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterVMVsanLatencyAvg) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, vsanLatencyTypeAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.VsanLatencyType, pdata.NewValueString(vsanLatencyTypeAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterVMVsanLatencyAvg) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterVMVsanLatencyAvg) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterVMVsanLatencyAvg(settings MetricSettings) metricVcenterVMVsanLatencyAvg {
	m := metricVcenterVMVsanLatencyAvg{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterVMVsanOperations struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.vm.vsan.operations metric with initial data.
func (m *metricVcenterVMVsanOperations) init() {
	m.data.SetName("vcenter.vm.vsan.operations")
	m.data.SetDescription("Virtual Machine vSAN IOPs")
	m.data.SetUnit("{operations/sec}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterVMVsanOperations) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, vsanOperationTypeAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.VsanOperationType, pdata.NewValueString(vsanOperationTypeAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterVMVsanOperations) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterVMVsanOperations) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterVMVsanOperations(settings MetricSettings) metricVcenterVMVsanOperations {
	m := metricVcenterVMVsanOperations{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterVMVsanThroughput struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.vm.vsan.throughput metric with initial data.
func (m *metricVcenterVMVsanThroughput) init() {
	m.data.SetName("vcenter.vm.vsan.throughput")
	m.data.SetDescription("The VSAN throughput of a virtual machine")
	m.data.SetUnit("By/s")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterVMVsanThroughput) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, vsanThroughputDirectionAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.VsanThroughputDirection, pdata.NewValueString(vsanThroughputDirectionAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterVMVsanThroughput) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterVMVsanThroughput) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterVMVsanThroughput(settings MetricSettings) metricVcenterVMVsanThroughput {
	m := metricVcenterVMVsanThroughput{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

// MetricsBuilder provides an interface for scrapers to report metrics while taking care of all the transformations
// required to produce metric representation defined in metadata and user settings.
type MetricsBuilder struct {
	startTime                             pdata.Timestamp // start time that will be applied to all recorded data points.
	metricsCapacity                       int             // maximum observed number of metrics per resource.
	resourceCapacity                      int             // maximum observed number of resource attributes.
	metricsBuffer                         pdata.Metrics   // accumulates metrics data before emitting.
	metricVcenterClusterCPUAvailable      metricVcenterClusterCPUAvailable
	metricVcenterClusterCPUEffective      metricVcenterClusterCPUEffective
	metricVcenterClusterCPUUsed           metricVcenterClusterCPUUsed
	metricVcenterClusterHostCount         metricVcenterClusterHostCount
	metricVcenterClusterMemoryAvailable   metricVcenterClusterMemoryAvailable
	metricVcenterClusterMemoryEffective   metricVcenterClusterMemoryEffective
	metricVcenterClusterMemoryUsed        metricVcenterClusterMemoryUsed
	metricVcenterClusterVMCount           metricVcenterClusterVMCount
	metricVcenterClusterVsanCongestions   metricVcenterClusterVsanCongestions
	metricVcenterClusterVsanLatencyAvg    metricVcenterClusterVsanLatencyAvg
	metricVcenterClusterVsanOperations    metricVcenterClusterVsanOperations
	metricVcenterClusterVsanOutstandingIo metricVcenterClusterVsanOutstandingIo
	metricVcenterClusterVsanThroughput    metricVcenterClusterVsanThroughput
	metricVcenterDatastoreDiskUsage       metricVcenterDatastoreDiskUsage
	metricVcenterDatastoreDiskUtilization metricVcenterDatastoreDiskUtilization
	metricVcenterHostCPUUsage             metricVcenterHostCPUUsage
	metricVcenterHostCPUUtilization       metricVcenterHostCPUUtilization
	metricVcenterHostDiskLatencyAvg       metricVcenterHostDiskLatencyAvg
	metricVcenterHostDiskLatencyTotal     metricVcenterHostDiskLatencyTotal
	metricVcenterHostDiskThroughput       metricVcenterHostDiskThroughput
	metricVcenterHostMemoryUsage          metricVcenterHostMemoryUsage
	metricVcenterHostMemoryUtilization    metricVcenterHostMemoryUtilization
	metricVcenterHostNetworkErrors        metricVcenterHostNetworkErrors
	metricVcenterHostNetworkPackets       metricVcenterHostNetworkPackets
	metricVcenterHostNetworkThroughput    metricVcenterHostNetworkThroughput
	metricVcenterHostNetworkUsage         metricVcenterHostNetworkUsage
	metricVcenterHostVsanCacheHitRate     metricVcenterHostVsanCacheHitRate
	metricVcenterHostVsanCacheReads       metricVcenterHostVsanCacheReads
	metricVcenterHostVsanCongestions      metricVcenterHostVsanCongestions
	metricVcenterHostVsanLatencyAvg       metricVcenterHostVsanLatencyAvg
	metricVcenterHostVsanOperations       metricVcenterHostVsanOperations
	metricVcenterHostVsanOutstandingIo    metricVcenterHostVsanOutstandingIo
	metricVcenterHostVsanThroughput       metricVcenterHostVsanThroughput
	metricVcenterResourcePoolCPUShares    metricVcenterResourcePoolCPUShares
	metricVcenterResourcePoolCPUUsage     metricVcenterResourcePoolCPUUsage
	metricVcenterResourcePoolMemoryShares metricVcenterResourcePoolMemoryShares
	metricVcenterResourcePoolMemoryUsage  metricVcenterResourcePoolMemoryUsage
	metricVcenterVMCPUUtilization         metricVcenterVMCPUUtilization
	metricVcenterVMDiskLatencyAvg         metricVcenterVMDiskLatencyAvg
	metricVcenterVMDiskLatencyMax         metricVcenterVMDiskLatencyMax
	metricVcenterVMDiskThroughput         metricVcenterVMDiskThroughput
	metricVcenterVMDiskUsage              metricVcenterVMDiskUsage
	metricVcenterVMDiskUtilization        metricVcenterVMDiskUtilization
	metricVcenterVMMemoryBallooned        metricVcenterVMMemoryBallooned
	metricVcenterVMMemoryUsage            metricVcenterVMMemoryUsage
	metricVcenterVMNetworkPackets         metricVcenterVMNetworkPackets
	metricVcenterVMNetworkThroughput      metricVcenterVMNetworkThroughput
	metricVcenterVMNetworkUsage           metricVcenterVMNetworkUsage
	metricVcenterVMVsanLatencyAvg         metricVcenterVMVsanLatencyAvg
	metricVcenterVMVsanOperations         metricVcenterVMVsanOperations
	metricVcenterVMVsanThroughput         metricVcenterVMVsanThroughput
}

// metricBuilderOption applies changes to default metrics builder.
type metricBuilderOption func(*MetricsBuilder)

// WithStartTime sets startTime on the metrics builder.
func WithStartTime(startTime pdata.Timestamp) metricBuilderOption {
	return func(mb *MetricsBuilder) {
		mb.startTime = startTime
	}
}

func NewMetricsBuilder(settings MetricsSettings, options ...metricBuilderOption) *MetricsBuilder {
	mb := &MetricsBuilder{
		startTime:                             pdata.NewTimestampFromTime(time.Now()),
		metricsBuffer:                         pdata.NewMetrics(),
		metricVcenterClusterCPUAvailable:      newMetricVcenterClusterCPUAvailable(settings.VcenterClusterCPUAvailable),
		metricVcenterClusterCPUEffective:      newMetricVcenterClusterCPUEffective(settings.VcenterClusterCPUEffective),
		metricVcenterClusterCPUUsed:           newMetricVcenterClusterCPUUsed(settings.VcenterClusterCPUUsed),
		metricVcenterClusterHostCount:         newMetricVcenterClusterHostCount(settings.VcenterClusterHostCount),
		metricVcenterClusterMemoryAvailable:   newMetricVcenterClusterMemoryAvailable(settings.VcenterClusterMemoryAvailable),
		metricVcenterClusterMemoryEffective:   newMetricVcenterClusterMemoryEffective(settings.VcenterClusterMemoryEffective),
		metricVcenterClusterMemoryUsed:        newMetricVcenterClusterMemoryUsed(settings.VcenterClusterMemoryUsed),
		metricVcenterClusterVMCount:           newMetricVcenterClusterVMCount(settings.VcenterClusterVMCount),
		metricVcenterClusterVsanCongestions:   newMetricVcenterClusterVsanCongestions(settings.VcenterClusterVsanCongestions),
		metricVcenterClusterVsanLatencyAvg:    newMetricVcenterClusterVsanLatencyAvg(settings.VcenterClusterVsanLatencyAvg),
		metricVcenterClusterVsanOperations:    newMetricVcenterClusterVsanOperations(settings.VcenterClusterVsanOperations),
		metricVcenterClusterVsanOutstandingIo: newMetricVcenterClusterVsanOutstandingIo(settings.VcenterClusterVsanOutstandingIo),
		metricVcenterClusterVsanThroughput:    newMetricVcenterClusterVsanThroughput(settings.VcenterClusterVsanThroughput),
		metricVcenterDatastoreDiskUsage:       newMetricVcenterDatastoreDiskUsage(settings.VcenterDatastoreDiskUsage),
		metricVcenterDatastoreDiskUtilization: newMetricVcenterDatastoreDiskUtilization(settings.VcenterDatastoreDiskUtilization),
		metricVcenterHostCPUUsage:             newMetricVcenterHostCPUUsage(settings.VcenterHostCPUUsage),
		metricVcenterHostCPUUtilization:       newMetricVcenterHostCPUUtilization(settings.VcenterHostCPUUtilization),
		metricVcenterHostDiskLatencyAvg:       newMetricVcenterHostDiskLatencyAvg(settings.VcenterHostDiskLatencyAvg),
		metricVcenterHostDiskLatencyTotal:     newMetricVcenterHostDiskLatencyTotal(settings.VcenterHostDiskLatencyTotal),
		metricVcenterHostDiskThroughput:       newMetricVcenterHostDiskThroughput(settings.VcenterHostDiskThroughput),
		metricVcenterHostMemoryUsage:          newMetricVcenterHostMemoryUsage(settings.VcenterHostMemoryUsage),
		metricVcenterHostMemoryUtilization:    newMetricVcenterHostMemoryUtilization(settings.VcenterHostMemoryUtilization),
		metricVcenterHostNetworkErrors:        newMetricVcenterHostNetworkErrors(settings.VcenterHostNetworkErrors),
		metricVcenterHostNetworkPackets:       newMetricVcenterHostNetworkPackets(settings.VcenterHostNetworkPackets),
		metricVcenterHostNetworkThroughput:    newMetricVcenterHostNetworkThroughput(settings.VcenterHostNetworkThroughput),
		metricVcenterHostNetworkUsage:         newMetricVcenterHostNetworkUsage(settings.VcenterHostNetworkUsage),
		metricVcenterHostVsanCacheHitRate:     newMetricVcenterHostVsanCacheHitRate(settings.VcenterHostVsanCacheHitRate),
		metricVcenterHostVsanCacheReads:       newMetricVcenterHostVsanCacheReads(settings.VcenterHostVsanCacheReads),
		metricVcenterHostVsanCongestions:      newMetricVcenterHostVsanCongestions(settings.VcenterHostVsanCongestions),
		metricVcenterHostVsanLatencyAvg:       newMetricVcenterHostVsanLatencyAvg(settings.VcenterHostVsanLatencyAvg),
		metricVcenterHostVsanOperations:       newMetricVcenterHostVsanOperations(settings.VcenterHostVsanOperations),
		metricVcenterHostVsanOutstandingIo:    newMetricVcenterHostVsanOutstandingIo(settings.VcenterHostVsanOutstandingIo),
		metricVcenterHostVsanThroughput:       newMetricVcenterHostVsanThroughput(settings.VcenterHostVsanThroughput),
		metricVcenterResourcePoolCPUShares:    newMetricVcenterResourcePoolCPUShares(settings.VcenterResourcePoolCPUShares),
		metricVcenterResourcePoolCPUUsage:     newMetricVcenterResourcePoolCPUUsage(settings.VcenterResourcePoolCPUUsage),
		metricVcenterResourcePoolMemoryShares: newMetricVcenterResourcePoolMemoryShares(settings.VcenterResourcePoolMemoryShares),
		metricVcenterResourcePoolMemoryUsage:  newMetricVcenterResourcePoolMemoryUsage(settings.VcenterResourcePoolMemoryUsage),
		metricVcenterVMCPUUtilization:         newMetricVcenterVMCPUUtilization(settings.VcenterVMCPUUtilization),
		metricVcenterVMDiskLatencyAvg:         newMetricVcenterVMDiskLatencyAvg(settings.VcenterVMDiskLatencyAvg),
		metricVcenterVMDiskLatencyMax:         newMetricVcenterVMDiskLatencyMax(settings.VcenterVMDiskLatencyMax),
		metricVcenterVMDiskThroughput:         newMetricVcenterVMDiskThroughput(settings.VcenterVMDiskThroughput),
		metricVcenterVMDiskUsage:              newMetricVcenterVMDiskUsage(settings.VcenterVMDiskUsage),
		metricVcenterVMDiskUtilization:        newMetricVcenterVMDiskUtilization(settings.VcenterVMDiskUtilization),
		metricVcenterVMMemoryBallooned:        newMetricVcenterVMMemoryBallooned(settings.VcenterVMMemoryBallooned),
		metricVcenterVMMemoryUsage:            newMetricVcenterVMMemoryUsage(settings.VcenterVMMemoryUsage),
		metricVcenterVMNetworkPackets:         newMetricVcenterVMNetworkPackets(settings.VcenterVMNetworkPackets),
		metricVcenterVMNetworkThroughput:      newMetricVcenterVMNetworkThroughput(settings.VcenterVMNetworkThroughput),
		metricVcenterVMNetworkUsage:           newMetricVcenterVMNetworkUsage(settings.VcenterVMNetworkUsage),
		metricVcenterVMVsanLatencyAvg:         newMetricVcenterVMVsanLatencyAvg(settings.VcenterVMVsanLatencyAvg),
		metricVcenterVMVsanOperations:         newMetricVcenterVMVsanOperations(settings.VcenterVMVsanOperations),
		metricVcenterVMVsanThroughput:         newMetricVcenterVMVsanThroughput(settings.VcenterVMVsanThroughput),
	}
	for _, op := range options {
		op(mb)
	}
	return mb
}

// updateCapacity updates max length of metrics and resource attributes that will be used for the slice capacity.
func (mb *MetricsBuilder) updateCapacity(rm pdata.ResourceMetrics) {
	if mb.metricsCapacity < rm.ScopeMetrics().At(0).Metrics().Len() {
		mb.metricsCapacity = rm.ScopeMetrics().At(0).Metrics().Len()
	}
	if mb.resourceCapacity < rm.Resource().Attributes().Len() {
		mb.resourceCapacity = rm.Resource().Attributes().Len()
	}
}

// ResourceOption applies changes to provided resource.
type ResourceOption func(pdata.Resource)

// WithVcenterClusterName sets provided value as "vcenter.cluster.name" attribute for current resource.
func WithVcenterClusterName(val string) ResourceOption {
	return func(r pdata.Resource) {
		r.Attributes().UpsertString("vcenter.cluster.name", val)
	}
}

// WithVcenterDatastoreName sets provided value as "vcenter.datastore.name" attribute for current resource.
func WithVcenterDatastoreName(val string) ResourceOption {
	return func(r pdata.Resource) {
		r.Attributes().UpsertString("vcenter.datastore.name", val)
	}
}

// WithVcenterHostName sets provided value as "vcenter.host.name" attribute for current resource.
func WithVcenterHostName(val string) ResourceOption {
	return func(r pdata.Resource) {
		r.Attributes().UpsertString("vcenter.host.name", val)
	}
}

// WithVcenterResourcePoolName sets provided value as "vcenter.resource_pool.name" attribute for current resource.
func WithVcenterResourcePoolName(val string) ResourceOption {
	return func(r pdata.Resource) {
		r.Attributes().UpsertString("vcenter.resource_pool.name", val)
	}
}

// WithVcenterVMID sets provided value as "vcenter.vm.id" attribute for current resource.
func WithVcenterVMID(val string) ResourceOption {
	return func(r pdata.Resource) {
		r.Attributes().UpsertString("vcenter.vm.id", val)
	}
}

// WithVcenterVMName sets provided value as "vcenter.vm.name" attribute for current resource.
func WithVcenterVMName(val string) ResourceOption {
	return func(r pdata.Resource) {
		r.Attributes().UpsertString("vcenter.vm.name", val)
	}
}

// EmitForResource saves all the generated metrics under a new resource and updates the internal state to be ready for
// recording another set of data points as part of another resource. This function can be helpful when one scraper
// needs to emit metrics from several resources. Otherwise calling this function is not required,
// just `Emit` function can be called instead. Resource attributes should be provided as ResourceOption arguments.
func (mb *MetricsBuilder) EmitForResource(ro ...ResourceOption) {
	rm := pdata.NewResourceMetrics()
	rm.Resource().Attributes().EnsureCapacity(mb.resourceCapacity)
	for _, op := range ro {
		op(rm.Resource())
	}
	ils := rm.ScopeMetrics().AppendEmpty()
	ils.Scope().SetName("otelcol/vmwarevcenterreceiver")
	ils.Metrics().EnsureCapacity(mb.metricsCapacity)
	mb.metricVcenterClusterCPUAvailable.emit(ils.Metrics())
	mb.metricVcenterClusterCPUEffective.emit(ils.Metrics())
	mb.metricVcenterClusterCPUUsed.emit(ils.Metrics())
	mb.metricVcenterClusterHostCount.emit(ils.Metrics())
	mb.metricVcenterClusterMemoryAvailable.emit(ils.Metrics())
	mb.metricVcenterClusterMemoryEffective.emit(ils.Metrics())
	mb.metricVcenterClusterMemoryUsed.emit(ils.Metrics())
	mb.metricVcenterClusterVMCount.emit(ils.Metrics())
	mb.metricVcenterClusterVsanCongestions.emit(ils.Metrics())
	mb.metricVcenterClusterVsanLatencyAvg.emit(ils.Metrics())
	mb.metricVcenterClusterVsanOperations.emit(ils.Metrics())
	mb.metricVcenterClusterVsanOutstandingIo.emit(ils.Metrics())
	mb.metricVcenterClusterVsanThroughput.emit(ils.Metrics())
	mb.metricVcenterDatastoreDiskUsage.emit(ils.Metrics())
	mb.metricVcenterDatastoreDiskUtilization.emit(ils.Metrics())
	mb.metricVcenterHostCPUUsage.emit(ils.Metrics())
	mb.metricVcenterHostCPUUtilization.emit(ils.Metrics())
	mb.metricVcenterHostDiskLatencyAvg.emit(ils.Metrics())
	mb.metricVcenterHostDiskLatencyTotal.emit(ils.Metrics())
	mb.metricVcenterHostDiskThroughput.emit(ils.Metrics())
	mb.metricVcenterHostMemoryUsage.emit(ils.Metrics())
	mb.metricVcenterHostMemoryUtilization.emit(ils.Metrics())
	mb.metricVcenterHostNetworkErrors.emit(ils.Metrics())
	mb.metricVcenterHostNetworkPackets.emit(ils.Metrics())
	mb.metricVcenterHostNetworkThroughput.emit(ils.Metrics())
	mb.metricVcenterHostNetworkUsage.emit(ils.Metrics())
	mb.metricVcenterHostVsanCacheHitRate.emit(ils.Metrics())
	mb.metricVcenterHostVsanCacheReads.emit(ils.Metrics())
	mb.metricVcenterHostVsanCongestions.emit(ils.Metrics())
	mb.metricVcenterHostVsanLatencyAvg.emit(ils.Metrics())
	mb.metricVcenterHostVsanOperations.emit(ils.Metrics())
	mb.metricVcenterHostVsanOutstandingIo.emit(ils.Metrics())
	mb.metricVcenterHostVsanThroughput.emit(ils.Metrics())
	mb.metricVcenterResourcePoolCPUShares.emit(ils.Metrics())
	mb.metricVcenterResourcePoolCPUUsage.emit(ils.Metrics())
	mb.metricVcenterResourcePoolMemoryShares.emit(ils.Metrics())
	mb.metricVcenterResourcePoolMemoryUsage.emit(ils.Metrics())
	mb.metricVcenterVMCPUUtilization.emit(ils.Metrics())
	mb.metricVcenterVMDiskLatencyAvg.emit(ils.Metrics())
	mb.metricVcenterVMDiskLatencyMax.emit(ils.Metrics())
	mb.metricVcenterVMDiskThroughput.emit(ils.Metrics())
	mb.metricVcenterVMDiskUsage.emit(ils.Metrics())
	mb.metricVcenterVMDiskUtilization.emit(ils.Metrics())
	mb.metricVcenterVMMemoryBallooned.emit(ils.Metrics())
	mb.metricVcenterVMMemoryUsage.emit(ils.Metrics())
	mb.metricVcenterVMNetworkPackets.emit(ils.Metrics())
	mb.metricVcenterVMNetworkThroughput.emit(ils.Metrics())
	mb.metricVcenterVMNetworkUsage.emit(ils.Metrics())
	mb.metricVcenterVMVsanLatencyAvg.emit(ils.Metrics())
	mb.metricVcenterVMVsanOperations.emit(ils.Metrics())
	mb.metricVcenterVMVsanThroughput.emit(ils.Metrics())
	if ils.Metrics().Len() > 0 {
		mb.updateCapacity(rm)
		rm.MoveTo(mb.metricsBuffer.ResourceMetrics().AppendEmpty())
	}
}

// Emit returns all the metrics accumulated by the metrics builder and updates the internal state to be ready for
// recording another set of metrics. This function will be responsible for applying all the transformations required to
// produce metric representation defined in metadata and user settings, e.g. delta or cumulative.
func (mb *MetricsBuilder) Emit(ro ...ResourceOption) pdata.Metrics {
	mb.EmitForResource(ro...)
	metrics := pdata.NewMetrics()
	mb.metricsBuffer.MoveTo(metrics)
	return metrics
}

// RecordVcenterClusterCPUAvailableDataPoint adds a data point to vcenter.cluster.cpu.available metric.
func (mb *MetricsBuilder) RecordVcenterClusterCPUAvailableDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricVcenterClusterCPUAvailable.recordDataPoint(mb.startTime, ts, val)
}

// RecordVcenterClusterCPUEffectiveDataPoint adds a data point to vcenter.cluster.cpu.effective metric.
func (mb *MetricsBuilder) RecordVcenterClusterCPUEffectiveDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricVcenterClusterCPUEffective.recordDataPoint(mb.startTime, ts, val)
}

// RecordVcenterClusterCPUUsedDataPoint adds a data point to vcenter.cluster.cpu.used metric.
func (mb *MetricsBuilder) RecordVcenterClusterCPUUsedDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricVcenterClusterCPUUsed.recordDataPoint(mb.startTime, ts, val)
}

// RecordVcenterClusterHostCountDataPoint adds a data point to vcenter.cluster.host.count metric.
func (mb *MetricsBuilder) RecordVcenterClusterHostCountDataPoint(ts pdata.Timestamp, val int64, hostEffectiveAttributeValue string) {
	mb.metricVcenterClusterHostCount.recordDataPoint(mb.startTime, ts, val, hostEffectiveAttributeValue)
}

// RecordVcenterClusterMemoryAvailableDataPoint adds a data point to vcenter.cluster.memory.available metric.
func (mb *MetricsBuilder) RecordVcenterClusterMemoryAvailableDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricVcenterClusterMemoryAvailable.recordDataPoint(mb.startTime, ts, val)
}

// RecordVcenterClusterMemoryEffectiveDataPoint adds a data point to vcenter.cluster.memory.effective metric.
func (mb *MetricsBuilder) RecordVcenterClusterMemoryEffectiveDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricVcenterClusterMemoryEffective.recordDataPoint(mb.startTime, ts, val)
}

// RecordVcenterClusterMemoryUsedDataPoint adds a data point to vcenter.cluster.memory.used metric.
func (mb *MetricsBuilder) RecordVcenterClusterMemoryUsedDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricVcenterClusterMemoryUsed.recordDataPoint(mb.startTime, ts, val)
}

// RecordVcenterClusterVMCountDataPoint adds a data point to vcenter.cluster.vm.count metric.
func (mb *MetricsBuilder) RecordVcenterClusterVMCountDataPoint(ts pdata.Timestamp, val int64, vmCountPowerStateAttributeValue string) {
	mb.metricVcenterClusterVMCount.recordDataPoint(mb.startTime, ts, val, vmCountPowerStateAttributeValue)
}

// RecordVcenterClusterVsanCongestionsDataPoint adds a data point to vcenter.cluster.vsan.congestions metric.
func (mb *MetricsBuilder) RecordVcenterClusterVsanCongestionsDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricVcenterClusterVsanCongestions.recordDataPoint(mb.startTime, ts, val)
}

// RecordVcenterClusterVsanLatencyAvgDataPoint adds a data point to vcenter.cluster.vsan.latency.avg metric.
func (mb *MetricsBuilder) RecordVcenterClusterVsanLatencyAvgDataPoint(ts pdata.Timestamp, val int64, vsanLatencyTypeAttributeValue string) {
	mb.metricVcenterClusterVsanLatencyAvg.recordDataPoint(mb.startTime, ts, val, vsanLatencyTypeAttributeValue)
}

// RecordVcenterClusterVsanOperationsDataPoint adds a data point to vcenter.cluster.vsan.operations metric.
func (mb *MetricsBuilder) RecordVcenterClusterVsanOperationsDataPoint(ts pdata.Timestamp, val int64, vsanOperationTypeAttributeValue string) {
	mb.metricVcenterClusterVsanOperations.recordDataPoint(mb.startTime, ts, val, vsanOperationTypeAttributeValue)
}

// RecordVcenterClusterVsanOutstandingIoDataPoint adds a data point to vcenter.cluster.vsan.outstanding_io metric.
func (mb *MetricsBuilder) RecordVcenterClusterVsanOutstandingIoDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricVcenterClusterVsanOutstandingIo.recordDataPoint(mb.startTime, ts, val)
}

// RecordVcenterClusterVsanThroughputDataPoint adds a data point to vcenter.cluster.vsan.throughput metric.
func (mb *MetricsBuilder) RecordVcenterClusterVsanThroughputDataPoint(ts pdata.Timestamp, val int64, vsanThroughputDirectionAttributeValue string) {
	mb.metricVcenterClusterVsanThroughput.recordDataPoint(mb.startTime, ts, val, vsanThroughputDirectionAttributeValue)
}

// RecordVcenterDatastoreDiskUsageDataPoint adds a data point to vcenter.datastore.disk.usage metric.
func (mb *MetricsBuilder) RecordVcenterDatastoreDiskUsageDataPoint(ts pdata.Timestamp, val int64, diskStateAttributeValue string) {
	mb.metricVcenterDatastoreDiskUsage.recordDataPoint(mb.startTime, ts, val, diskStateAttributeValue)
}

// RecordVcenterDatastoreDiskUtilizationDataPoint adds a data point to vcenter.datastore.disk.utilization metric.
func (mb *MetricsBuilder) RecordVcenterDatastoreDiskUtilizationDataPoint(ts pdata.Timestamp, val float64) {
	mb.metricVcenterDatastoreDiskUtilization.recordDataPoint(mb.startTime, ts, val)
}

// RecordVcenterHostCPUUsageDataPoint adds a data point to vcenter.host.cpu.usage metric.
func (mb *MetricsBuilder) RecordVcenterHostCPUUsageDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricVcenterHostCPUUsage.recordDataPoint(mb.startTime, ts, val)
}

// RecordVcenterHostCPUUtilizationDataPoint adds a data point to vcenter.host.cpu.utilization metric.
func (mb *MetricsBuilder) RecordVcenterHostCPUUtilizationDataPoint(ts pdata.Timestamp, val float64) {
	mb.metricVcenterHostCPUUtilization.recordDataPoint(mb.startTime, ts, val)
}

// RecordVcenterHostDiskLatencyAvgDataPoint adds a data point to vcenter.host.disk.latency.avg metric.
func (mb *MetricsBuilder) RecordVcenterHostDiskLatencyAvgDataPoint(ts pdata.Timestamp, val int64, latencyDirectionAttributeValue string, latencyTypeAttributeValue string) {
	mb.metricVcenterHostDiskLatencyAvg.recordDataPoint(mb.startTime, ts, val, latencyDirectionAttributeValue, latencyTypeAttributeValue)
}

// RecordVcenterHostDiskLatencyTotalDataPoint adds a data point to vcenter.host.disk.latency.total metric.
func (mb *MetricsBuilder) RecordVcenterHostDiskLatencyTotalDataPoint(ts pdata.Timestamp, val int64, latencyDirectionAttributeValue string) {
	mb.metricVcenterHostDiskLatencyTotal.recordDataPoint(mb.startTime, ts, val, latencyDirectionAttributeValue)
}

// RecordVcenterHostDiskThroughputDataPoint adds a data point to vcenter.host.disk.throughput metric.
func (mb *MetricsBuilder) RecordVcenterHostDiskThroughputDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricVcenterHostDiskThroughput.recordDataPoint(mb.startTime, ts, val)
}

// RecordVcenterHostMemoryUsageDataPoint adds a data point to vcenter.host.memory.usage metric.
func (mb *MetricsBuilder) RecordVcenterHostMemoryUsageDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricVcenterHostMemoryUsage.recordDataPoint(mb.startTime, ts, val)
}

// RecordVcenterHostMemoryUtilizationDataPoint adds a data point to vcenter.host.memory.utilization metric.
func (mb *MetricsBuilder) RecordVcenterHostMemoryUtilizationDataPoint(ts pdata.Timestamp, val float64) {
	mb.metricVcenterHostMemoryUtilization.recordDataPoint(mb.startTime, ts, val)
}

// RecordVcenterHostNetworkErrorsDataPoint adds a data point to vcenter.host.network.errors metric.
func (mb *MetricsBuilder) RecordVcenterHostNetworkErrorsDataPoint(ts pdata.Timestamp, val int64, throughputDirectionAttributeValue string) {
	mb.metricVcenterHostNetworkErrors.recordDataPoint(mb.startTime, ts, val, throughputDirectionAttributeValue)
}

// RecordVcenterHostNetworkPacketsDataPoint adds a data point to vcenter.host.network.packets metric.
func (mb *MetricsBuilder) RecordVcenterHostNetworkPacketsDataPoint(ts pdata.Timestamp, val int64, throughputDirectionAttributeValue string) {
	mb.metricVcenterHostNetworkPackets.recordDataPoint(mb.startTime, ts, val, throughputDirectionAttributeValue)
}

// RecordVcenterHostNetworkThroughputDataPoint adds a data point to vcenter.host.network.throughput metric.
func (mb *MetricsBuilder) RecordVcenterHostNetworkThroughputDataPoint(ts pdata.Timestamp, val int64, throughputDirectionAttributeValue string) {
	mb.metricVcenterHostNetworkThroughput.recordDataPoint(mb.startTime, ts, val, throughputDirectionAttributeValue)
}

// RecordVcenterHostNetworkUsageDataPoint adds a data point to vcenter.host.network.usage metric.
func (mb *MetricsBuilder) RecordVcenterHostNetworkUsageDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricVcenterHostNetworkUsage.recordDataPoint(mb.startTime, ts, val)
}

// RecordVcenterHostVsanCacheHitRateDataPoint adds a data point to vcenter.host.vsan.cache.hit_rate metric.
func (mb *MetricsBuilder) RecordVcenterHostVsanCacheHitRateDataPoint(ts pdata.Timestamp, val float64) {
	mb.metricVcenterHostVsanCacheHitRate.recordDataPoint(mb.startTime, ts, val)
}

// RecordVcenterHostVsanCacheReadsDataPoint adds a data point to vcenter.host.vsan.cache.reads metric.
func (mb *MetricsBuilder) RecordVcenterHostVsanCacheReadsDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricVcenterHostVsanCacheReads.recordDataPoint(mb.startTime, ts, val)
}

// RecordVcenterHostVsanCongestionsDataPoint adds a data point to vcenter.host.vsan.congestions metric.
func (mb *MetricsBuilder) RecordVcenterHostVsanCongestionsDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricVcenterHostVsanCongestions.recordDataPoint(mb.startTime, ts, val)
}

// RecordVcenterHostVsanLatencyAvgDataPoint adds a data point to vcenter.host.vsan.latency.avg metric.
func (mb *MetricsBuilder) RecordVcenterHostVsanLatencyAvgDataPoint(ts pdata.Timestamp, val int64, vsanLatencyTypeAttributeValue string) {
	mb.metricVcenterHostVsanLatencyAvg.recordDataPoint(mb.startTime, ts, val, vsanLatencyTypeAttributeValue)
}

// RecordVcenterHostVsanOperationsDataPoint adds a data point to vcenter.host.vsan.operations metric.
func (mb *MetricsBuilder) RecordVcenterHostVsanOperationsDataPoint(ts pdata.Timestamp, val int64, vsanOperationTypeAttributeValue string) {
	mb.metricVcenterHostVsanOperations.recordDataPoint(mb.startTime, ts, val, vsanOperationTypeAttributeValue)
}

// RecordVcenterHostVsanOutstandingIoDataPoint adds a data point to vcenter.host.vsan.outstanding_io metric.
func (mb *MetricsBuilder) RecordVcenterHostVsanOutstandingIoDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricVcenterHostVsanOutstandingIo.recordDataPoint(mb.startTime, ts, val)
}

// RecordVcenterHostVsanThroughputDataPoint adds a data point to vcenter.host.vsan.throughput metric.
func (mb *MetricsBuilder) RecordVcenterHostVsanThroughputDataPoint(ts pdata.Timestamp, val int64, vsanThroughputDirectionAttributeValue string) {
	mb.metricVcenterHostVsanThroughput.recordDataPoint(mb.startTime, ts, val, vsanThroughputDirectionAttributeValue)
}

// RecordVcenterResourcePoolCPUSharesDataPoint adds a data point to vcenter.resource_pool.cpu.shares metric.
func (mb *MetricsBuilder) RecordVcenterResourcePoolCPUSharesDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricVcenterResourcePoolCPUShares.recordDataPoint(mb.startTime, ts, val)
}

// RecordVcenterResourcePoolCPUUsageDataPoint adds a data point to vcenter.resource_pool.cpu.usage metric.
func (mb *MetricsBuilder) RecordVcenterResourcePoolCPUUsageDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricVcenterResourcePoolCPUUsage.recordDataPoint(mb.startTime, ts, val)
}

// RecordVcenterResourcePoolMemorySharesDataPoint adds a data point to vcenter.resource_pool.memory.shares metric.
func (mb *MetricsBuilder) RecordVcenterResourcePoolMemorySharesDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricVcenterResourcePoolMemoryShares.recordDataPoint(mb.startTime, ts, val)
}

// RecordVcenterResourcePoolMemoryUsageDataPoint adds a data point to vcenter.resource_pool.memory.usage metric.
func (mb *MetricsBuilder) RecordVcenterResourcePoolMemoryUsageDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricVcenterResourcePoolMemoryUsage.recordDataPoint(mb.startTime, ts, val)
}

// RecordVcenterVMCPUUtilizationDataPoint adds a data point to vcenter.vm.cpu.utilization metric.
func (mb *MetricsBuilder) RecordVcenterVMCPUUtilizationDataPoint(ts pdata.Timestamp, val float64) {
	mb.metricVcenterVMCPUUtilization.recordDataPoint(mb.startTime, ts, val)
}

// RecordVcenterVMDiskLatencyAvgDataPoint adds a data point to vcenter.vm.disk.latency.avg metric.
func (mb *MetricsBuilder) RecordVcenterVMDiskLatencyAvgDataPoint(ts pdata.Timestamp, val int64, latencyDirectionAttributeValue string) {
	mb.metricVcenterVMDiskLatencyAvg.recordDataPoint(mb.startTime, ts, val, latencyDirectionAttributeValue)
}

// RecordVcenterVMDiskLatencyMaxDataPoint adds a data point to vcenter.vm.disk.latency.max metric.
func (mb *MetricsBuilder) RecordVcenterVMDiskLatencyMaxDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricVcenterVMDiskLatencyMax.recordDataPoint(mb.startTime, ts, val)
}

// RecordVcenterVMDiskThroughputDataPoint adds a data point to vcenter.vm.disk.throughput metric.
func (mb *MetricsBuilder) RecordVcenterVMDiskThroughputDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricVcenterVMDiskThroughput.recordDataPoint(mb.startTime, ts, val)
}

// RecordVcenterVMDiskUsageDataPoint adds a data point to vcenter.vm.disk.usage metric.
func (mb *MetricsBuilder) RecordVcenterVMDiskUsageDataPoint(ts pdata.Timestamp, val int64, diskStateAttributeValue string) {
	mb.metricVcenterVMDiskUsage.recordDataPoint(mb.startTime, ts, val, diskStateAttributeValue)
}

// RecordVcenterVMDiskUtilizationDataPoint adds a data point to vcenter.vm.disk.utilization metric.
func (mb *MetricsBuilder) RecordVcenterVMDiskUtilizationDataPoint(ts pdata.Timestamp, val float64) {
	mb.metricVcenterVMDiskUtilization.recordDataPoint(mb.startTime, ts, val)
}

// RecordVcenterVMMemoryBalloonedDataPoint adds a data point to vcenter.vm.memory.ballooned metric.
func (mb *MetricsBuilder) RecordVcenterVMMemoryBalloonedDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricVcenterVMMemoryBallooned.recordDataPoint(mb.startTime, ts, val)
}

// RecordVcenterVMMemoryUsageDataPoint adds a data point to vcenter.vm.memory.usage metric.
func (mb *MetricsBuilder) RecordVcenterVMMemoryUsageDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricVcenterVMMemoryUsage.recordDataPoint(mb.startTime, ts, val)
}

// RecordVcenterVMNetworkPacketsDataPoint adds a data point to vcenter.vm.network.packets metric.
func (mb *MetricsBuilder) RecordVcenterVMNetworkPacketsDataPoint(ts pdata.Timestamp, val int64, throughputDirectionAttributeValue string) {
	mb.metricVcenterVMNetworkPackets.recordDataPoint(mb.startTime, ts, val, throughputDirectionAttributeValue)
}

// RecordVcenterVMNetworkThroughputDataPoint adds a data point to vcenter.vm.network.throughput metric.
func (mb *MetricsBuilder) RecordVcenterVMNetworkThroughputDataPoint(ts pdata.Timestamp, val int64, throughputDirectionAttributeValue string) {
	mb.metricVcenterVMNetworkThroughput.recordDataPoint(mb.startTime, ts, val, throughputDirectionAttributeValue)
}

// RecordVcenterVMNetworkUsageDataPoint adds a data point to vcenter.vm.network.usage metric.
func (mb *MetricsBuilder) RecordVcenterVMNetworkUsageDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricVcenterVMNetworkUsage.recordDataPoint(mb.startTime, ts, val)
}

// RecordVcenterVMVsanLatencyAvgDataPoint adds a data point to vcenter.vm.vsan.latency.avg metric.
func (mb *MetricsBuilder) RecordVcenterVMVsanLatencyAvgDataPoint(ts pdata.Timestamp, val int64, vsanLatencyTypeAttributeValue string) {
	mb.metricVcenterVMVsanLatencyAvg.recordDataPoint(mb.startTime, ts, val, vsanLatencyTypeAttributeValue)
}

// RecordVcenterVMVsanOperationsDataPoint adds a data point to vcenter.vm.vsan.operations metric.
func (mb *MetricsBuilder) RecordVcenterVMVsanOperationsDataPoint(ts pdata.Timestamp, val int64, vsanOperationTypeAttributeValue string) {
	mb.metricVcenterVMVsanOperations.recordDataPoint(mb.startTime, ts, val, vsanOperationTypeAttributeValue)
}

// RecordVcenterVMVsanThroughputDataPoint adds a data point to vcenter.vm.vsan.throughput metric.
func (mb *MetricsBuilder) RecordVcenterVMVsanThroughputDataPoint(ts pdata.Timestamp, val int64, vsanThroughputDirectionAttributeValue string) {
	mb.metricVcenterVMVsanThroughput.recordDataPoint(mb.startTime, ts, val, vsanThroughputDirectionAttributeValue)
}

// Reset resets metrics builder to its initial state. It should be used when external metrics source is restarted,
// and metrics builder should update its startTime and reset it's internal state accordingly.
func (mb *MetricsBuilder) Reset(options ...metricBuilderOption) {
	mb.startTime = pdata.NewTimestampFromTime(time.Now())
	for _, op := range options {
		op(mb)
	}
}

// Attributes contains the possible metric attributes that can be used.
var Attributes = struct {
	// DiskState (The state of storage and whether it is already allocated or free.)
	DiskState string
	// HostEffective (Whether the host is effective in the vCenter cluster)
	HostEffective string
	// LatencyDirection (The direction of disk latency.)
	LatencyDirection string
	// LatencyType (The type of disk latency being reported.)
	LatencyType string
	// ThroughputDirection (The direction of network throughput.)
	ThroughputDirection string
	// VMCountPowerState (Whether the virtual machines are powered on or off)
	VMCountPowerState string
	// VsanLatencyType (The type of vSAN latency.)
	VsanLatencyType string
	// VsanOperationType (The type of vSAN operation.)
	VsanOperationType string
	// VsanThroughputDirection (The type of vSAN throughput.)
	VsanThroughputDirection string
}{
	"disk_state",
	"effective",
	"direction",
	"type",
	"direction",
	"power_state",
	"type",
	"type",
	"direction",
}

// A is an alias for Attributes.
var A = Attributes

// AttributeDiskState are the possible values that the attribute "disk_state" can have.
var AttributeDiskState = struct {
	Available string
	Used      string
}{
	"available",
	"used",
}

// AttributeHostEffective are the possible values that the attribute "host_effective" can have.
var AttributeHostEffective = struct {
	True  string
	False string
}{
	"true",
	"false",
}

// AttributeLatencyDirection are the possible values that the attribute "latency_direction" can have.
var AttributeLatencyDirection = struct {
	Read  string
	Write string
}{
	"read",
	"write",
}

// AttributeLatencyType are the possible values that the attribute "latency_type" can have.
var AttributeLatencyType = struct {
	Kernel string
	Device string
}{
	"kernel",
	"device",
}

// AttributeThroughputDirection are the possible values that the attribute "throughput_direction" can have.
var AttributeThroughputDirection = struct {
	Transmitted string
	Received    string
}{
	"transmitted",
	"received",
}

// AttributeVMCountPowerState are the possible values that the attribute "vm_count_power_state" can have.
var AttributeVMCountPowerState = struct {
	On  string
	Off string
}{
	"on",
	"off",
}

// AttributeVsanLatencyType are the possible values that the attribute "vsan_latency_type" can have.
var AttributeVsanLatencyType = struct {
	Read  string
	Write string
}{
	"read",
	"write",
}

// AttributeVsanOperationType are the possible values that the attribute "vsan_operation_type" can have.
var AttributeVsanOperationType = struct {
	Read  string
	Write string
	Unmap string
}{
	"read",
	"write",
	"unmap",
}

// AttributeVsanThroughputDirection are the possible values that the attribute "vsan_throughput_direction" can have.
var AttributeVsanThroughputDirection = struct {
	Read  string
	Write string
}{
	"read",
	"write",
}
